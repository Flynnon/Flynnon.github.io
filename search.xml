<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[红包算法]]></title>
    <url>%2F2018%2F06%2F03-%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[前因 最近Flynnon的舍友来北京找工作,因此几个同学一起聚了下,聊的聊的就聊到了他的面试经历,其中有一道算法题,而他当时没有思路,我们进行了讨论,在这里做个记录. 题目 仿照微信红包设计一个红包分配算法,要求: 1. 抽奖公平; 2. 手气最好的人抽到的红包金额不大于手气最差的人的10倍. 初始思路 在看到这道题目时,首先意识到要用随机数生成算法以保证相对公平.然后对随机的范围进行限制即可.代码如下: 1234567891011121314151617181920212223242526272829303132333435363738394041# coding=utf-8from __future__ import print_functionimport random# 思路:# 设 总金额为total,最大倍数为m,红包个数为total# 那么先考虑极端情况,只有一个人抽到大红包y,其余人金额相等且均为小红包x,则: y &lt; m * x, y + (count - 1) * x = total# 推导出 x &gt; total / (m + count - 1), 这样就能算出每人领取的红包的最小值, 接下来可以认为每个人都是从手气最好的人那里随机抢了一点点.....# 总金额total = 100# 红包数目count = 10# 最大倍数max_multiple = 10# 每个人抽到的红包的列表money_list = []# 最小红包金额min_value = total * 1.0 / (max_multiple + count - 1)# 最大红包金额max_value = min_value * max_multiplefor i in range(count): # 当只有最后一个红包时,余额就是红包金额 if count == 1: money_list.append(total) break # 随机数的范围是 (min_value, max_value), 因为能抢的部分只是手气最好的人比其它人多的部分 the_value = random.random() * (max_value - min_value) + min_value # 总金额变少 total = total - the_value # 红包总数减一 count -= 1 # 重新求出其余人的上界, 这里减去的部分是指从手气最好的用户那里抢去的金额 max_value = max_value - (the_value - min_value) money_list.append(the_value)print(money_list) 变化思路 上述版本写完后,总感觉有些复杂,因此重新理了一下思路,发现上面想的有些复杂,简单思路如下: 123456789101112131415161718192021222324252627282930313233343536373839404142434445# coding=utf-8from __future__ import print_functionimport random# 思路:# 设 总金额为total,最大倍数为m,红包个数为total# 那么先考虑极端情况,只有一个人抽到大红包y,其余人金额相等且均为小红包x,则: y &lt; m * x, y + (count - 1) * x = total# 推导出 x &gt; total / (m + count - 1), 这样就能算出每人领取的红包的最小值# 然后,先假设每个用户都得到了一份最小红包,那么这个问题就简化为了 随机生成count个随机数,使得它们的和为 total - count * x,简单很多...# 总金额total = 100# 红包数目count = 10# 最大倍数max_multiple = 10# 每个人抽到的红包的列表money_list = []# 最小红包金额min_value = total * 1.0 / (max_multiple + count - 1)# 每个用户都得到最小红包数之后的剩余金额,即公共部分remain_value = total - min_value * countfor i in range(count): # 当只有最后一个红包时,余额就是红包金额 if count == 1: money_list.append(total) break # 随机数的范围是 (0, remain_value), 即公共部分任取 tmp_value = random.random() * remain_value the_value = tmp_value + min_value # 总金额变少 total = total - the_value # 红包总数减一 count -= 1 # 重新求出剩余部分的金额数 remain_value -= tmp_value money_list.append(the_value)print(money_list) 总结 有的时候换种思路,事情就会好做很多. 另外就是Flynnon的算法比起刚毕业的时候真是差的越来越多了….要找个时间训练一下了….]]></content>
      <tags>
        <tag>算法,杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改造博客记]]></title>
    <url>%2F2018%2F05%2F27-%E6%94%B9%E9%80%A0%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[前言 在写了一段时间的博客后,感觉一直使用 Github Page 默认的地址优点不好记,因此产生了使用自己域名的想法.下面是实际操作过程中的一些记录. 域名购买 这一步是很简单的,直接从阿里云(万网)购买了心仪的域名 www.flynnon.com. 配置域名解析 因为是从阿里云购买的域名,因此顺理成章的配置了域名解析(免费版),这里很简单的配置了一下,大概就是将域名本身指向我购买的服务器的IP地址. 由于Flynnon的主机是从搬瓦工购买的,因此无法备案(当然也不需要备案).但是没有备案总感觉不保险,因此专门配置了CNAME类型的解析规则将blog.flynnon.com这个域名指向我的Github Page的地址了…. 注意: 这一步的时候,需要在source文件夹下创建一个CNAME文件,并将你配置的域名写入其中(比如我就写了blog.flynnon.com),否则Github Page会认为从该URL来的访问不合法. 折腾 在进行完上面几步后,就可以通过blog.flynnon.com来访问Flynnon的博客了,但Flynnon还想用自己购买的云主机来发布博客.因此又在这个基础上进行了一些折腾. Nginx 首先,需要一个服务器软件,这里Flynnon选择了Nginx.原因是它既是一个Web服务器(作为启动博客的服务器程序),也可以做反向代理(Flynnon想用它来为其余的服务分配一个好记的URL).当然,更重要的是,Flynnon想学习一下Nginx的使用…. Nginx使用apt包管理工具进行安装十分方便. 123# nginx的安装...写在这里都有点丢人...sudo apt updatesudo apt install nginx 配置也十分简单.下面是我最终的配置. 12345678910111213141516171819202122232425262728293031# /etc/nginx/sites-enabled/defaultupstream jenkins &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; # 设置监听的端口号 server_name www.flynnon.com; # 设置默认的hexo文件的目录位置 root /var/www/hexo; # 设置hexo的index文件名 index index.html index.htm; # 当找不到url对应的文件时返回404 location / &#123; try_files $uri $uri/ =404; &#125; # 这个是访问jenkins的设置,然后就可以通过 www.flynnon.com/jenkins 来访问jenkins了 location /jenkins &#123; proxy_pass http://jenkins; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Request-Url $request_uri; &#125;&#125; Jenkins 然后需要考虑的是,博客内容如何更新到服务器上.当然…每次更新博客的时候手动从Github上下载也不是不可以(但是太low了)…考虑了一下之后选择了使用Jenkins来进行自动构建. 安装及使用 下面记录一下Jenkins的配置过程. 123456789# Jenkins是基于Java的,因此使用前需要先安装Java.sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer# 我们按照Jenkins官网的介绍(https://jenkins.io/doc/pipeline/tour/getting-started/)使用即可,它的war包自带Jetty服务器wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war# 然后就可以直接运行了(jenkins.war中自带了jetty服务器), 使用--httpPort指定它监听的端口.java -jar jenkins.war --httpPort=8080 运行完以上两步后,通过浏览器访问 www.flynnon.com/jenkins 进行配置即可.这里网上的教程很多,就不一步步展示了. 接下来比较重要的是配置Hooks来同步代码,这里有两种思路,一种是直接从Github Page所在的项目中同步,直接就可以访问.另一种是从存放Hexo博客源码的项目同步代码,然后使用 hexo -g 生成HTML文件.这两种方式都可以.就不细写了..需要注意的是文件需要放置到nginx配置的目录中. 补充:实际使用时发现,jenkins默认的登录页面是 ip:port/login?from=..,也就是说访问 www.flynnon.com/jenkins 时会自动跳转到 www.flynnon.com/login?from=%2Fjenkins…这样肯定是不行的,查了半天之后还是没解决,后来通过请教同事(师傅)发现了参数介绍.使用 –prefix 可以解决这个问题. Webhooks配置 为了实现自动发布,需要配置hooks,在Jenkins这边需要安装对应的插件,并且在博客任务中进行接收自动发布的勾选.这些资料网上很多,就不详细记录了. 代码管理方面.因为github的私有仓库很贵,因此Flynnon使用了bitbucket来进行博客源码的存放,为了实现自动发布,在github/bitbucket上进行了jenkins hooks的配置.一定要注意回调地址,千万不要写错(妈蛋…).它们都是HTTP协议的URI,但是bitbucket的hooks的url为: {jenkins_url}/bitbucket-hook/, 而github的url为 {jenkins_url}/github-webhook/. 一定不要想当然的复制!!! Execute Shell 在拿到源码后,需要进行额外的一些处理,在Jenkins中是在增加的构建步骤中处理,因为Flynnon对于shell更加熟悉,因此选择了增加Execute Shell. 如果在同步方式选择了同步生成代码的话,这一步就很简单了,配置如下: 123cd $&#123;WORKSPACE&#125;rm -rf /var/www/hexo/*cp -r ./* /var/www/hexo/ 如果选择了同步源码,就需要安装npm,然后进行生成.为了简单点,我使用了docker充当环境,下面有详细介绍. supervisor 其实进行完以上步骤之后就可以用了,但是每次都得手动/半自动(执行写好的shell脚本)对jenkins进行启动,并且挂了也没法自动重启.因此针对这个需求又使用了supervisor来进行管理. 1234567891011121314151617# 安装supervisorsudo apt install supervisor# supervisor的配置文件位于此目录下cd /etc/supervisor/# 这里图简单,直接修改了主配置文件.更好的做法是在conf.d目录下新建一个自定义的配置文件vim supervisord.conf# 下面是一些常用命令. 其中后面四个命令均可以省略 -c 参数# supervisord -c supervisor.conf 通过配置文件启动supervisor# supervisorctl -c supervisor.conf status 查看状态# supervisorctl -c supervisor.conf start [all]|[x] 启动所有/指定的程序进程# supervisorctl -c supervisor.conf stop [all]|[x] 关闭所有/指定的程序进程# supervisorctl -c supervisor.conf reload 重新载入配置文件# 这里我们只需要重新载入配置文件即可sudo supervisorctl reload 我的supervisor配置如下: 1234567[program:jenkins]command=java -jar /opt/jenkins.war --httpPort=8080 --prefix=/jenkinsuser=flynnonautostart=trueautorestart=truestartsecs=30startretries=8 docker 如果在同步方式选择了同步源码的话,还需要安装npm,但是作为一个后端开发,本人对于npm并不是很熟悉,而且怕被弄乱系统,因此选择了使用docker来启动一个npm的容器,这样就简单很多(反正它也只是用来安装hexo和生成博客的). Dockerfile如下: 123456789FROM node:10MAINTAINER tangfei_cn@foxmail.comWORKDIR /appCOPY ./package.json .# 国内的服务器,可以加上 npm config set registry https://registry.npm.taobao.org 设置源RUN npm install -g hexo-cli &amp;&amp; npm install -g &amp;&amp; npm install hexo --save 然后只需要在博客源码所在的页面执行下面一条语句即可.可以进行的优化有:使用alpine-node进行容器的体积优化.当然也可以直接换个思路…. 123# 这里的主要思路是将docker作为npm环境,然后将博客目录映射到容器中的对应目录进行构建.# 将生成的html文件所在的目录保存在本机上提供给nginx进行发布.docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generate 最终,我的Jenkins Shell中的配置如下: 123456789# 这里使用了jenkins自带的一些环境变量,避免硬编码cd $&#123;WORKSPACE&#125;docker build -t hexo:0.1 ./docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generaterm -rf /var/www/hexo/*cp -r ./public/* /var/www/hexo/# 为了解决权限问题...chmod o+r /var/www/hexo 在我的预想中,这个任务应该能正常运行,但是又遇到了权限问题…在将文件拷贝到 /var/www/hexo/ 下后,nginx无法读取该目录下的文件,导致502了…因此将supervisor中jenkins程序的user改成了root,并在Jenkins Shell的最后加了一句修改文件夹权限的命令… 总结 这一步之后,博客就搭建完成了,目前很符合我的需求,虽然不完美,但是已经没有了改动的想法. 如果你在仿照这篇博客搭建自己的博客时遇到了什么问题,或者觉得哪里不满足需求,可以联系我~]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习-总结]]></title>
    <url>%2F2018%2F04%2F25-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(7).html</url>
    <content type="text"><![CDATA[前言 总算是断断续续的看完了,但是由于实践比较少,因此很多语法并没有深入的认识.但是也不能说完全没有收获,至少有了一些印象,当再看C语言相关的代码的时候至少知道搜索的关键词是什么了(笑..). 关于收获 总感觉做事是需要带着目的去的,事后也需要做总结,来审视做这件事的得失.没有目的就很难坚持下去,没有总结就容易产生浪费而不自知. 读这本书的目的 Flynnon是一个Python开发工程师,在能熟练的使用Python进行开发后就很自然的对它的实现产生了兴趣.于是上网百度了一圈,发现有一本现成的书《Python源码剖析》.简单了解了一下之后就买了它的影印版(很可惜绝版了…).并开始了学习… 但是进度远不如预期.当然,原因是多方面的(比如说Flynnon太懒..比如说手机太好玩(;´▽`)y-~~),但评估后发现对于C的不熟悉时影响效率的很大一个因素,因此决定先复习一下C语言的知识再继续. 关于这本书 看完之后感觉,这本书并不适合初学者(也许第一版会好一些吧),因为在什么都不懂的情况下(比如,连内存的概念都没有建立起来的时候),这本书开头的铺垫有点少.另外,它也不适合高级开发者,对于它们而言介绍的知识点过于简洁了,看完后还是有很多语法/用法没有学习到. 另外,也不怎么适合我这种半吊子,也许是翻译的问题,导致看起来有一种很难受的感觉.而且这本书过于简单了,对于知识点的介绍总是浅尝辄止,导致看完后细想来并没有收获什么.附录看起来倒是蛮全的,但是实在没有心情读完了…. Flynnon本人感觉这本书并不是很好,作者的思维太发散了,导致看起来很乱,初学者依靠这本书很难建立对C语言的完整印象,而且作者的发散思维又有很强的干扰作用,会使得读者(比如Flynnon)产生先暂停看看别的书的想法,而中断又不大可能,因此会导致读完后感觉不懂的东西还是很多(当然如果本来就知道这些知识点的话,会对那些知识点有一些不同的认识). 综上,感觉本书并不是一本很好的学习C语言的书籍… 收获 其实看完后的收获并不很多,因为日常开发中基本没有用到C的场景,这段时间的实践也仅仅是在看书的过程中写了一些小的Demo.因此对于这些知识点并没有记得很牢.但至少会对C语法有一定的印象,这样在看源码的时候至少知道怎么查了.因此也算是有些收获吧..]]></content>
      <tags>
        <tag>C语言学习</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(6)]]></title>
    <url>%2F2018%2F04%2F23-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(6).html</url>
    <content type="text"><![CDATA[前言 以下记录了第八章的一些知识点.这一章主要介绍了UNIX系统中用于输入和输出的系统调用,以及如何通过它们实现标准库函数(没细写). 输入/输出 在UNIX操作系统中,所有的外围设备(包括键盘和显示器)都被看作是文件系统中的文件.因此,所有的输入/输出都要通过读文件或写文件完成.也就是说,通过一个单一的接口就可以处理外围设备和程序之间的所有通信. 文件描述符 用户程序并不能直接操作文件(实际上文件仅仅是一种抽象),这部分权力被系统所接管.用户程序只能通过与系统交互得到一个文件描述符来对对应文件进行操作. 概念 文件描述符(File Descriptor)通常是一个小的非负整数,内核用以标识一个特定进程正在访问的文件.当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符.系统负责维护已打开文件的所有信息,用户程序只能通过文件描述符引用文件. 特殊的文件描述符 针对大多数的输入/输出是通过键盘和显示器来进行的这一现象,UNIX中的shell程序进行了优化.即: 把文件描述符0与进程的标准输入(standard input)关联,文件描述符1与标准输出(standard output)关联,文件描述符2与标准错误(standard error)关联. 这样的话,只要shell程序使用文件0作为输入,文件1和2作为输出,它就不会也无需知道程序的输入从哪里来,并输出到哪里去。 事实上,当我们通过shell进行简单的读写时,并不需要考虑什么文件描述符,直接使用read函数读取文本,再使用echo函数输出即可. 1234#!/bin/bash# demo.shread textecho $&#123;text&#125; 而使用者可以很方便的使用管道与0,1,2这三个文件描述符来进行重定向. 1234# 运行demo.sh文件./demo.sh # 从标准输入读取,并输出到标准输出./demo.sh &lt; la.txt &gt; xx.txt # 从la.txt进行读取,并输出到xx.txt# 通常,文件描述符2仍与显示器相关联.这样,出错信息会输出到显示器上 低级I/O 输入与输出是通过read和write系统调用实现的. 123456789/* 系统调用 */// 两个系统调用的函数都是类似的:// 参数: 第一个参数都是文件描述符,第二个参数是程序中存放读或写的数据的字符数组,第三个参数是要传输的字节数.// 返回值: 每个调用返回的都是实际传输的字节数,具体不同如下.int read(int fd, char *buf, int n); // 函数的返回值可能会小于请求的字节数.如果返回值为0,则表示已到达文件的结尾;如果返回值为-1,则表示发生了某种错误.int write(int fd, char *buf, int n); // 返回值是实际写入的字节数.如果返回值与请求写入的字节数不相等,则说明发生了错误 在一次调用中,读出或写入的数据的字节数可以为任意大小.但是,用更大的值调用该函数可以获得更高的效率,因为系统调用的次数减少了.但是一次读取太多的话,占用内存又会变多….所以需要权衡… 文件操作读取1234// open的函数签名// 参数: name为文件名, flags为打开方式, perms代表权限// 返回值: 所打开的文件的文件描述符,打开失败则返回-1.int open(char *name, int flags, int perms); open函数主要支持的几种打开方式: 名称 含义 对应 O_RDONLY 只读模式打开 r O_WRONLY 只写方式打开 w O_RDWR 读写方式打开 a 创建 12345// create的函数签名// 参数: name代表文件名, perms代表所创建的文件的权限.// 返回值: 所创建文件的文件描述符,打开失败则返回-1.// 如果此文件已存在,create将把该文件的长度截断为0,从而丢弃原先已有的内容(也就是覆盖).这个过程并不会报错,且权限不会更改. int create(char *name, int perms); 关闭 一个程序能同时打开的文件数目是有限制的(一般为20),因此当一个程序需要同时处理许多文件时,要么更改系统的限制数目要么重用文件描述符. 作为一个合格的程序,不应该擅自更改一些系统变量.因此,比较好的方法是重用文件标识符.其实也就是释放原来占用的文件标识符,再申请新的文件标识符. close用来断开文件描述符和已打开文件之间的连接,并释放此文件描述符,以供其它文件使用. 1234// close的函数签名// 参数: 要关闭的文件的文件标识符// 返回值: 成功返回0,出错返回-1.int close(int fd); close的功能与fclose类似,但是fclose会刷新缓冲区,而close不会. 当一个进程终止时,内核对该进程所有尚未关闭的文件描述符调用close关闭,所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的所有文件. 删除 unlink将一个名称(这个涉及到软连接与硬链接..)从系统中删除. 1234// unlink的函数签名// 参数: 要删除的文件名// 返回值: 成功执行时,返回0;失败返回-1.int unlink(const char *pathname); 随机访问 上面介绍的read和write方法在访问文件时时顺序进行的,也就是在访问第1000个字符时需要先顺序访问前999个,但是对于我们的需求来说,这就有点浪费了,我们实际上需要一种可以直接从开头跳到第1000个字符的方法,也就是随机访问. 正好,系统调用lseek与fseek可以在文件中任意移动位置而不实际读写任何数据. 123456789101112131415161718192021222324252627// lseek的函数签名// 参数: fd -&gt; 要操作的文件的文件描述符// offset -&gt; 偏移量(相对于origin而言的),当origin参数不为0时,offset参数可以为负值// origin -&gt; 定位符(0表示以文件开头位置为基点,1表示以当前位置为基点,2表示以文件结束位置为基点).// 返回值: 调用成功时返回目前的读写位置,也就是距文件开头的字节数.若有错误则返回-1.long lseek(int fd, long offset, int origin);// 示例: 指向文件的末尾lseek(fd, 0L, 2);// fseek的函数签名// 参数: stream -&gt; 代表要操作的文件的文件指针// offset -&gt; 与上同// origin -&gt; 与上同// 返回值: 调用成功时返回0,若有错误则返回一个非零值.// 附加说明: fseek不像lseek会返回读写位置,因此必须使用ftell()来取得目前读写的位置int fseek(FILE * stream, long offset, int origin);// 示例: 指向文件的末尾fseek(FILE *stream, 0, 2);// ftell的函数签名// 参数: stream -&gt; 代表要操作的文件的文件指针// 返回值: 调用成功时返回目前的读写位置,也就是距文件开头的字节数.出错则返回-1.long ftell(FILE *stream); 获取文件信息 UNIX中,文件的信息是存储在inode表中的,而文件名仅仅是inode的一个别称. 也就是说,在UNIX中通过文件名打开文件需要经历以下步骤: 1.系统找到这个文件名对应的inode号码; 2.系统通过inode号码,获取到对应的inode信息; 3.根据inode信息,定位文件数据所在的block,读出数据. 在UNIX系统中,目录就是文件.目录文件的结构非常简单,就是一系列目录项(dirent)的列表.每个目录项,由两部分组成:所包含文件的文件名,以及该文件名对应的inode号码. 我们可以通过系统调用stat来获取某文件的信息. 1234567891011121314151617181920212223// stat的函数签名// 参数: path -&gt; 代表要操作的文件的路径// buf -&gt; 用来承载文件信息的stat结构体对象的指针// 返回值: 返回文件的i结点中的所有信息;若出错,则返回-1.int stat(const char *path, struct stat *buf);// 头文件&lt;sys/stat.h&gt;中包含了描述stat的返回值的结构// 这个就不细写了,用到的时候查就可以了~(Flynnon还是太懒了...)struct stat &#123; mode_t st_mode; //文件对应的模式,文件,目录等信息. ino_t st_ino; //inode节点号 dev_t st_dev; //设备号码 dev_t st_rdev; //特殊设备号码 nlink_t st_nlink; //文件的连接数 uid_t st_uid; //文件所有者 gid_t st_gid; //文件所有者对应的组 off_t st_size; //普通文件,对应的文件字节数 time_t st_atime; //文件最后被访问的时间 time_t st_mtime; //文件内容最后被修改的时间 time_t st_ctime; //文件状态改变时间 blksize_t st_blksize; //文件内容对应的块大小 blkcnt_t st_blocks; //伟建内容对应的块数量&#125;; 下面给出一个使用stat系统调用的例子. 123456789#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() &#123; struct stat buf; stat("/etc/hosts", &amp;buf); printf("/etc/hosts file size = %d\n", buf.st_size); // 通过stat系统调用得到了某个文件的大小并打印&#125; 扩展 UNIX系统中的权限是由九位二进制数字控制的,具体如下: 1.从左至右,1-3位数字代表文件所有者的权限,4-6位数字代表同组用户的权限,7-9数字代表其他用户的权限. 2.每三位中,第一位代表读权限,第二位代表写权限,第三位代表执行权限. 也就是:代表权限的二进制的取值范围为:000 000 000 - 111 111 111,换算为八进制就是 0000 - 0777.方便起见,一般使用三个八进制的值来表示权限,例如777代表所有人拥有所有权限. 在Linux中更改文件权限的方式如下. 123456#!/bin/bash# 将某个文件的权限换成777(所有人都可读可写可执行)sudo chmod 777 $&#123;file_path&#125;# 使某文件对于其所属用户组可执行.sudo chmod g+x $&#123;file_path&#125;]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《操作系统革命》杂记]]></title>
    <url>%2F2018%2F04%2F11-%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A9%E5%91%BD%E3%80%8B%E6%9D%82%E8%AE%B0.html</url>
    <content type="text"><![CDATA[前因 最近莫名其妙的产生了自己搭建服务器的想法(已经有云服务器的前提下),结果淘宝、京东、百度、Google了一圈之后发现好像没有便宜的….但是也不是毫无收获吧,搜索的过程中,不知道在哪里看到了《操作系统革命》这个名字,感觉很高大上的样子….就搜了一下,发现B站上有这个纪录片.于是把它看完了,并进行了一些记录. 记录片基本是跟随Linux发展的时间线走的,从GNU开始说起,直到Red Hat和VA Linux的上市为止.因为是科普性质,所以很多事情都是一笔带过的. 大事记 比尔盖茨首先提出了软件是需要收费的. Richard Stallman从1983年开始逐步开启了GNU计划,并聚集了一帮人开发出了除了内核之外的一套操作系统上的工具.在这个过程中他创建了Free Software Foundation(自由软件基金会). 而Linus比他们早开发出内核(Linux内核),因此1992年,两方结合组成了一个完整的操作系统生态. 因为后来Linux这个名字使用更加广泛,因此Richard与Linus两位大佬谁都不服谁…纪录片中那个颁奖视频中一个在强调是GNU(GNU/Linux)系统而不是Linux系统,另一个在逗娃… 1998年的GNU自称为Free Software(Free是指开放,即源代码可以获取、修改),然而人们总把它与免费联系在一起,认为它不能赚钱,违背了商业道德.基于此以及理念上的不同,Eric,Linus等一批人提出了Open Source的概念,并成立了开放源代码促进会. IE使用捆绑、免费打败网景之后,网景开始担心微软滥用市场地位,修改通用标准(HTML/HTTP)等,使其它软件公司(网景等)被迫退出服务器市场.,因此决定开放源代码(把源代码本身开做产品,借助公司之外的人开发软件).这个决定使得OpenSource与Linux进入到更多人的视线(毕竟大公司). 自由软件社团的人组织对微软发起退款运动…使得计算机制造商允许人们购买未预装操作系统的电脑. Red Hat与VA Linux的上市,标志着Linux系统与开源的巨大胜利(当然,记录片中的VA Linux,现在基本没听到过这个名字了…). Linux内核发展简史 1991年,Linux 0.01发布,1万行代码,1个用户. 1992年,Linux 0.96发布,4万行代码,1000个用户. 1993年,Apache项目正式启动,促进了Internet发展的同时,并使得Linux系统使用人数快速增长(使用这一套很省钱且很快就可以搭建一个Web服务器,回报比NT高).并且Apache的市场份额逐渐增加(可靠、灵活、可扩展). 1994年,Linux 1.0发布,17万行代码. 1995年,Linux 1.2发布,25万行代码,50万用户. 1997年,Linux 2.1发布,80万行代码,350万用户. 1998年,Linux 2.110发布,150万行代码,750万用户. 1998年,开放源代码促进会(Open Source Intiative)成立. 1999年,Linux 2.2发布,1200万用户. 1999年,RED HAT成为首个上市的Linux公司. 自由(Free)与开源(Open Source)自由软件中的四种自由: 自由之零：不论目的为何，有使用该软件的自由; 自由之一：有研究该软件如何运作的自由，并且得以修改该软件来匹配用户自身的需求。获取该软件之源码为达成此目的之前提; 自由之二：有重新散布该软件的自由，所以每个人都可以借由散布自由软件来敦亲睦邻; 自由之三：有改善再利用该软件的自由,并且可以发表修订后的版本供公众使用,如此一来，整个社区都可以受惠.如前项,获取该软件之源码为达成此目的之前提. Open Source许可证原则: 1.自由的重新发布(无所谓收不收费); 2.必须附带源码； 3.衍生著作,拿到别人的源码后可在遵循统一协议的情况下再发布; 4.必须保证原作者程序的完整性,须使用版本号分别; 5.没有对个人或组织的歧视; 6.没有对任何领域的歧视; 7.许可证是可继承的; 8.不针对特定系统; 9.不能损坏其它程序的许可性质. 纪录片中对自由软件与Free Software区别的解释: Open Source 关注的是可以由此形成一个社团,成员通过交流与改进软件来相互协作. Free Software 关注的是与他人合作的自由、组织社团的自由. GUN基金会的解释: https://www.gnu.org/philosophy/free-software-for-freedom.zh-cn.html 收获 其实看完之后,收获真的不多…只能说了解了Linux发展的历史,以及对闭源,开源和自由软件有了一点了解. 我认为开源本身对于开发者的好处是显而易见的,可以通过观看其它人写到代码来提升自己(得有耐心…),如果自己开发的的程序/功能被很多人使用,对于个人品牌打造很有帮助.就像记录片中的某人(没记住名字…),在面试的时候直接来了一句,某某软件是我开发的~怎一个潇洒了得. 另外,自由软件这个概念也很好,但是并不好实现,只能说盼望世界变成这样吧… 然而,闭源将软件看做劳动成果保护起来,用以获取财富;开源将软件看做知识,提倡自由分享.这两种都没错…只能说是立场之争…站在我的角度,肯定是开源好一点了(性价比高且使用时有莫名的成就感)… 再好的软件也需要推广,比如纪录片中提到的每隔一段时间的安装会,以及掀起对微软的退款游行以提高知名度.. 题外话 感觉这篇博客语法很差劲…但是又没想还咋改,希望未来的某个时间能再次看到这篇博客,并修改一番吧…]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(5)]]></title>
    <url>%2F2018%2F04%2F10-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(5).html</url>
    <content type="text"><![CDATA[前言 以下记录了第七章的一些知识点. 输入输出 标准库实现了简单的文本输入/输出模式.在这个模式中,文本流由一系列行组成,每一行的结尾是一个换行符.如果系统没有遵循这种模式,则标准库将通过一些措施使得该系统适应这种模式.例如,标准库可以在输入端将回车符和换行符都转换为换行符,而在输出端进行反向转换. 一般输入输出相关的标准函数均定义在头文件中. 标准输入输出函数12345// getchar 与 putchar // getchar从标准输入进行字符读取.函数在每次被调用时返回下一个输入字符.若遇到文件结尾,则返回EOF.int getchar(void);// putchar将字符输送至标准输出上.如果没有发生错误,则函数putchar返同输出的字符;如果发生了错误,则返回EOF.int putchar(int); 符号常量EOF(END OF FILE)在头文件中定义,其值一般为-1,但程序中应该使用EOF本身来测试文件是否结束,这样才能保证程序同EOF的特定值无关. 事实上,getchar与putchar都是宏定义而不是函数. 格式化输出 格式化输出是更高层次上的一种输出方法,通过它可以设定输出格式. 函数12345678910// printf的函数原型// printf在输出格式format的控制下,将其参数进行转换与格式化,并输出到标准输出.它的返回值为打印的字符数.// 后面三个小数点代表变长参数表(不定长参数),具体请见下方扩展int printf(char *format, ...);// sprintf的函数原型// printf在输出格式format的控制下,将其参数进行转换与格式化,并将结果存放到string中.它的返回值为打印的字符数.int sprintf(char *string, char *format, ...);// 注意:上述函数使用第一个参数判断后面参数的个数及类型.如果参数的个数不够或者类型错误,则将得到错误的结果. 格式字符串 格式字符串即printf函数与sprint函数的函数定义中的format参数. 格式字符串包含两种类型的对象:普通字符和转换说明.在输出时,普通字符(不包括%)将原样不动地复制到输出流中,而转换说明则是用于控制上述函数中其余参数(即最后不定长参数表)的转换和打印. 每个转换说明都由一个百分号字符(即%)开始,并以一个转换字符结束.合法的转换字符列表如下: 转换字符 参数类型 输出形式 d, i int 类型 十进制数 o int 类型 无符号八进制数(没有前导 0) x, X int 类型 无符号十六进制数(没有前导0x或0X),即:10~15分别用abcdef或ABCDEF表示 u int 类型 无符号十进制数 c int 类型 单个字符 s char *类型 顺序打印字符串中的字符，直到遇到’\0’或已打印了由精度指定的字符数为止 f double 类型 十进制小数[-]m.dddddd，其中d的个数由精度指定(默认值为6) e, E double 类型 科学计数法[-]m.dddddd e ±xx 或[-]m.dddddd E ±xx，其中d的个数由精度指定(默认值为 6) g, G double 类型 如果指数小于-4或大于等于精度,则用 %e/%E 格式输出,否则用 %f 格式输出.尾部的0和小数点不打印 p void *类型 指针(取决于具体实现) % 无(不转换参数) 打印一个百分号% 填充 通过在%与转换字符之间添加一些特定格式的值可以更加细致的控制输出格式(例如指定输出是左对齐还是右对齐).合法的填充如下: 填充格式 含义(作用) 负号 - 指定被转换的参数按照左对齐的形式输出 数字 指定最小字段宽度,转换后的参数将打印不小于最小字段宽度的字段.不足则用空格填充 小数点 字段宽度与精度的分隔符 数字 指定精度.(指定字符串中要打印的最大字符数,浮点数小数点后的位数,整型最少输出的数字数目) 字母 h 或 l 只能作用于整形.h表示将整数作为short类型打印. l表示将整数作为long类型打印 效果示例 下面是一些示例(以printf(format, “hello world”)为例): 格式化字符串(format) 输出结果 解释 :%12s: : hello world: 最少输出12个字符(右对齐) :%.9s: :hello wor: .分隔, 最大输出九个字符(超出的截断) :%-12s: : hello world: 最少输出12个字符(左对齐) :%-11.10s: :hello worl : .分隔, 最少输出11个字符,后面的字符串输出10位,左对齐 扩展 在printf函数与sprintf函数的声明中均使用了三个小数点(省略号)来作为参数,这种参数叫做变长参数表.它表示参数表中参数的数量和类型是可变的,且它只能出现在参数表的尾部. 变长参数表的使用: 标准头文件&lt;stdarg.h)中包含一组宏定义,它们对如何遍历参数表进行了定义.具体请见下列示例. 123456789101112131415161718192021222324252627282930313233343536373839404142/* 使用变长参数表实现一个具有printf部分功能的函数 */#include&lt;stdio.h&gt;#include&lt;stdarg.h&gt;/* 变长参数表相关的宏有 va_list, va_start, va_arg, va_end. 它们都被定义在 stdarg.h 头文件中 *//* 适应变长参数表时参数列表中至少应包括一个有名参数(例如以下示例中的fmt), va_start将最后一个有名参数作为起点 */void minprintf(char *fmt, ...)&#123; // 声明不定长参数表 va_list ap; // 使用 va_list宏 来声明一个指向变长参数表的参数指针. char *p, *sval; // 定义一些中间变量 int ival; double dval; va_start(ap, fmt); // 使用 va_start宏 来使上面声明的参数指针ap指向变长参数表中的第一个参数.在使用 ap 之前,该宏必须被调用一次 for (p = fmt; *p; p++) &#123; // 遍历 fmt 参数(即格式字符串) if (*p != '%') &#123; // 跳过格式字符串中的 % 字符 putchar(*p); continue; &#125; switch (*++p) &#123; // 根据格式字符来选择具体的打印策略 case 'd': ival = va_arg(ap, int); // 使用 va_arg宏 来从不定长参数表中读取特定类型的参数,并将参数指针移动相应的步长 printf("%d", ival); // 为了简单....使用了printf函数来完成输出时的格式转化 break; case 'f': dval = va_arg(ap, double); printf("%f", dval); break; case 's': for (sval = va_arg(ap, char *); *sval; sval++) putchar(*sval); break; default: putchar(*p); break; &#125; &#125; va_end(ap); // 使用结束后,使用 va_end宏 来完成清理工作&#125;int main(void)&#123; minprintf("%d %s %f", 1, "hahaha", 2.5); // 调用, 其结果与同参数调用printf函数相同 return 0;&#125; 格式化输入 格式化输入是更高层次上的一种输入读取方法,通过它可以对读取到的字符串进行转化,直接得到特定类型的变量. 函数12345678910111213// scanf的函数原型// scanf函数从标准输入中读取字符序列,按照format中的格式说明对字符序列进行解释,并把结果保存到其余的参数中int scanf(char *format, ...);// sscanf的函数原型// sscanf从字符串string中读取字符序列,按照format中的格式说明对字符序列进行解释,并把结果保存到其余的参数中int sscanf(char *string, char *format, ...);// 注意:// 1.scanf与sscanf函数的所有不定长参数都必须是指针,用于指定经格式转换后的相应输入保存的位置;// 2.上述函数在扫描完其格式串或者碰到某些输入无法与格式控制说明匹配的情况时,终止执行.// 3.上述函数的返回值为成功匹配并赋值的输入项的个数,而当达到文件尾时,该函数返回EOF. 即:该函数的返回值可以用来确定已匹配的输入项的个数.// 4.返回值为0表示下一个输入字符与格式串中的第一个格式说明不匹配.下一次调用scanf函数时将从上一次转换的最后一个字符的下一个字符开始继续搜索. 格式字符串 格式字符串即scanf函数与sscanf函数的函数定义中的format参数.它通常包含转换说明,用于控制输入的转换. 格式字符串包含三种类型的对象:空白字符(空格/制表符),普通字符和转换说明.在读取时,空白字符将被忽略,普通字符(不包括%),用于匹配输入流中下一个非空白符字符,而转换说明则是用于控制上述函数中其余参数(即变长参数表中的参数)的读取与转换. 每个转换说明都由一个百分号字符(即%)开始,并以一个转换字符结束.合法的转换字符列表如下: 转换字符 参数类型 读取参数格式 d int *类型 十进制整数 i int *类型 可以是八进制(以 0 开头)或十六进制(以 0x 或 0X 开头) o int *类型 八进制整数(可以以 0 开头,也可以不以 0 开头) x int *类型 十六进制整数(可以 0x 或 0X 开头,也可以不以 0x 或 0X 开头) u unsigned int *类型 无符号十进制整数 c char *类型 字符 s char *类型(指向一个足以存放该字符串(还包括尾部的字符’\0’)的字符数组.字符串的末尾将被添加一个结束符’\0’) 字符串(不加引号) e, f, g float *类型 浮点数,它可以包括正负号(可选)、小数点(可选)及指数部分(可选) % 无(不进行任何赋值操作) 不进行任何赋值操作 填充 通过在%与转换字符之间添加一些特定格式的值可以更加细致的控制读取规则.合法的填充如下: 填充格式 含义(作用) 赋值禁止字符 * 被此字符填充时,跳过该输入字段,不进行赋值 数字 指定最大字段宽度 h 只能作用于整形.h表明参数表的相应参数是一个指向short类型的指针 l 作用于整数时,表明参数表的相应参数是一个指向long类型的指针.作用于浮点数时,表明参数表的相应参数是一个指向double类型的指针 使用示例12345678910111213141516171819#include &lt;stdio.h&gt;int int_v;char char_v[20];float f_v;scanf("%d %s %*d %f", &amp;int_v, char_v, &amp;f_v);// 运行上述程序片段时,可在标准输入输入 10 lalala 3 2.8, 之后, int_v的值为10, char_v数组的前七个字符为 l a l a l a \0, f_v的值为 2.8// scanf函数忽略格式串中的空格和制表符.此外,在读取输入值时,它将跳过空白符(空格符、横向制表符、换行符、回车符、纵向制表符以及换页符).如果要读取格式不固定的输入,最好每次读入一行,然后再用sscanf将合适的格式分离出来读入.// scanf函数可以与其它输入函数混合使用,无论使用哪个输入函数,调用下一个输入函数时将从scanf没有读取的第一个字符处开始读取数据.即:每次使用scanf它的读取都会被消费,而读取失败的会被略过.// 场景: 在从标准输入读取日期时,支持多种输入格式.while (getline(line, sizeof(line)) &gt; 0) &#123; // 需要保存输入,再一一判断格式 if (sscanf(line, "%d %s %d", &amp;day, monthname, &amp;year) == 3) printf("valid: %s\n", line); // dd mm yy 格式 else if (sscanf(line, "%d/%d/%d", &amp;month, &amp;day, &amp;year) == 3) printf("valid: %s\n", line); // mm/dd/yy格式 else printf("invalid: %s\n", line);&#125; 文件操作 文件也可以看成是一种特殊的输入输出设备.事实上,在Linux系统中一切都被抽象成文件. 文件的打开 在操作文件之前,我们需要先打开一个文件.这个操作是通过头文件中的fopen函数实现的.它的介绍如下: 1234567891011#include &lt;stdio.h&gt;// fopen函数的函数签名// 第一个参数name是一个字符串,它包含了文件名(包括绝对路径).// 第二个参数mode也是一个字符串，它代表了文件的使用模式,用于指定文件的使用方式.这个参数的详细介绍在后面一点.// 它的返回值是一个可以用于文件读写操作的指针,被成为文件指针.关于文件指针,后面在详细介绍.FILE *fopen(char *name, char *mode);// fopen函数的使用// 以写模式打开一个文件FILE *fp = fopen("/home/flynnon/a.txt", "w"); fopen函数返回的文件指针实际上指向的是一个包含文件信息的结构.这些所指的信息包括:缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等状态.如果发生错误,fopen将返回 NULL. 幸运的是,我们并不需要直接与这些具体的细节打交道.这些信息已经被头文件中的FILE封装好了.这里要注意的是FILE像int一样是一个类型名,而不是一个结构标记(它是通过typedef定义的). 使用fopen打开一个文件有多种模式,见下表: 模式字符串 名称 行为 w 写模式 打开不存在的文件时,会新建.打开已存在的文件时,会将先该文件的内容清空.然后写入. r 读模式 只能对文件内容进行读取,不能写入. a 追加模式 打开不存在的文件时,会新建.打开已存在的文件时,会将指针移动到文件末尾.然后写入. r 与上述模式合用,二进制模式 用来打开二进制类型的文件. 文件内容的读写 有两个类似于getchar与putchar的从文件中操作字符的函数getc与putc,下面是介绍. 123456// getc与putc都需要一个文件指针,以得到操作的文件的信息.// getc函数返回fp指向的输入流中的下一个字符.如果到达文件尾或出现错误,该函数将返回EOF.int getc(FILE *fp);// putc函数将字符c写入到fp指向的文件中,并返回写入的字符.如果发生错误,则返回EOF.int putc(int c, FILE *fp); 同样的,也有两个类似于printf与scanf的从文件中操作字符的函数fprintf与fscanf,下面是介绍. 1234// 它们与scanf和printf函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针int fscanf(FILE *fp, char *format, ...);int fprintf(FILE *fp, char *format, ...); 特殊的文件 启动一个C语言程序时,操作系统环境负责打开3个文件,并将这3个文件的指针提供给该程序.这3个文件分别是标准输入、标准输出和标准错误,它们的文件指针分别为stdin、stdout和stderr. stdin,stdout,stderr都是常量,不能为它们重新赋值. 事实上,前面的标准输入输出函数getchar与putchar可以等同于下列定义宏定义. 123// 实际上,getchar与putchar只是从标准输入stdin中进行字符的读取与输出.#define getchar() getc(stdin)#define putchar(c) putc((c),stdout) 关闭文件 文件作为一种资源,长时间占用总是不好的.因此在使用完成之后需要关闭它.这时就会用到fclose函数. 当文件指针不再需要时及时释放是一个很好的习惯.当程序正常终止时,程序会自动为每个打开的文件调用fclose函数. 123// fclose函数关闭一个文件指针所指的文件流,把缓冲区内最后剩余的数据输出到流中,并释放函数指针和有关的缓冲区.// 如果流成功关闭,fclose返回0,否则返回EOF.int fclose(FILE *fp); 重定向 有时候在编写代码时,不想通过硬编码来指定输入输出的文件,此时可以使用freopen函数来进行流的重定向. 123456789101112// freopen函数可以把预定义的标准流文件定向到以mode模式打开的filename文件的文件指针FILE * freopen(const char *filename, const char *mode, FILE *stream);// 下列语句将标准输出重定向到了normal.log文件中freopen("normal.log", "w", stdout);// 此时下列输出语句实际上是将 "lalalal" 输出到normal.log文件中printf("lalalal");// 下列语句将标准输出重定向到了normal.log文件中freopen("normal.log", "w", stdout);// 此时下列输出语句实际上是将 "lalalal" 输出到normal.log文件中printf("lalalal"); 输出错误 前面提到标准输入输出有三种,也给出了使用stdin、stdout(使用printf,scanf,pprintf,pscanf)的例子.下面会给出一个使用stderr的示例,并介绍ferror、feof函数. 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; if(argc == 1)&#123; fprintf(stderr, "param is wrong."); // 将字符串输出到标准错误 exit(1); // 使用exit退出程序 &#125; FILE *fp = fopen("/Users/flynnon/blog/d.json", "r"); if(ferror(fp))&#123; // 检查文件流中是否有错误 fprintf(stderr, "ope file error"); exit(1); &#125; exit(0);&#125;// exit函数被调用时,调用程序将终止执行,任何调用该程序的进程都可以获取exit的参数值.// 一般以0作为正常的返回值,以其余数字作为错误的标志(可以看看Linux中的规定).// exit还会为每个已打开的输出文件调用fclose函数,以将缓冲区中的所有输出写到相应的文件中.void exit(int);// 如果流fp中出现错误,则函数ferror返回一个非0值.int ferror(FILE *fp);// 如果指定的文件到达文件结尾,它返回一个非0值.int feof(FILE *fp); 行输出与行输入 在读取文件的时候,常常有读取一行或者输出一行的需求,而使用以上的fgetc/fscanf/fputc/fprintf都不是很方便(傻瓜)…还好,C语言标准库提供了fgets与fputs方法…下面是介绍. 1234567// 输出函数fputs将一个字符串(不需要包含换行符,此函数自己根据平台添加)写入到一个文件中.发生错误时,该函数将返回EOF,否则返回一个非负值.int fputs(char *line, FILE *fp);// fgets函数从fp指向的文件中读取下一个输入行(包括换行符),并将它存放在字符数组line中,它最多可读取maxline-1个字符.// fgets读取的行将以'\0'结尾保存到数组中.// 通常情况下,fgets返回line,但如果遇到了文件结尾或发生了错误,则返回 NULL.char *fgets(char *line, int maxline, FILE *fp); 同printf与fprintf,scanf与pscanf一样,对于标准输入输出也有一对类似的函数fget与fput. puts函数在写入字符串时会在结尾添加一个换行符;而gets函数在读取字符串时会自动删除结尾的换行符(‘\n’). 常用函数 在C标准库中提供了很多常用的函数. 字符串操作相关 与字符串操作相关的函数主要定义在头文件中,下面是介绍. 函数声明 作用 返回值 char strcat(char dest, const char *src) 将src指向的字符串复制到dest指向的字符串的末尾 指向最终的目标字符串dest的指针 char strncat(char dest, const char *src, size_t n) 把src所指向的字符串追加到dest所指向的字符串的结尾,直到n字符长度为止 指向最终的目标字符串dest的指针 int strcmp(const char str1, const char str2) 把str1所指向的字符串和str2所指向的字符串进行比较(按照每一位的ascii比较) 标志大小的int值,大于(正),小于(负),等于(0) int strncmp(const char str1, const char str2, size_t n) 把str1和str2进行比较,最多比较前n个字节 同上 char strcpy(char dest, const char *src) 把src所指向的字符串复制到dest 指向最终的目标字符串dest的指针 char strncpy(char dest, const char *src, size_t n) 把src所指向的字符串复制到dest,最多复制n个字符,src长度小于n时,使用NULL填充 指向最终的目标字符串dest的指针 size_t strlen(const char *str) 计算字符串str的长度,直到空结束字符,但不包括空结束字符 长度 char strchr(const char str, int c) 在参数str所指向的字符串中搜索第一次出现字符c(一个无符号字符)的位置 指向第一次出现位置的指针,未找到则返回NULL char strrchr(const char str, int c) 在参数str所指向的字符串中搜索最后一次出现字符c(一个无符号字符)的位置 指向最后出现位置的指针,未找到则返回NULL 字符串类别测试与转化函数 头文件中定义了一些用于字符测试和转换的函数.下面是介绍. 函数签名 含义 返回值 int isalpha(int c) 判断c是否是字符 若c是字符,返回一个非零值,否则返回0 int isupper(int c) 判断c是否是大写字符 若c是大写字符,返回一个非零值,否则返回0 int islower(int c) 判断c是否是小写字符 若c是小写字符,返回一个非零值,否则返回0 int isdigit(int c) 判断c是否是数字字符 若c是数字字符,返回一个非零值,否则返回0 int isalnum(int c) 判断c是否是字母/数字 若c是字母/数字,返回一个非零值,否则返回0 int isspace(int c) 判断c是否是空白字符(空格、横向制表符、换行符、回车符，换页符或纵向制表符) int toupper(int c) 将c转化成大写字母 如果c有相对应的大写字母,则该函数返回c的大写字母.否则返回c本身 int tolower(int c) 将c转化成小写字母 如果c有相对应的小写字母,则该函数返回c的小写字母.否则返回c本身 命令执行函数 函数system(char* s)执行包含在字符申s中的命令,然后继续执行当前程序. system函数返回一个整型的状态值,其值来自于执行的命令,并同具体系统有关. 存储管理函数 函数malloc和calloc用于动态地分配存储块.介绍如下. 1234567891011// malloc的函数签名// 当分配成功时,它返回一个指针,设指针指向n字节长度的未初始化的存储空间,否则返回NULL.void *malloc(size_t NumBytes);// calloc的函数签名// 当分配成功时,它返回一个指针,该指针指向的空闲空间足以容纳由n个指定长度的对象组成的数组,否则返回NULL.该存储空间被初始化为0.// numElements: 对象个数, sizeOfElement: 每个对象的大小void *calloc(size_t numElements,size_t sizeOfElement);// 释放p指向的存储空间.其中,p是此前通过调用malloc或calloc函数得到的指针void free(void *FirstByte); 数学函数 头文件中声明了20多个数学函数,感觉用到的时候查就可以了… 随机数 函数rand()生成介于0和RAND_MAX之间的伪随机整数序列(RAND_MAX是在头文件中定义的符号常量). 函数srand(unsigned)设置rand函数生成的序列的种子. 12// 生成0-1之间的随机数的宏定义#define frand() ((double) rand() / (RAND_MAX+1.0))]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(4)]]></title>
    <url>%2F2018%2F03%2F29-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(4).html</url>
    <content type="text"><![CDATA[前言 以下记录了第六章的一些知识点. 结构语义 结构是一个或多个变量的集合,这些变量可能为不同的类型.也就是说:为了处理的方便而将这些变量组织在一个名字之下,这个名字被称作结构. 语法 关键字 struct 引入结构声明.结构声明由包含在花括号内的一系列声明组成. struct后面的名字是可选的,称为结构标记.结构标记用于为结构命名,在定义之后,结构标记就代表花括号内的声明,可以用它作为该声明的简写形式. 结构中定义的变量称为成员. 结构成员、结构标记和普通变量(即非成员)可以采用相同的名字,它们之间不会冲突. 123456// 结构的声明struct point &#123; // struct是关键字.point被称作结构标记 int x; // x,y,point 被称为成员 int y; int point; // 通过分析上下文,可以很明显的分辨出两个point代表的含义&#125;; struct声明定义了一种数据类型.在标志结构成员表结束的右花括号之后可以跟一个变量表,这与其它基本类型的变量声明方式是相同的. 如果结构声明的后面不带变量表,则不需要为它分配存储空间,它仅仅描述了一个结构的模板或轮廓. 如果结构声明中带有标记,那么在以后定义结构实例时也可以使用该标记定义. 12345// 结构实例的声明struct &#123; int x; &#125; x, y, z; // 直接跟变量表声明结构实例struct point pt; // 通过标记定义声明结构实例 结构的初始化可以在定义的后面使用初值表进行.使用这种方式初始化时,初值表中同每个成员对应的初值必须是常量表达式. 自动结构也可以通过赋值初始化,还可以通过调用返回相应类型结构的函数进行初始化. 123456789101112131415161718192021// 结构实例的初始化#include &lt;stdio.h&gt;struct point&#123; int x; int y; int point;&#125;;struct point get_point(void)&#123; struct point pt = &#123;4, 5, 6&#125;; return pt;&#125;;int main(void)&#123; struct point p1 = &#123;1, 2, 3&#125;; // 使用初值表初始化 struct point p2 = p1; // 赋值初始化 struct point p3 = get_point(); // 通过函数返回值初始化 struct point p4; // 自动初始化.此时: p4.x == p4.y == p4.point == 0&#125; 在表达式中，可以通过 结构名.成员 这样的形式来引用某个特定结构中的成员. 123456789101112131415#include &lt;stdio.h&gt;struct point&#123; int x; int y; int point;&#125;;int main(void)&#123; struct point p = &#123;1, 2, 3&#125;; printf("%d %d %d ", p.x, p.y, p.point); // 访问成员 p.x = 100; printf("%d %d %d", p.x, p.y, p.point); // 也可以为成员赋值&#125;// 很明显,输出是: 1 2 3 100 2 3 结构可以嵌套,即:结构中可以包含结构(不能嵌套自身的结构体). 1234567891011121314# include&lt;stdio.h&gt;struct inner&#123; int x;&#125;;struct outer&#123; struct inner y; // 结构体的嵌套 int x;&#125;;int main(void)&#123; struct outer o = &#123;&#123;1&#125;, 2&#125;; // 嵌套型结构体的初始化 printf("%d %d", o.y.x, o.x); // 很明显,输出为 1 2&#125; 运算 结构仅支持如下操作: 1.作为一个整体复制和赋值(包括向函数传递参数以及从函数返回值); 2.通过&amp;运算符取地址; 3.通过”.”操作符访问成员. 结构之间不允许比较. 指向结构的指针定义123456789101112struct point&#123; // 声明一个结构 int x; int y;&#125;struct point *p; // 声明一个指向point结构类型的指针struct point tmp = &#123;1, 2&#125;; // 定义一个point结构类型的变量p = &amp;tmp; // 通过取地址符&amp;使p指向tmp变量int y = (*p).x + 1; // 通过指针操作结构成员的写法(注意: 结构成员运算符“.”的优先级比“*”的优先级高,因此括号必须存在) // 此时y的值为2y = p-&gt;x + 1; // 通过指针操作结构成员的简写方法. // 此时y的值为3 扩展 由于”.”(用于结构体),”-&gt;”(用于结构体),”[]”(用于下标),”()”(用于函数调用)的操作符优先级是最高的,因此在不熟悉时可能对语句的结果判断失误,因此,最好使用括号来显式定义操作顺序. 12345678910111213141516171819// 优先级的示例#include &lt;stdio.h&gt;int main(void)&#123; struct point&#123; int *s; &#125;; int z = 0; struct point tmp = &#123;&amp;z&#125;; struct point *p = &amp;tmp; int r = *p++-&gt;s; // 这个语句的含义是: 先读取p指向的结构体中的str指针所指向的值对象(即z)的值,然后再将p加1 printf("%d\n", r); // 此时的r的值为0&#125; 结构体中可以嵌套指针(包括指向自身类型的指针). 12345678// 结构体中嵌套自身类型的指针示例struct office&#123; int chair; int computer; struct office *o; // 结构体中嵌套指向本类型的指针&#125;;struct office o1 = &#123;10, 10, NULL&#125;; // 使用空指针进行初始化struct office o2 = &#123;10, 10, &amp;o1&#125;; // 使用正常的指向某个结构实例的指针进行初始化 结构数组声明1234567891011121314// 变量数组的声明与初始化(以下两种声明方式是等价的)// 先声明结构体,再声明结构体数组struct point &#123; int x; int y;&#125;;struct point p_array[2];// 声明结构体的同时声明数组struct point &#123; int x; int y;&#125; p_array[2]; 初始化1234567891011121314// 结构体数组的初始化// 精确的做法,将每一行(即每个结构)的初值都括在花括号内进行初始化struct point p_array[2] = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;&#125;;// 简单做法,在定义的后面通过一个用圆括号括起来的初值表进行初始化// 即: 如果初值是简单变量或字符串,并且其中的任何值都不为空,则内层的花括号可以省略struct point p_array[2] = &#123; 1, 2, 3, 4&#125;;// 同普通数组一样,如果初值存在并且方括号[ ]中没有数值,编译程序将自动计算数组 p_array 中的项数. 扩展 C语言提供了一个编译时(compile-time)一元运算符sizeof,可用来计算任一对象的长度. 表达式 sizeof 对象 以及 sizeof(类型名) 将返回一个整型值(严格地说,返回值是无符号整型值,其类型为 size_t),它等于指定对象或类型占用的存储空间字节数. 12345678910111213141516171819202122232425262728293031323334// sizeof的用法#include&lt;stdio.h&gt;int test(void)&#123; printf("%s", "exec"); // 这里并不会被执行 return 1;&#125;;struct point&#123; int x; int y;&#125;;struct special&#123; int x; char y;&#125;;int main()&#123; struct point p = &#123;1, 2&#125;; struct special sp = &#123;1, 'x'&#125;; struct point *p_p = &amp;p; int tmp_array[] = &#123;1, 2, 3&#125;; printf("%ld", sizeof tmp_array); // 当sizeof的对象是数组时,返回数组总大小. printf("%ld", sizeof p_p); // 当对象是指针时,返回指针本身的大小,而不是指示内存空间的大小. printf("%ld", sizeof p); // 一般而言,结构体的大小为所有元素的大小之和. printf("%ld", sizeof(sp)); // 然而,由于需要对齐,因此实际长度可能会有变化. printf("%ld", sizeof(1+1)); // 对象是表达式时,求的大小是表达式返回值的类型大小,但并不计算表达式的值. printf("%ld", sizeof(test())); // 如果对象是函数,则返回函数返回值类型大小,不实际执行,因此函数中的输出并不会出现. printf("%ld", sizeof(int)); // 作用于类型时,返回该类型所占空间大小. printf("%ld", sizeof("123")); // 由于字符串结尾总有一个'\0',因此计算空间时会比实际长度大一. return 0; // 结果为: 12 8 8 8 4 4 4 4&#125; 不同的对象有不同的对齐要求,所以,结构中可能会出现未命名的“空穴“(hole). 通过使用sizeof可以很容易的算出数组中元素的个数. 条件编译语句 #if 中不能使用sizeof,因为预处理器不对类型名进行分析.但预处理器并不计算 #define 语句中的表达式,因此,在#define中使用sizeof是合法的. 12345678910111213// 利用sizeof求数组元素个数的方法int tmp[] = &#123;1, 2, 3&#125;;// 1. 数组的长度除以单个元素的长度int length = sizeof(tmp) / sizeof(int);// 2. 数组的长度除以指定元素的长度int length = sizeof(tmp) / sizeof(sizeof(tmp[0]));// 一个利用sizeof求数组长度的宏定义#define ARR_LEN(x) (sizeof(x) / sizeof(x[0])) C语言提供了一个称为 typedef 的功能,它用来建立新的数据类型名. 从任何意义上讲,typedef 声明并没有创建一个新类型,它只是为 某个已存在的类型增加了一个新的名称而已.typedef声明也没有增加任何新的语义,即通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性. 优点:1.可以使程序参数化,以提高程序的可移植性(如果typedef声明的数据类型同机器有关,那么当程序移植到其它机器上时,只需改变typedef类型定义就可以了);2.通过使用更恰当的名称为程序提供更好的说明性. 123456typedef int Length; // 给int一个别名LengthLength x = 0; // 相当于 int x = 0;typedef struct tnode &#123; char *word; struct tnode *right;&#125; Treenode; // 复杂声明 联合概念 联合(union)是可以(在不同时刻)保存不同类型和长度的对象的变量,由编译器负责跟踪对象的长度和对齐要求. 联合提供了一种方式,以在单块存储区中管理不同类型的数据,而不需要在程序中嵌入任何同机器有关的信息(通过使用联合,一个变量可以合法地保存多种数据类型中任何一种类型的对象). 定义方式1234567// 使用联合的场景示例: 假设一个常量可能是int,f1oat或字符指针.// 若该常量的不同类型占据相同大小的存储空间,且保存在同一个地方的话,使用将最方便.通过将该常量定义为联合可以实现.union u_demo &#123; int ival; float fval; char *sval;&#125; u; // 变量u必须足够大,以保存这3种类型中最大的一种,具体长度同具体的实现有关. 使用 同结构类似,可以使用 联合名.成员 或 联合指针-&gt;成员 的方法来访问联合中的成员. 读取的类型必须是最近一次存入的类型.由程序员负责跟踪当前保存在联合中的类型,如果保存的类型与读取的类型不一致,其结果取决于具体的实现. 联合只能用其第一个成员类型的值进行初始化. 实际上,联合就是一个结构,它的所有成员相对于基地址的偏移量都为0.对联合允许的操作与对结构允许的操作相同:作为一个整体单元进行赋值、复制、取地址及访问其中一个成员. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;// 定义宏来标识当前union变量的类型#define INT 1#define CAHR 2// 定义union类型union u_d&#123; char y; int x;&#125;;// 通过校验当前union变量的类型来进行针对性处理(这里是输出)// 以下两个带注释行的用法是不规范的,很可能得不到预期的结果void print_u_demo(union u_d u, int u_type)&#123; if (u_type == INT)&#123; printf("%d\n", u.x); printf("%c\n", u.y); // 这里会输出 u.x 对应的 ASCII 字符 &#125; else if (u_type == CAHR)&#123; printf("%d\n", u.x); // 这里不能得到有意义的输出 printf("%c\n", u.y); &#125; else&#123; printf("bad type %d in utype\n", u_type); &#125;&#125;int main()&#123; int u_type = 0; // 用变量来记录结构成员当前的类型 union u_d u = &#123;'A'&#125;; // 使用第一个成员类型来初始化 u_type = CAHR; print_u_demo(u, u_type); u.x = 100; u_type = INT; print_u_demo(u, u_type); return 0;&#125; 内存模型 union变量占用的内存等于最长的成员占用的内存.本质上只是对一段大内存的不同解读方式.如下图所示: 位字段背景 在存储空间很宝贵的情况下,有可能需要将多个对象保存在一个机器字中(机器字指计算机一次能处理数据的bit位数). 一种常用的方法:使用类似于编译器符号表的单个二进制位标志集合. 1234567891011121314151617181920212223// 使用一个char或int对象中的位标志集合来标识一个对象的属性的示例// 这里使用int型变量来标识某标识符的特定信息的集合.int flags;// 定义一个与相关位的位置对应的"屏蔽码"的集合,其中的每一个元素代表一种属性// 这些数字必须是2的幂.这样,访问这些位就变成了用移位运算、屏蔽运算及补码运算进行简单的位操作// 使用宏定义#define KEYWORD 01#define EXTRENAL 02#define STATIC 04// 使用枚举定义enum &#123; KEYWORD = 01, EXTERNAL = 02, STATIC = 04 &#125;;// 为该标识符的属性设值flags |= EXTERNAL | STATIC;// 判断该标识符是否有特定属性if ((flags &amp; (EXTERNAL | STATIC)) == 0)&#123; doSomething();&#125; C语言语法层面的支持 这种做法的本质是利用一位来存储一种信息,但是每种信息只能有简单的 是/否 概念.这样就在很大限度上减少了内存使用,并且判断效率也很高.至于使用什么方法来实现这种思路就无关紧要了. 也许是C语言中类似的做法很多.因此,它在语法层面为这种操作提供了支持.即:位字段(位域). 位字段允许我们定义一个由位组成的段,并可为它赋以一个名字.通过这种方式可以更高效的利用内存. 123456789101112131415161718192021222324252627282930313233343536// 位字段的声明// 位字段只能定义为 int, signed int, unsigned int中的一种struct &#123;unsigned int is_keyword : 1; // 冒号“:”后的数字为该位字段所占的bit位数unsigned int : 1; // 可以使用无名字段来占位,仅起填充作用,该字段所在的位不能被使用unsigned int : 0; // 0字段,不实际占用位,仅起标记作用(下一个位字段在下一个字边界开始).unsigned int is_static : 1;&#125; flags;// 位字段的访问// 位字段没有独立的地址,不能进行取址操作// 位字段没有独立的存储空间,不能进行sizeof()操作flags.is_keyword// 内存分配// 规则: 1.位字段按声明顺序在机器字内存储; // 2.位字段不能跨越机器字存储,上一个机器字空间不足时,该位字段将全部存到下一个机器字// 假设当前机器是32位struct &#123; unsigned int a :20; unsigned int b : 6; unsigned int c : 2;&#125;demo; // 20+6+2 &lt; 32, 故可在1个机器字内存储struct &#123; unsigned int d :20; unsigned int e :6; // 32 -（20+6）= 6, 该机器字剩余6bit unsigned int f :20; // 6bit不够存储f,则f将在下一个机器字边界开始存储&#125;flagscopy; //整体来看, 20+6+20&gt;32 故需在2个机器字内存储struct &#123; unsigned int g : 1; unsigned int : 0; unsigned int h : 1; // 由于前面是一个0字段标记,因此h将在下一个机器字边界开始存储&#125;]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(3)]]></title>
    <url>%2F2018%2F03%2F21-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html</url>
    <content type="text"><![CDATA[前言 以下记录了第五章的一些知识点. 指针概念语义 一般来说,内存可以看作是一系列连续编号或编址的存储单元,我们将不可再分的最小单位定义为位(bit,一个位大小的内存中只能存储0/1两种状态之一).我们可以将一些信息转化为二进制(0/1的序列)进行存储,这就是编码. 在第一个较通用的编码表ASCII编码诞生后,我们将其中能存储一个英文字符的空间称为一字节(Byte),其中,1Byte=8bit. 而一般把存储器中的一个字节(Byte)称为一个内存单元.如果我们将这些存储单元看作有序的(例如,按照物理顺序排序),那么就可以用某个值表示每一个内存单元的地址,又由于字节大小是固定的,因此我们可以通过记录某字节在这个字节序列中的位置来计算位置,也就是说,这个位置信息可以等价为内存单元的地址. 我们将某个内存单元A的地址(也就是位置信息)也存储到内存单元B(也可能是一组内存单元)之后,就可以通过取出B单元的信息来计算出A的地址,从而间接的取出A的信息.其中,B中的值被称为A的地址,B被称为指针. 也就是:指针是能够存放一个地址的一组存储单元. 语法 1.ANSI C使用类型void (指向 void的指针)代替在原来使用char 作为通用指针的类型. 也就是说:任何类型的指针都可以转换为 oid 类型，并且在将它转换回原来的类型时不会丢失信息; 2.在C语言中,通过一元运算符&amp;来取某变量的地址.又由以上推导可得:地址运算符&amp;只能应用于内存中的对象,即变量与数组元素.它不能作用于表达式,常量或register类型的变量; 3.一元运算符是间接寻址或间接引用运算符.当它作用于指针时,将访问指针所指向的对象; 4.为了安全,指针只能指向某种特定类型的对象.也就是说,每个指针都必须指向某种特定的数据类型; 5.由于指针也是变量,所以在程序中可以直接使用,而不必通过间接引用的方法使用; 6.对指针有意义的初始化值只能是空(NULL/0)或者是表示地址的表达式(表达式所代表的地址必须是在此前已定义的具有适当类型的数据的地址). 12345678910111213int x = 1;int *y = &amp;x, *z; // 定义一个指向变量x的内存地址的指针yvoid *p = &amp;x; // void* 类型的变量可以作为通用指针z = y; // 指针可以直接使用int *t = NULL; // 指针定义时,可以指向NULL/0.此时,它被称为 空指针.int *u = 0;// 指针数组初始化// name数组中的每个元素都是一个指针,它指向某一个字符串常量(该常量存在于内存中的某个位置).char *name[] = &#123; "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"&#125;; 应用场景指针与函数参数 将指针作为参数的优点: 1. 指针参数使得被调用函数能够访问和修改主调函数中对象的值; 2. 在函数需要返回多种不同含义的值时,可以利用指针参数进行接收. 123456789101112131415161718192021222324252627// 当is_valid函数返回1时,输出为:swap success,当is_valid函数返回0时,输出为swap fail.#include &lt;stdio.h&gt;int is_valid(int *x)&#123; // 这里虚构is_valid函数进行参数检查,它的返回值表示参数是否合法 return 1;&#125;int swap(int *x, int *y)&#123; //这里的swap函数实现了如下功能:1.修改交换传递的参数的值;2.通过返回值标识了交换是否成功 if (!(is_valid(x) &amp;&amp; is_valid(y)))&#123; return 0; &#125; int temp = *x;; *x = *y; *y = temp; return 1;&#125;int main(void)&#123; int x = 1, y = 2; if (swap(&amp;x, &amp;y))&#123; printf("%s", "swap success"); &#125; else&#123; printf("%s", "swap fail"); &#125; return 0;&#125; 指针与数组 通过查询维基百科可以得到:数组(Array)是由相同类型的元素(element)的集合所组成的资料结构,分配一块连续的内存来存储.很容易联想到:若数组A中存在多个元素,那么其中某个元素b的地址可以在首元素地址的基础上,通过位移(指针运算)来得到.而根据定义,数组类型的变量或表达式的值即是该数组第0个元素的地址.因此有: A[i]与*(A+i)是等价的,即通过数组和下标实现的表达式可等价地通过指针和偏移量实现.且若确信相应的元素存在,也可以通过下标访问数组第一个元素之前的元素(即i可以为负数). 指针是一个变量,而数组名并不是变量(它是常指针).因此可以为指向数组的指针重新赋值,而不可以更改数组名所指向的地址(即不能更改A的值). 一般来说,用指针编写的程序比用数组下标编写的程序执行速度快,但另一方面,用指针实现的程序理解起来稍微困难一些. 当把数组名传递给一个函数时,实际上传递的是该数组第一个元索的地址.由于在被调用函数中,该参数是一个局部变量,因此,数组名参数必须是一个指针,也就是一个存储地址值的变量. C语言规范保证,0永远不是有效的数据地址.因此,可以返回地址0来表示发生了异常事件. 123456int* test(int x)&#123; if (x &gt; 0)&#123; return &amp;x; // 正常情况 &#125; return 0; // 用0来表示异常情况&#125; 字符指针与函数 字符串常量是一个数组(字符数组),因此字符串常量可通过一个指向其第一个元素的指针访问. 将字符串常量作为参数时,实际是传递了字符指针,函数中是通过使用这个指针来访问字符串常量.C语言没有提供将整个字符串作为一个整体进行处理的运算符. 12345char amessage[] = "now is the time"; // 定义一个数组// amessage 是一个仅仅足以存放初始化字符串以及空字符'\0'的一维数组.其中作为数组名的amessage是一个常指针,它始终指向该内存区域.然而,数组中的单个字符可以进行修改.char *pmessage = "now is the time"; // 定义一个指针// 在字符串的内部表示中,字符数组以空字符'\0'结尾.// pmessage是一个指针,其初值指向一个字符串常量.它的值可以被修改(可以指向不同的位置).但这个字符串常量不能被改变(结果未定义). 123// 进栈和出栈的标准用法*p++=val; // 将val压入栈val=*--p; // 将栈顶元素弹出到val中 指针数组12345678910//指针数组的声明char *lineptr[10]; // lineptr是一个具有10个元素的一维数组, 其中数组的每个元素都是一个指向字符类型对象的指针.// 注意, lineptr是一个常指针// 指针数组的初始化char *name[] = &#123; "Illegal month", "January", "February", "March", "April", "May", "June", "July","August", "September", "October", "November", "December"&#125;// 说明: name数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应位置的元素. 第i个字符串的所有字符存储在存储器中的某个位置, 指向它的指针存储在name[i]中. 由于上述声明中没有指明name的长度, 因此, 编译器编译时将对初值个数进行统计, 并将结果填入数组的长度. 二维数组 在C语言中,二维数组实际上是一种特殊的一维数组,即:它的每个元素也是一个一维数组. 一般来说,除数组的第一维(下标)可以不指定大小外,其余各维都必须明确指定大小.初始化时,没有指定的元素会被默认初始化. 一般来说,二维数组在内存中也是按照一维数组的形式排列的.在C语言中,二维数组是按行排列的. 二维数组(多维数组)中每一个一维数组的长度是固定的,而指针数组的每一行长度(该指针指向的元素的大小/数组的长度)可以不同. 指针数组最频繁的用处是存放具有不同长度的字符串. 12345678910111213141516171819202122232425// 二维数组的声明与定义// 按行分段赋值int daytab[2][12] = &#123; &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;// 上述声明的第一维大小的定义可以省略,即int daytab[][12] = &#123; &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;// 按行连续赋值int daytab[2][12] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;// 同理int daytab[][12] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;// 访问二维(多维)数组中某元素// 实际是通过常规的矩阵下标计算公式 n×row+col(其中,n表示每一个一位数组的长度,row表示行下标,col表示列下标)计算得到元素 array[row][col]的位置int tmp = daytab[0][1]; // 此时,tmp的值为28 函数指针 在C语言中,函数本身不是变量.但我们可以定义指向函数的指针,这种指针被称作函数指针. 声明格式: 类型说明符 (*函数名)(参数), 示例如下: 123/* 函数指针的声明 */ int (* sort)(int, int);// 这里的sort更恰当的说应该叫做函数指针的变量名.这个特殊的指针指向一个接收两个int型变量,并返回整型值的函数 调用格式: (*func)(params…) / func(params…) 123456789101112131415161718192021222324252627/* 函数指针的赋值与调用示例 */#include &lt;stdio.h&gt;void test(); // 声明一个函数void test_test(void (* t)(void))&#123; // 参数声明为函数指针 printf("hahah "); t(); // 通过传入的函数指针对函数进行调用&#125;int main(void)&#123; void (*tmp)(); // 声明一个函数指针 tmp = test; // 初始化函数指针 tmp(); // 调用方法一 (*tmp)(); // 调用方法二 test_test(tmp); // 将函数指针作为参数传递&#125;void test()&#123; static int x = 1; // 声明静态变量 printf("%s%d ", "test", x); // 通过打印静态变量来直观表示打印次数 x += 1;&#125;// 输出: test1 test2 hahah test3&#125; 指针的运算 指针与整数之间不能相互转换.0是惟一的例外:常量0可以赋值给指针,指针也可以和常量0进行比较.程序中经常用符号常量NULL(定义在标准头文件中)代替常量0. 指针的运算: 1.如果指针p和q指向同一个数组的成员,那么它们之间就可以进行类似于==、!=、&lt;、&gt;=的关系比较运算。这里实际比较的是它们的位置关系(数组下标的大小); 2.任何指针与0进行相等或不等的比较运算都有意义,用来校验当前指针是否是空指针; 3.如果p和q指向相同数组中的元素,且 p&lt;q ,那么 q-p+1 就是位于 p和q 指向的元索之间的元素的数目; 4.指针可以和整数进行相加或相减运算.例如: p为指针,则 p+n 表示指针p当前指向的对象之后第n个对象的地址.具体计算时,n将根据p指向的对象的长度按比例缩放,而p指向的对象的长度则取决于p的声明. 5.相同类型指针之间的赋值运算是合法的,void* 类型的指针与其它指针的赋值运算是合法的; 6.指针的算术运算中指向不同数组元素之间的运算没有定义,但是可以使用数组最后一个元素的下一个元素的地址(这个地址可以赋给指向数组元素的指针,但仅允许它进行赋值或比较运算,不能对保存这个地址的指针进行解引用或下标运算). 123456789101112131415int tmp[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;;int *x = tmp + 1; // x指向2int *y = tmp + 4; // y指向5int *p = &amp;tmp[7]; // 数组tmp最后一个元素的下一个元素的地址int z = p - y; // 可以使用p进行运算,此时z的值为p与y下标的距离3z = x &lt; y; // z的值为1z = x == 0; // z的值为0z = x != 0; // z的值为1x = y + 1; // x现在指向y所指元素的后一个元素,即6y = z; //赋值操作void* p = y; // 赋值操作 特殊命令行参数 在支持C语言的环境中, 可以在程序开始执行时将命令行参数传递给程序. C语言中的参数约定如下: main函数的第一个参数argc的值表示运行程序时命令行中参数的数目; 第二个参数argv是一个指向字符串数组的指针，数组中的每个字符串对应一个参数.另外，ANSI标准要求argv[argc]的值必须为一个空指针. 图示如下: 扩展:UNIX系统中的C语言程序有一个公共的约定:以负号开头的参数表示一个可选标志或参数.例如: ls -l 这样的shell命令.实现: 通过校验argv所指向的数组中的某个字符串是否以’-‘开头,再在这个基础上通过switch来得到其后跟随的字符,并进行特殊处理.]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(2)]]></title>
    <url>%2F2018%2F02%2F04-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html</url>
    <content type="text"><![CDATA[前言 以下记录了第三章及第四章的一些知识点. 语句 在表达式之后加上一个分号(;),它们就变成了语句; 12// 语句int x; 用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句(也叫作程序块), 复合语句在语法上等价于单条语句; 12345// 复合语句&#123; int x = 1; x += 1;&#125; 建议在有语句嵌套的情况下使用花括号来显式定义匹配关系; switch语句中, default分支是可选的,如果没有 default 分支也没有其它分支与表达式的值匹配,则该switch语句不执行任何动作。在switch 语句中,case的作用只是一个标号,而break/return语句才会使程序的执行立即从switch语句中退出; 1234567891011121314151617// switch语句// 注: 中括号，表示此语句可以没有switch (表达式) &#123; case 常量表达式1: 语句1; // 可以是多条语句，可以加括号，也可以不加，到下一个case之前，都是本case的语句范围 [break;] case 常量表达式2: 语句2; [break;] .... case 常量表达式n: 语句n; [break;] [default：] 语句n+1; [break;]&#125; break语句可用于从for、while与do-while等循环中提前退出,continue语句用于使for、while或do-while语句开始下一次循环的执行; goto语句可以与标号配合进行程序的任意跳转功能。标号的命名同变量命名的形式相同,标号的后面要紧跟一个冒号。标号可以位于对应的goto语句所在函数的任何语句的前面。标号的作用域是整个函数; 12345678910111213141516// goto语句示例int main(void)&#123; int i, j; for (i = 0; i &lt; 10; i++)&#123; printf( "Outer loop executing. i = %d\n", i ); for (j = 0; j &lt; 3; j++)&#123; printf( " Inner loop executing. j = %d\n", j ); if ( i == 5 ) goto stop; // 进行跳转 &#125; &#125; /* This message does not print: */ printf( "Loop exited. i = %d\n", i ); stop: printf( "Jumped to stop. i = %d\n", i ); // 定义标号 return 1;&#125; 函数 在函数中可以通过return语句返回一个值,如果没有显式声明返回值类型,则返回值类型为int.此外,在任何情况下,如果函数没有成功地返回一个值,则它的“值”肯定是无用的; 123456// 函数返回值样例int func_demo(void)&#123; int x = 1; return x; printf("%s", "这条语句不会被执行.");&#125; 123456789// 未定义返回值的情况下,函数的值xx()&#123;&#125;int main(void)&#123; int x = xx(); printf("%d", x); // 结果是0 return 0;&#125; 函数的声明与定义必须一致.如果某函数与调用它的主函数放在同一源文件中,并且类型不一致,编译器就会检测到该错误。但是,如果被调用函数是单独编译的(这种可能性更大),这种不匹配的错误就无法检测出来，出现错误的几率会很大; 如果没有函数原型,则函数将在第一次出现的表达式中被隐式声明.如果先前没有声明过的一个名字出现在某个表达式中,并且其后紧跟一个左圆括号,那么上下文就会认为该名字是一个函数名字,该函数的返回值将被假定为int类型,且上下文并不对其参数作任何假设,即很可能会取到错误的返回值; 1234567891011121314151617// 类型检查错误且函数解析错误的样例// demo.c#include &lt;stdio.h&gt;char* xx(void)&#123; return "lalala";&#125;// demo2.c#include &lt;stdio.h&gt;int main(void)&#123; int x = xx(1); printf("%d %s", x, "啦啦啦"); return 0&#125; 1234# 以如下命令进行编译,会产生warning(而不是error)gcc demo.c demo2.c -o la# 以如下命令对二进制文件进行执行,控制台的输出为 4195868 啦啦啦./la 变量 C语言程序可以看成由一系列的外部对象构成, 这些外部对象可能是变量或函数.由于函数内不允许定义函数,因此函数天生是外部对象.那么外部变量就可以认为是定义在所有函数之外的变量,同函数一样,全局共享一个实例.与此相对应,内部变量(自动变量)即为定义在函数内部的变量; 12345678# include &lt;stdio.h&gt;int x = 1; // 外部(全局)变量int main(void)&#123; int y = 1; // 内部(自动)变量 printf("%d", x + y); return 0;&#125; 构成C语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中,原先已编译过的函数可以从库中进行加载; 外部变量或函数的作用域从声明它的地方开始,到其所在的(待编译的)文件的末尾结束.如果要在外部变量的定义之前使用该变量,或者外部变量的定义与变量的使用不在同一个源文件中,则必须在相应的变量声明中强制性地使用关键字 extern; 1234567891011/*外部变量定义与使用分离 及 内部变量默认初始化 的栗子*/// demo.c#include &lt;stdio.h&gt;int main(void)&#123; extern int x; printf("%d", x);&#125;// demo2.cint x = 100; 1234# 以如下命令进行编译,会产生warning(而不是error)gcc demo.c demo2.c -o la# 以如下命令对二进制文件进行执行,若有x有extern定义则控制台的输出为100,若没有则控制台输出为0./la 变量声明用于说明变量的属性(主要是变量的类型),而变量定义除此以外还将引起存储器的分配.在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,而其它文件可以通过extern声明来访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明).外部变量的定义中必须指定数组的长度,但 extern 声明则不一定要指定数组的长度.外部变量的初始化只能出现在其定义中; 当源文件个数很多时,变量/函数的定义位置并不是那么容易找到,很容易造成混乱.为了解决这个问题,可以将定义与实现分离,即使用头文件进行定义的集中管理,而将实现分散在各个文件中.通过这种机制,可以减少变化时错误的产生几率; 123456789101112131415/*上面的栗子,通过使用头文件来将共享的部分集中在一起之后变为如下形式,可以去除变量x的声明很自然的...如果某个包含文件的内容发生了变化,那么所有依赖于该包含文件的源文件都必须重新编译*/// 在文件test.h中int x = 100;//在文件 demo1.py 中#include &lt;stdio.h&gt;# include "test.h"int main(void)&#123; printf("%d", x);&#125; 被static限定符声明的外部变量与函数的作用域被限定为被编译源文件的剩余部分,通过此修饰符可以实现隐藏外部对象的目的.而被static限定的内部变量则只能在该函数中使用但一直占据存储空间,且只在第一次进入程序块时被初始化一次; 123456789101112131415161718// static变量的栗子, 五次输出值均为14#include &lt;stdio.h&gt;#include "test.h"int test(int x)&#123; static int y = 10; int tmp = x + y; y += 1; return tmp;&#125;int main(void)&#123; int times = 5; while(times-- &gt; 0)&#123; printf("%d", test(times)); &#125; return 0;&#125; register声明告诉编译器,它所声明的变量在程序中使用频率较高,因此建议将此变量放入寄存器中以使程序更小、执行速度更快(编译器可以忽略此建议).register声明只适用于自动变量以及函数的形式参数.同时,无论寄存器变量实际上是不是存放在寄存器中,它的地址都是不能访问的; 变量初始化 1.在不进行显式初始化的情况下,外部变量和静态变量都将被初始化为 0,而自动变量和寄存器变量的初值则没有定义(即初值为无用的信息); 2.定义标量变量时,可以在变量名后紧跟一个等号和一个表达式来初始化变量; 3.对于外部变量与静态变量来说,初始化表达式必须是常量表达式,且只初始化一次(从概念上讲是在程序开始执行前进行初始化); 4.对于自动变量与寄存器变量,初始化表达式可以不是常量表达式:可以包含任意在此表达式之前已经定义的值,包括函数调用.且在每次进入函数或程序块时都会初始化; 5.对于数组. (a)初始化表达式列表用花括号括起来,各初始化表达式之间通过逗号分隔. (b)若初始化表达式元素个数比数组元素数少,则对外部变量、静态变量和自动变量来说,没有初始化表达式的元素将被初始化为0,如果初始化表达式的个数比数组元素数多,则会产生编译错误. (c)不能一次将一个初始化表达式指定给多个数组元素,也不能跳过前面的数组元素而直接初始化后面的数组元素; (d)对于字符数组.可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列. 预处理器总览 从概念上讲,预处理器是编译过程中单独执行的第一个步骤,大概有以下几种: 名称 符号 含义 文件包含预处理器 #include 将本行内容替换为path所指的文件的内容 宏替换预处理器 #define 将本文件中的 name(名字记号) 替换为 text(替换文本) 预处理器运算符 ## (配合#define使用) 一种连接实际参数的手段 条件包含 #if,#elif,#else,#endif,#ifdef,#ifndef 一种控制编译结果的手段 文件包含预处理器12345// 在系统目录查找#include &lt;stdio.h&gt;// 先在用户目录查找#include "test.h" (a)在源文件中,任何形如:#include “文件名”或#include &lt;文件名&gt; 的行都将被替换为由文件名指定的文件的内容.(b)如果文件名用引号引起来,则在源文件所在位置查找该文件.如果在该位置没有找到文件,或者如果文件名是用尖括号&lt;&gt;括起来的,则将根据相应的规则(可能是环境变量)查找该文件. 宏替换预处理器1234567891011// 常规版本#define XX 100// 带参数的版本(格式匹配)#define max(A, B) ((A) &gt; (B) ? (A) : (B))//使用#的版本#define dprint(expr) printf(#expr " = %g\n", expr)// 使用##的版本#define paste(front, back) front ## back (1)格式为#define 名字 替换文本 后续所有出现名字记号的地方都将被替换为替换文本;(2)#define 指令定义的名字的作用域从其定义点开始,到被编译的源文件的末尾处结束;(3)宏定义也可以带参数,这样可以对不同的宏调用使用不同的替换文本,最好使用括号指定层次关系;(4)可以通过#undef 指令在本文件中释放被宏定义的名字;(5)如果在替换文本中,参数名以#作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串.即第三个示例的作用为: 将 dprint(x/y) 函数变为 printf(“x/y” “ = &amp;g\n”, x/y); 语句 亦即 printf(“x/y = &amp;g\n”, x/y);(6)##为宏扩展提供了一种连接实际参数的手段.如果替换文本中的参数与##相邻,则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新扫描.即##用来将两个宏参数连接为一个宏参数.以上第四个例子的作用: 将 paste(name, 1) 转化为 name1 (宏调用 paste(name, 1)的结果将建立记号 name1)(7)一个长的#define语句可用反斜杠分成几行. 条件包含系列123456789101112131415161718192021#define X 1// 根据条件选择编译内容#if !defined(X) code#elif (X == 0) code1#elif X == 1 code2#else code3#endif// 简写#ifdef X code4#endif#ifndef X code5#endif (1)通过这种机制可以修改要被编译的代码.(2)#if 语句对其中的常量整型表达式(其中不能包含 sizeof、类型转换运算符或 enum 常量)进行求值,若该表达式的值不等于 0,则包含其后的各行,直到遇到#endif、#elif或#else语句为止.(3)在条件包含预处理器中可以使用表达式 defined(名字),该表达式的值遵循规则如下:当名字已经定义时,其值为 1;否则,其值为 0.(4)#ifdef与#ifndef是一种简写,用来测试某个名字是否已经定义并执行相应语句. #ifdef的使用和#if defined()的用法一致 #ifndef又和#if !defined()的用法一致(5)最后要使用#endif标识判断结束.]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(1)]]></title>
    <url>%2F2018%2F01%2F24-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[前言 前段时间在看一本书叫做《Python源码剖析》,但是发现在很多分析具体实现的地方看不懂.尤其是struct和指针部分,因此决定重温一下C语言的语法. C语言是我接触的第一门编程语言,刚开始学习时,什么都不懂,学校的课本也是写的乱七八糟,因此在网上搜了一下,找到了《C Primer Plus》这本书,然而当时学习是为了应付考试,因此只是学习到文件读写部分就没有继续了,现在想想甚为可惜… 由于有了一定的基础,因此本次复习选择的书是比较简洁的《The C Programing Language(中文版)》,在学习的过程中,会将一些个人认为比较重要的知识点记录下来供以后参考. 以下记录了第1-2章的一些知识点。 拾遗 main是一个特殊的函数名——每个程序都以main函数为起点开始执行,这意味着每个程序都必须在某个位置包含一个main函数; 在允许使用某种类型变量值的任何场合,都可以使用该类型的更复杂的表达式; 赋值操作是一个表达式,并且具有一个值,即赋值后左边变量保存的值; 即: (x = 1) == 1 在关系表达式或逻辑表达式中,如果关系为真,则表达式的结果值为数值 1; 如果为假,则结果值为数值 0; 函数原型中的参数名是可选的,只需标明类型即可; 即: 形如 int test(int, int); 的函数声明是合法的 在 C 语言中,所有函数参数都是“通过值”传递的.在被调用的函数中,参数可以看作是快速初始化的局部变量; 函数中的每个局部变量只在函数被调用时存在,在函数执行完毕退出时消失; 外部变量声明方式: (1) 定义在所有函数之外; (2) 通过extern关键字定义. 注: a.外部变量只能定义一次; b.在源文件中,如果外部变量的定义出现在使用它的函数之前, 那么在那个函数中就没有必要使用extern声明(接上面的a,即a的本质),因此在通常的做法中,所有外部变量的定义都放在源文件的开始处,这样就可以省略extern声明; “定义”表示创建变量或分配存储单元,而“声明”指的是说明变量的性质,但并不分配存储单元。 摘抄 声明语句说明变量的名字及类型,同时也可以指定变量的初值。 运算符指定将要进行的操作。 表达式把变量与常量组合起来生成新的值。 对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。 变量命名规范: 变量名是由字母和数字组成的序列,但其第一个字符必须为字母.其中下划线“_”被看做是字母.一般变量用小写字母,常量用大写字母. 基本数据类型及限定符基本数据类型: 关键字 解释 char 字符型,占用一个字节,可以存放本地字符集中的一个字符 int 整型,通常反映了所用机器中整数的最自然长度 float 单精度浮点型 double 双精度浮点型 限定符: 关键字 解释 short 用于限定整型 eg: short int x —&gt; short x long 用于限定整型 eg: long int x —&gt; long x signed/unsigned 用于限定整型,代表是否可以有负值 关于类型所占用位数的规定: short 与 int 类型至少为 16 位; long 类型至少为 32 位; short类型不得长于 int 类型,而 int 类型不得长于 long 类型; long double 类型表示高精度的浮点数. 常量 字符常量 一个字符常量是一个整数,书写时将一个字符括在单引号中即可.如’x’字符在机器字符集中的数值就是该字符常量的值; 字符串常 从技术角度看,字符串常量就是字符数组.其中字符串的内部表示使用一个空字符’\0’作为串的结尾.因此存储字符串的物理存储单元数比括在双引号中的字符数多一个； 枚举常量 枚举是一个常量整型值的列表.在没有显式定义的情况下,enum 类型中第一个枚举名的值为 0,第二个为 1…, 如果指定了其中部分枚举名的值,那么未指定值的枚举名的值将依着最后一个指定值向后递增. 规定: 不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值. 意义: 枚举为建立常量值与名字之间的关联提供了一种便利的方式. 常量定义 常量可以通过const修饰符 或者 宏定义来实现. 变量声明 声明表达式 在声明中,如果变量名的后面紧跟一个等号以及一个表达式,该表达式就充当对变量进行初始化的初始化表达式 例如: int x; int x = 1; 变量的默认初始化 如果变量不是自动变量,则只能进行一次初始化操作,从概念上讲,应该是在程序开始执行之前进行,并且初始化表达式必须为常量表达式。 每次进入函数或程序块时,显式初始化的自动变量都将被初始化一次,其初始化表达式可以是任何表达式。默认情况下,外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义值(即无效值) const限定符 任何变量的声明都可以使用 const限定符限定。此限定符指定变量的值不能被修改,对数组而言,const限定符指定数组所有元素的值都不能被修改. const 限定符也可配合(数组)参数使用,它表明函数不能修改(数组元素)参数的值 例如: int strlen(const char[]) 与 int test(const int a) 运算符与表达式 简单分类 示例 注意 二元运算符 +, -, *, /, %, &amp;, /执行的是整除(即地板除法,只留整数) 关系运算符 &gt;, &gt;=, &lt;, &lt;= 运算结果是 0/1 相等性运算符 ==, != 运算结果是 0/1 逻辑运算符 &amp;&amp;, &#124;&#124; 短路机制 一元运算符 !, ++, – ++,–位置影响 强制类型转换运算符 () 位操作运算符 &amp;, &#124;, ^, &lt;&lt;, &gt;&gt;, ~ 可以简单认为作用于二进制 三元运算符 : ? 示例: z = (a&gt;b) ? a: b 等价于 if (a &gt; b){ z = a;} else {z = b;} 赋值运算符 op= 某些赋值表达式的缩写 逗号运算符 , 优先级最低 补充 赋值表达式:如果 expr1 和 expr2 是表达式,那么赋值表达式 expr1 = (expr1) op (expr2)等价于:expr1 op= expr2其中op可以为+,-,*,/,%,&lt;&lt;,&gt;&gt;,|,^,&amp; 之一.则op=可以称为赋值运算符.同赋值表达式一样, 赋值运算符的类型是它的左操作数的类型,其值是赋值操作完成后的值.逗号运算符:被逗号分隔的一对表达式将按照从左到右的顺序进行求值,语句的类型与值为表达式最右边的操作数的类型和值.某些情况下的逗号并不是逗号运算符,比如分隔函数参数的逗号,分隔声明中变量的逗号等,这些逗号并不保证各表达式按从左至右的顺序求值. 类型转换 1. 自动转换是指把’比较窄的’操作数转换为’比较宽的’操作数,并且不丢失信息的转换. 场景: (1)赋值表达式： 赋值运算符右边的值需要转换为左边变量的类型,左边变量的类型即赋值表达式结果的类型; (2)二元运算: 如果二元运算符的两个操作数具有不同的类型,那么在进行运算之前先要把“较低”的类型提升为“较高”的类型,且运算的结果为较高的类型(long double &gt; double &gt; float &gt; long &gt; int &gt; (char/short)) 注: char和short在参与运算时,会先转成int (3)函数调用: 在没有函数原型的情况下,char 与 short 类型都将被转换为 int 类型,float 类型将被转换为double 类型 2. 强制(手动)类型转换: 格式: (类型名)表达式 [这里用到了强制转化运算符] 示例: long x = 0.123; int y = (int)x; # y == 0 注意 1. C 语言没有指定同一运算符中多个操作数的计算顺序(&amp;&amp;、||、?: 和,运算符除外). 即: x = f() + g(); 语句中,f()可以在 g()之前计算,也可以在 g()之后计算 2. C 语言没有指定函数各参数的求值顺序 即: printf(“%d %d\n”, ++n, power(2, n)); 语句的结果取决于编译器的具体实现 3. ANSI C标准明确规定了所有对参数的副作用都必须在函数调用之前生效 4. 书中写到: 在任何一种编程语言中,如果代码的执行结果与求值顺序相关,则都是不好的程序设计风格. 本人对此持怀疑态度]]></content>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重启博客记]]></title>
    <url>%2F2017%2F12%2F26-%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[我所在的公司为了保证迭代速度，因此在初期选用了功能强大的Django框架进行开发。因此目前公司后端所用到的技术大多是与Django能很好的合作的。Celery就是这样一个工具，可以使用它来进行一些异步处理。 为了能跟上公司技术进步的脚步，这段时间一直在看Celery与RabbitMQ的官方文档进行学习。然而，Flynnon的英语并不是很好….因此学习的很慢。 其实RabbitMQ还好，示例清楚明了，在跟着Tutorials走了一遍后，感觉对于它有什么作用，以及如何使用Python进行开发有了一定的了解。然而这一套在Celery这里就行不通了，看了很久都没弄懂它是怎么用的… 于是就通过百度搜索了一下Celery，在结果中看到了很多博主写的博客。虽然有很多纯粹是复制粘贴的，质量很差，但是也有不少质量很高的博客，使我茅塞顿开。 在这个过程中就萌生了写一些东西的想法，其实在16年的时候就搭建了博客(虽然处于半废弃状态…)，于是就想着把他捡起来，重新开始Flynnon的博客之旅。 重建博客大约花费了四天，这段时间大约做了以下工作: 1. 建立博客。通过查看Hexo的官方文档，重新构建了对Hexo的认知，并建立了新的博客，并对之前的博文进行了迁移操作; 2. 选择主题。这一步花费了很长时间，我之前使用的主题是vno，它很不错，但是既然是重新来过，就把主题也一起换了…，最后选择了NexT主题，感觉它看起来很简洁，并且用户很活跃; 3. 定制化。主要是通过查看NexT的文档对博客进行配置，也添加了很多很使用的功能(Google Analytics etc.)。在这里主要参考了Ele的博客，构图什么的都是从那里偷的…. 4. 完善细节。这一步始终在进行…. 希望我可以坚持下去，搭建一个不错的博客吧….]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java控制访问权限的方法]]></title>
    <url>%2F2017%2F02%2F27-%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%90%E4%B8%80%E4%BD%8D%E7%BD%AE%E4%B8%BA%E7%95%8C%EF%BC%8C%E4%BA%A4%E6%8D%A2%E5%85%B6%E4%B9%8B%E5%89%8D%E4%B8%8E%E4%B9%8B%E5%90%8E%E7%9A%84%E9%83%A8%E5%88%86(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：给定一个字符串str和一个整数i，i代表字符串中某一个元素的下标，将str[0..i-1]移到这个元素的右侧，将str[i+1..len(str)-1]移到这个元素的左侧。(要求：时间复杂度为Ｏ(N),空间复杂度为Ｏ(1)).测试用例样例： 输入：”abcde”, 2 预期结果: decab 下面是Java实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Created by Flynnon on 17-2-27. * 问题：给定一个字符串str和一个整数i，i代表字符串中某一个元素的下标，将str[0..i-1]移到这个元素的右侧，将str[i+1..len(str)-1]移到这个元素的左侧。 * 要求：时间复杂度为Ｏ(N),空间复杂度为Ｏ(1) */public class Test &#123; /** * 将一个数组以某一元素分界，将这个元素之前的部分与之后的部分互换位置 * 主要思路: 将之前的部分与之后的部分分别逆序，再将整体逆序即可 * @param str 要进行操作的字符串 * @param i 作为分界线的元素的下标 * @return 转化之后生成的字符串 */ public static String replaceBeginAndEnd(String str, int i) &#123; if (str == null || i &lt; 0 || str.length() &lt;= i) &#123; return str; &#125; char[] chars = str.toCharArray(); reverseCharArray(chars, 0, i - 1); reverseCharArray(chars, i + 1, chars.length - 1); reverseCharArray(chars, 0, chars.length - 1); return new String(chars); &#125; /** * 用来翻转一个数组的某一部分 * @param charArray 要进行操作的数组 * @param begin 要翻转的部分第一个元素的下标 * @param end 要翻转的部分最后一个元素的下标 */ public static void reverseCharArray(char[] charArray, int begin, int end) &#123; char tmp; while (begin &lt; end) &#123; tmp = charArray[begin]; charArray[begin] = charArray[end]; charArray[end] = tmp; begin++; end--; &#125; &#125; public static void main(String[] args) &#123; String str = "abcde"; System.out.println(replaceBeginAndEnd(str, 2)); &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历二叉树并用二维数组保存(Java实现)]]></title>
    <url>%2F2017%2F02%2F27-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BF%9D%E5%AD%98(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。 给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。 测试用例样例： 输入：节点值为1-7的满二叉树。 预期结果： [1 ] [2,3] [4,5,6,7] 下面是Java实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.*;/** * Created by Flynnon on 17-2-27. * 问题：有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。 * 给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列. */public class BinaryTreeUtil &#123; /** * 定义节点类 * 为了简单就不定义getter/setter方法了 */ public static class Node &#123; public Node()&#123; this(0); &#125; public Node(int v)&#123; value = v; &#125; int value; Node left = null; Node right = null; &#125; /** * 进行转化的工具类 * 主要思路：主要思路与带行号层序遍历二叉树类似，只是用可变长数组（List）来存储每一行的元素 * @param root 要遍历的二叉树的根节点 * @return 此二叉树转化成的二维数组 */ public static int[][] getTreeValueArray(Node root) &#123; // 保证这颗二叉树非空 if (root == null) &#123; return new int[][]&#123;&#125;; &#125; // curLineLast : 当前行结尾节点 // nextLineLast : 下一行结尾节点 // 刚开始时，curLineLast与nextLineLast均指向根节点 Node curLineLast = root, nextLineLast = root; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); // 外层 List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); // 内层 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!q.isEmpty()) &#123; Node temp = q.poll(); // 只有当前节点的子节点不为空时，nextLineLast才需要更改指向的目标 if (temp.left != null) &#123; q.add(temp.left); nextLineLast = temp.left; &#125; if (temp.right != null) &#123; q.add(temp.right); nextLineLast = temp.right; &#125; // 将当前节点（值）加入内层 list.add(temp.value); // 当出栈节点为当前行尾节点时，说明该换行了 if (curLineLast == temp) &#123; // 换行时将内层加入到外层中 lists.add(list); // 新初始化一个内层 list = new ArrayList&lt;&gt;(); // 将当前行尾节点指向下一行尾节点 curLineLast = nextLineLast; &#125; &#125; // 将得到的List转化为int[] int[][] ints = new int[lists.size()][]; for (int i = 0; i &lt; ints.length; i++) &#123; Integer[] integerArray = lists.get(i).toArray(new Integer[0]); ints[i] = new int[integerArray.length]; for (int j=0;j&lt;integerArray.length;j++)&#123; ints[i][j] = integerArray[j]; &#125; &#125; return ints; &#125; /** * 前序递归构造二叉树 root-&gt;left-&gt;right * * @param scanner 输入流，用于读取节点值 * @return 构造完成的二叉树的根节点 */ public static Node createTreeNode(Scanner scanner) &#123; assert scanner != null; Node root = null; //声明当前根节点 int data = scanner.nextInt(); if (data &gt; 0) &#123; //若当前节点存在（这里为了简单以负数为占位符） root = new Node(data); //使用其它顺序构造二叉树，只需更改这三句即可 root.left = createTreeNode(scanner); root.right = createTreeNode(scanner); &#125; return root; &#125; /** * 测试类 * 以1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1为例 */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = Test.createTreeNode(sc); sc.close(); int[][] result = BinaryTreeUtil.getTreeValueArray(root); for (int[] arr : result) &#123; System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带行号遍历二叉树(Java实现)]]></title>
    <url>%2F2017%2F02%2F27-%E5%B8%A6%E8%A1%8C%E5%8F%B7%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：给定一颗二叉树，要求输出它的层序遍历，并在每行开始时输出行号。测试用例样例： 输入：节点值为1-7的满二叉树。 预期结果： 1 : 1 2 : 2 3 3 : 4 5 6 7 下面是Java实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;/* Created by Flynnon on 17-2-26. 对二叉树带行号的层序遍历的归纳 *//** * 定义节点类 * 为了简单就不定义getter/setter方法了 */class Node &#123; public int value; public Node left; public Node right; public Node() &#123; this(0); &#125; public Node(int v) &#123; this.value = v; this.left = null; this.right = null; &#125;&#125;/** * 对二叉树进行操作的工具类 */class PrintBinaryTree &#123; //私有化构造函数 private PrintBinaryTree() &#123; throw new RuntimeException("该工具类不应该被实例化"); &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下） * 主要思路：利用队列先进先出的性质保存顺序 * * @param root 要遍历的二叉树的根节点 */ public static void levelTraversal(Node root) &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); if (temp != null) &#123; System.out.print(temp.value + " "); q.add(temp.left); q.add(temp.right); &#125; &#125; &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下）,并附带行号 * 主要思路：利用队列先进先出的性质保存顺序来层序遍历二叉树。 * 使用curLineLast与nextLineLast两个节点标志来标识遍历过程中当前行结尾节点与下一行结尾节点， * 再使用一个lineNo整形量来记录当前行号（初始设为1），并在curLineLast节点更替时，更新lineNo的值并按格式打印即可。 * 注：nextLineLast始终指向最新遍历到的节点 * @param root 要遍历的二叉树的根节点 */ public static void levelTraversalWithLineNo(Node root) &#123; // 加入断言，保证root不为null assert root != null; // curLineLast : 当前行结尾节点 // nextLineLast : 下一行结尾节点 // 刚开始时，curLineLast与nextLineLast均指向根节点 Node curLineLast = root, nextLineLast = root; // 设根节点所在的行为第1行 int lineNo = 1; System.out.print(lineNo + " : "); Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); // 只有当前节点的子节点不为空时，nextLineLast才需要更改指向的目标 if (temp.left != null) &#123; q.add(temp.left); nextLineLast = temp.left; &#125; if (temp.right != null) &#123; q.add(temp.right); nextLineLast = temp.right; &#125; System.out.print(temp.value + " "); // 当出栈节点为当前行尾节点时，说明该换行了 if (curLineLast == temp) &#123; // 将当前行尾节点指向下一行尾节点 curLineLast = nextLineLast; System.out.print(System.lineSeparator() + ++lineNo + " : "); &#125; &#125; &#125;&#125;/** * 测试类 */public class BinaryTree &#123; // 以1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1为例 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = PrintBinaryTree.createTreeNode(sc); sc.close(); System.out.print("层序遍历:"); PrintBinaryTree.levelTraversal(root); System.out.println("带行号的层序遍历:"); PrintBinaryTree.levelTraversalWithLineNo(root); &#125;&#125; 下面是测试用例及结果，与预期结果一致（多出的一个行号先忽略了吧….）。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从m个各不相同的元素中取出n个并进行全排列(Java实现)]]></title>
    <url>%2F2017%2F02%2F26-%E4%BB%8Em%E4%B8%AA%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AD%E5%8F%96%E5%87%BAn%E4%B8%AA%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%8E%92%E5%88%97(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：从m个各不相同的元素中取出n个，进行全排列，得到所有可能的结果。 即：输入为字符数组（数组内每个字符均不相同）和个数n，返回由这些字符组成的所有长度为n的字符串。测试用例样例： 输入为{‘a’,’b’,’c’}和个数1，返回值为{“a”,”b”,”c”} 输入为{‘a’,’b’,’c’,’d’}和个数2，返回值为{“ab”,”ac”,”ad”,”ba”,”bc”,”bd”,”ca”,”cb”,”cd”,”da”,”db”,”dc”} 下面是Java实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.List;/** * Created by Flynnon on 17-2-26. */public class ListChars &#123; /** * @param chars 总的字符序列（数组） * @param n 要取出的字符的个数 */ public static void doit(char[] chars, int n) &#123; if (n &lt;= 0 || chars == null) &#123; return; &#125; List&lt;Character&gt; charList = new ArrayList&lt;&gt;(); //通过这一步初始化序列的长度 for (int i = 0; i &lt; n; i++) &#123; charList.add('#'); &#125; listAll(charList, chars, n); &#125; /** * 从m个元素中任取n个并对结果进行全排列 * @param list 用于承载可能的排列情况的List * @param chars 总的字符数组，长度为m * @param n 从中取得字符个数 */ public static void listAll(List&lt;Character&gt; list, char[] chars, int n) &#123; if (n == 0) &#123; //这里偷懒，直接打印了.... System.out.println(list); // 输出一种可能的排列 return; &#125; for (char aChar : chars) &#123; // 暴力尝试 if (!list.contains(aChar)) &#123; // 若List中不包含这一位元素 list.set(list.size() - n, aChar); // 将当前元素加入 &#125; else &#123; // 否则跳到下一位 continue; &#125; listAll(list, chars, n - 1); // 下一位 list.set(list.size() - n, '#'); // 还原 &#125; &#125; public static void main(String[] args) &#123; // 以字符数组承载总的字符集合 char[] chars = &#123;'a', 'b', 'c', 'd'&#125;; ListChars.doit(chars, 2); &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的递归构建及先序、中序、后序、层序遍历(Java实现)]]></title>
    <url>%2F2017%2F02%2F25-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E6%9E%84%E5%BB%BA%E5%8F%8A%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E3%80%81%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要展示的是：二叉树的递归构建，先序、中序、后序遍历（递归和循环），层序遍历的Java语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;/* Created by Flynnon on 17-2-25. 对二叉树的递归定义、前序、后序、中序、层序遍历方法的归纳 *//** * 定义节点类 * 为了简单就不定义getter/setter方法了 */class Node &#123; public int value; public Node left; public Node right; public Node() &#123; this(0); &#125; public Node(int v) &#123; this.value = v; this.left = null; this.right = null; &#125;&#125;/** * 对二叉树进行操作的工具类 */class PrintBinaryTree &#123; //私有化构造函数 private PrintBinaryTree()&#123; throw new RuntimeException("该工具类不应该被实例化"); &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下） * 主要思路：利用队列先进先出的性质保存顺序 * @param root 要遍历的二叉树的根节点 */ public static void levelTraversal(Node root) &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); if (temp != null) &#123; System.out.print(temp.value + " "); q.add(temp.left); q.add(temp.right); &#125; &#125; &#125; /** * 前序遍历二叉树（递归） root-&gt;left-&gt;right * @param root 要遍历的二叉树的根节点 */ public static void preOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; System.out.print(root.value + " "); preOrderRec(root.left); preOrderRec(root.right); &#125; /** * 前序遍历二叉树（非递归） root-&gt;left-&gt;right * 主要思路：利用栈保存未打印的节点，然后逐个出栈处理，在此过程中更新栈 * @param root 要遍历的二叉树的根节点 */ public static void preOrderUnRec(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); Node temp; while (!stack.empty()) &#123; //root==null时，只会空转一个循环，因此无需判断 temp = stack.pop(); if (temp != null) &#123; System.out.print(temp.value + " "); stack.push(temp.right); //注意：这里的入栈顺序是先right后left stack.push(temp.left); // 以保证从栈中取出时为先left后right &#125; &#125; &#125; /** * 后序遍历二叉树（递归） * @param root 要遍历的二叉树的根节点 */ public static void postOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; postOrderRec(root.left); postOrderRec(root.right); System.out.print(root.value + " "); &#125; /** * 后序遍历二叉树（非递归） left-&gt;right-&gt;root * 主要思路：利用栈保存未打印的节点，然后逐个出栈，进行判断，并根据需要更新栈 * 因为是处理完左右子树后，再处理根(回溯)，所以需要一个记录上一个被打印的节点的引用 * @param root 要遍历的二叉树的根节点 */ public static void postOrderUnRec(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); //cur:当前节点 pre:上一个被打印的节点 Node cur, pre = null; while (!stack.empty()) &#123; //查看（不是取出）栈顶的结点 cur = stack.peek(); //如果当前结点没有孩子结点（叶子节点） //或者孩子节点都已被打印过（这里不可能出现有两个子节点却只打印了其中一个的情况） //说明该打印当前节点了 if ((cur.left == null &amp;&amp; cur.right == null) || (pre != null &amp;&amp; (pre == cur.left || pre == cur.right))) &#123; System.out.print(cur.value + " "); //打印当前结点 stack.pop(); //被打印的节点（当前节点）出栈 pre = cur; //更新pre的值 &#125; else &#123; if (cur.right != null) //若未轮到当前节点，将当前节点的右节子点、左子节点入栈 stack.push(cur.right); //注意：这里的入栈顺序是先right后left if (cur.left != null) // 以保证从栈中取出时为先left后right stack.push(cur.left); &#125; &#125; &#125; /** * 中序遍历二叉树（递归） * @param root 要遍历的二叉树的根节点 */ public static void inOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; inOrderRec(root.left); System.out.print(root.value + " "); inOrderRec(root.right); &#125; /** * 中序遍历二叉树（非递归） left-&gt;root-&gt;right * 主要思路：模拟递归的过程，将左子树节点不断的压入栈，直到左叶子，然后处理栈顶节点的右子树 * @param root 要遍历的二叉树的根节点 */ public static void inOrderUnRec(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = root; //纯粹是为了好看...JVM会优化 while (cur != null || !stack.isEmpty()) &#123; //当root==null时，不会进入循环，因此无需判断 while (cur != null) &#123; //从当前节点开始，从上到下将最左边的那一列节点入栈 stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); //取出栈顶的节点（该节点左节点为null，因此现在该打印它） System.out.print(cur.value + " "); cur = cur.right; //定位到已打印的节点的右子节点 &#125; &#125; /** * 前序递归构造二叉树 root-&gt;left-&gt;right * @param scanner 输入流，用于读取节点值 * @return 构造完成的二叉树的根节点 */ public static Node createTreeNode(Scanner scanner) &#123; assert scanner!=null; Node root = null; //声明当前根节点 int data = scanner.nextInt(); if (data &gt; 0) &#123; //若当前节点存在（这里为了简单以负数为占位符） root = new Node(data); //使用其它顺序构造二叉树，只需更改这三句即可 root.left = createTreeNode(scanner); root.right = createTreeNode(scanner); &#125; return root; &#125;&#125;/** * 测试类 */public class BinaryTree&#123; // 这里以节点值分别为1-7的满二叉树为例 // 1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = PrintBinaryTree.createTreeNode(sc); sc.close(); System.out.print("层序遍历:"); PrintBinaryTree.levelTraversal(root); System.out.print("\n中序递归遍历:"); PrintBinaryTree.inOrderRec(root); System.out.print("\n中序非递归遍历:"); PrintBinaryTree.inOrderUnRec(root); System.out.print("\n前序递归遍历:"); PrintBinaryTree.preOrderRec(root); System.out.print("\n前序非递归遍历:"); PrintBinaryTree.preOrderUnRec(root); System.out.print("\n后序递归遍历:"); PrintBinaryTree.postOrderRec(root); System.out.print("\n后序非递归遍历:"); PrintBinaryTree.postOrderUnRec(root); &#125;&#125; 这是测试结果截图（本测试用例没问题）： 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java控制访问权限的方法]]></title>
    <url>%2F2016%2F11%2F05-Java%E4%B8%AD%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[这篇博客主要用来介绍Java中的访问权限. 引入访问控制权限 我们都知道，一个通用类库(如：JDK)开发出来的目的是让普通开发者重用以节省开发时间与精力，但是类库的设计不可能在刚开始就尽善尽美，普通开发者在对类库的使用过程中，总能发现很多由于设计不当所出现的问题，这时，类库开发者就需要对类库进行重构。 而类库的更新不能影响到消费者程序的执行，这就引出了面向对象设计的一个基本问题：类库开发者如何区分可以变动的部分和不可以变动的部分？ Java这门语言在设计的时候吸收了很多前人的经验，所以这个问题也被抛了出来，而它解决这个问题的方法是通过访问修饰符，即限制普通开发者访问的部分。 对于访问权限成型的一些思考 在设计时很容易想到使用二分，即将访问权限分为可以访问与不能访问两种，也就是引入public与private。如果域被public修饰，说明这个部分可以被任何人访问到；如果域被private修饰，则除了当前类其他人都不能访问。但这样又会出现一些问题，即使用绝对的二分产生的副作用太大，被private修饰的域连类库开发者本身都无法访问了。 Java在引入包进行命名空间的管理之后，就有了一种较为优秀的解决方法，即引入friendly与protected，对于具有friendly访问权限的域，只有同一个包内的类可以访问；对于具有protected访问权限的域，只有此域所在类的子类或与此类在同一个包内的类可以访问，这样就划分了较为清楚的界限。 一般来说，用户自己写的类会被划分到自己特有的包中，这种情况下，这种访问权限控制的方式对于类库开发者与用户来说是正确的。但是，并不是所有的用户都会遵守规则，如果用户恶意使用类库开发者使用的包，还是会产生权限泄露，即用户访问到了类库开发者隐藏的东西。对于这种情况有什么解决方法么？ 个人认为：这个问题根本不是问题….因为权限控制实际上是一种约定，这种约定的内涵是：在使用双方都遵守的情况下，双方都可以得到较满意的答案（即：类库开发者拥有重构的 对于类库开发者来说唯一的约束是那些自己公开的API。也就是说对于已经公开的API，也许会有用户使用，这种情况下一定不能更改API以避免影响用户已经开发过的Java应用程序（保证向下兼容），那么对于类库开发者认为用户一定无法访问的部分就可以随便改了，在用户自己违反了约定的情况下，他的权益就无法也无需得到保证。 Java访问权限关键字介绍 上面说到Java中分了四种访问权限，一表胜千言，下面是详细的介绍。 关键字 含义 类内部 本包 子类 外部包 public 公有的 √ √ √ √ protected 受保护的 √ √ √ × default 缺省(包访问权限) √ √ × × private 私有的 √ × × × 一些需要注意的小问题 Java的权限控制只停留在编译期间。 它不会在编译生成的class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。因此，通过反射可以访问任何包下任何类中的成员，包括私有成员。 类的访问修饰符。 对于一个非内部类来说，因为它直属于包而不属于任何一个类，所以只有包访问权限与公有权限对它来说才有意义。也就是说，只能用public或者默认权限来修饰非内部类。 对于一个内部类来说，它直属于一个类，因此四种权限都可以对其起作用。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识AJAX]]></title>
    <url>%2F2016%2F09%2F06-%E5%88%9D%E8%AF%86AJAX.html</url>
    <content type="text"><![CDATA[这几天一直在看书，大致了解了AJAX技术，在这里做一个小小的总结。 简单了解AJAX 我觉得维基百科是比较准确的一个信息源，因此，我们先来看维基百科中对于AJAX的定义。 在维基百科上我们可以看到：AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。 那么，现在我们对AJAX有一个大致的印象：AJAX=JavaScript+XML。而js和xml我们至少都应该听说过。 AJAX为什么会出现 回顾我们的开发旅程，在使用Servlet+JSP+JavaBean开发基于B/S架构的应用的过程中，交互是如何实现的？用户在网页端填写并提交表单（Form），然后点击提交按钮向网页服务器发送请求（Request）。服务器接收请求并处理传来的表单，返回响应(Response)，浏览器取得响应信息后，通过解析将页面展示在浏览器上。 然而，这种模式存在很多问题。现在看这样一个例子：浏览器端展示了用户登陆界面，当用户输入用户名、密码及验证码后，数据被发送到了服务器，假定我们在Servlet中处理请求后发现用户名及密码不匹配，接下来的处理流程是什么样的？ 我们会将包含页面及错误信息的响应返回给浏览器端，浏览器在解析响应后对这些信息进行展示。使用这样的开发流程，无论后台业务逻辑实现的多么完美都会存在一些固有的问题： 首先，十分浪费带宽。在前后两个页面中除了展示错误信息的部分外其它元素全都是相同的，完全没有必要再次传输，在设计者的预想中，只需要对第一次的界面信息进行复用就可以了。 其次，用户体验差。在传统的开发模式下，假设我们是用户，一旦在登陆页面的表单中不小心输入了错误的密码(因为密码框是密文，所以无法得知具体的输入)，在提交表单后就会出现下列情况：等待一段时间后页面才被刷新、界面提示用户名错误、原来的输入都被清空。这样我们又得重新输入一遍用户名及密码，体验极不友好。在我们的的网速比较慢的情况下，体验还会更差。这对于产品经理及网站的用户来说都是不可忍受的。 那么有没有什么方法可以解决这种问题呢？也就是说，能不能在用户刚输入密码时就得到服务器端的反馈呢？ AJAX解决上述问题的思路 技术的更新总是一环套一环的，在js的XMLHttpRequest对象出现之前这个问题是没有优雅的解决办法的，只能使用一些丑陋的方法并且效果还不是特别好。但是在XMLHttpRequest对象出现之后，前辈们立刻就想到了一种比较好的解决方法，即：使用XMLHttpRequest对象作为Agent来将请求发送给服务器，并用它来接收服务器返回的数据，这样就可以不跳转页面完成数据的交互，而且只需要传输少量必要的数据，因此对网速的要求也变低了。 但是，还有两个问题没有解决： 1.如何根据服务器端返回的数据动态更改页面，以达到与用户交互的作用？ 2.如何规定服务器发送回来的数据格式？ 下面来看前辈们选择的解决方法： 对于1：前辈们选择了使用JavaScript。个人认为这样做的原因有两个，第一，JavaScript足够流行，几乎所有的主流浏览器都对JavaScript提供了支持；第二，JavaScript可以通过DOM编程的方式来动态的改变网页的内容。 对于2：前辈们选择了XML，我想可能是因为它语法足够严格、语义明确而且更加通用吧。但是我认为传输的数据格式对使用AJAX并没有影响。例如，我们可以选择传输Json来使传输的数据更加少，甚至可以只是传输一段有意义的字符串，只要服务器端开发者与浏览器端开发者对字符串格式进行了约定即可。 AJAX的准确定义 在了解了上面的内容后，我们就可以对AJAX进行一个准确的定义了：AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 下面我们来看一下，如何利用AJAX技术进行开发。 使用AJAX开发的步骤-概述 关于AJAX更详细的介绍，可以查看W3School中对于AJAX的介绍 下面是我简单总结的AJAX实现步骤： 1. 我们需要一个XMLHttpRequest对象。（我们都知道IE低版本浏览器的标准很很多都与主流标准不兼容。很不幸，对于XMLHttpRequest对象也是一样的….） 因此，一个XMLHttpRequest对象的获取过程可以是这样的： 123456var httpXml = null;if(window.XMLHttpRequest)&#123; httpXml = new XMLHttpRequest(); //针对现代浏览器，IE7及以上版本&#125;else if(window.ActiveXObject)&#123; httpXml = new ActiveXObject("Microsoft.XMLHTTP"); //针对IE5,IE6版本&#125; 2.我们需要为这个XMLHttpRequest对象注册它要进行的操作（通过回调），并根据返回的请求状态与HTTP状态码来查看消息的状态，并确定在何种情况下我们要进行何种操作。 这个过程是这样的： 12345678//为XMLHttpRequest对象的onreadystatechange属性注册httpXml.onreadystatechange=function()&#123; // 在回调函数中根据请求状态与返回的HTTP状态码来选择相应的操作处理数据 if(httpXml.readyState==4&amp;&amp;httpXml.status==200)&#123; //这里只是简单的显示接收到的文本信息 alert(httpXml.responseText); &#125;&#125;; 3.我们需要进行请求发送的参数设置。 这个过程是这样的： 123456//函数原型：open(method,url,async,username,password)//method ---&gt;请求方式:GET,POST或HEAD//url ---&gt;请求的地址 GET提交方式可以在后面加上参数//async ---&gt;请求是否异步执行，true---异步，false---同步 默认为true//username,password ---&gt;可选，为url所需的授权提供认证资格。如果不为空，会覆盖掉url中指定的资格httpXml.open("GET","http://localhost:8080/aaa/MyServlet",true); 4.要真正的发送请求啦！ 1234// 参数为请求参数,POST提交内容格式为---&gt;"username=taffy&amp;password=666",GET为-----&gt;空// 注意：若为POST请求方式，还需设置一个http请求头(应该位于open之后,send之前)// 即 setRequestHeader("CONTENT-TYPE","application/x-www-form-urlencoded"); 标志form表单的enctype属性 httpXml.send(null); 这样，一个简单的AJAX过程就完成了。 一些没有介绍的小知识点： 12345678//XMLHttpRequest对象的重要属性responseText 得到返回的文本信息responseXML 得到返回的XML信息//XMLHttpRequest对象的重要方法getResponseHeader() 得到指定头部信息getAllResponseHeaders() 将 HTTP响应头部作为未解析的字符串返回//XMLHttpRequest对象的控制方法abort() 取消当前响应，关闭连接，将readyState置0 简单的Demoregister.html（客户端页面） javascript123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type="text/javascript"&gt; &lt;!--&gt;onload:页面加载完成后调用 &lt;--&gt; window.onload = function()&#123; var user = document.getElementById("my_user"); //获取XMLHttpRequest对象 var httpXml = null; if(window.XMLHttpRequest)&#123; httpXml = new XMLHttpRequest(); //针对现代浏览器，IE7及以上版本 &#125;else if(window.ActiveXObject)&#123; httpXml = new ActiveXObject("Microsoft.XMLHTTP"); //针对IE5,IE6版本 &#125; user.onblur=function()&#123; httpXml.onreadystatechange=function()&#123; if(httpXml.readyState==4&amp;&amp;httpXml.status==200)&#123; if(httpXml.responseText!="true")&#123; alert("用户名不存在"); &#125; &#125; &#125;; httpXml.open("GET","http://localhost:8080/aaa/MyServlet?user="+user.value,true); httpXml.send(null); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="http://localhost:8080/aaa/AnotherServlet"&gt; &lt;input type="text" name="username" id="my_user"&gt; &lt;input type="text" name="password" id="my_pass"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; MyServlet.java（服务器端逻辑） 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class MyServlet */@WebServlet("/MyServlet")public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public MyServlet() &#123; super(); &#125; @override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter out = response.getWriter(); String username = request.getParameter("user"); if (username!=null&amp;&amp;!username.equals("")) &#123; if (username.equals("admin")) &#123; out.write("true"); &#125;else &#123; out.write("false"); &#125; &#125;else &#123; out.write("false"); &#125; out.close(); &#125; @override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 上面的小demo可以正常实现逻辑，就不放结果了…. Ajax的优缺点 优点： 能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送重复的信息，减少了流量。 缺点： 1.它可能破坏浏览器的后退功能。在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记下历史记录中的静态页面(现代浏览器一般都可以解决这个问题)； 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。 大致就是这样啦。本人水平有限，欢迎指正。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo!]]></title>
    <url>%2F2016%2F09%2F02-HelloHexo.html</url>
    <content type="text"><![CDATA[其实在很久之前我就想搭建一个个人博客，可是因为自己太懒，而且不敢去开始，所以一直没有付诸行动。最近几天，在看到了田浩同学分享的特别帅的个人博客页面后，想有一个自己个人博客的冲动突然就上来了。于是在经历了两天的漫无目的地寻找之后于2016-09-02成功建立了自己的个人博客。以后应该会将自己在学习的路上的一些想法与经验写在这里。不过话说回来….也不知道有没有人看….这里附上一些参考链接：建立这篇博客时参考的文章地址田浩同学帅炸了的博客]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
