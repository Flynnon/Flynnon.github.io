<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[《RabbitMQ实战》笔记(三)]]></title>
    <url>%2F2018%2F07%2F11-RabbitMQ_3.html</url>
    <content type="text"><![CDATA[前言 这是笔记的第三部分….. 由于Flynnon并不是专业运维人员,因此很多细节就略过不表了(例如:负载均衡具体实现,主备机制等等),真到了用到的时候,再百度/Google吧… 负载均衡 这里简单了解一下负载均衡技术和RabbitMQ集群的协作方法,也就是使用为什么使用负载均衡,使用之后代码需要变化多少. 这部分的操作本质上是对负载均衡软件/硬件的配置,使得它可以对请求进行转发与均衡. 概念 上一篇提到的集群实现在使用的过程中还有很多可以优化的地方,其中一个就是在访问集群中的节点的时候需要指定IP,这样就会造成硬编码,且节点变更的时候不好维护.客户端必须对集群中的每一个节点IP做手动配置(也就是得有一个可用IP列表),并处理集群节点的选择和故障服务器的检测.由于节点的选择是由各个客户端自行进行选择的,因此负载也不会平均. 对于这种不太好的实践,可以使用负载均衡(感觉也有反向代理思路)技术来进行处理,即:使用一个单独的负载均衡器(代理)来接收所有请求,然后将请求转发到集群中的某一个节点.而这些对于客户端都是透明的,客户端只需要硬编码代理节点的IP地址(可以使用域名进一步进行配置解耦)即可. 代理节点还可以实现一些定制化功能,例如:故障节点检测(根据不同的算法对后端节点进行检测,剔除挂掉的节点),负载均衡(根据不同的算法进行转发,使得各个后端节点的负载相近),请求分析等等. 由于RabbitMQ与客户端通信使用的是TCP,因此负载均衡软件需要能够做到四层负载均衡.本书使用的是HAProxy. 编码 接下来看看,我们的编码会产生什么样的变化. 对于生产者来说,本书的意思是无需特殊处理(消费者每次都会建立新的连接).但我并不是很认同….pika库的channel对象有一个add_on_cancel_callback方法,应该是为了处理这种情况的,但是还没有找到示例…先放着吧… 对于消费者来说,由于需要处理连接异常(所连接的节点故障或者实际监听的队列所在的节点故障)的情况.因此需要做异常处理与重试.本书给出的处理方式也是很简单粗暴(不断的重建连接).下面的示例中所做的假设为当出现故障时(无论是上述哪一个),都会引发异常. 123456789101112131415161718192021222324import pikaimport jsonconnection = Nonewhile True: try: connection = pika.BlockingConnection(pika.ConnectionParameters(host='rabbitmq')) channel = connection.channel() method_ = channel.queue_declare(queue='order_queue') queue_name = method_.method.queue channel.exchange_declare(exchange='payment', exchange_type='topic', auto_delete=False, durable=True) channel.queue_bind(queue_name, 'payment', routing_key='ordering.create',) def on_request(ch, method, props, body): do_something() channel.basic_consume(on_request, queue=queue_name, no_ack=False) channel.start_consuming() except Exception: # 这里忽略产生的异常,重建连接 if connection: connection.close() 插件 插件是一种扩展作者未能预见到的服务器的行为方式,RabbitMQ的插件也是使用Erlang编写的,且和服务器一同运行在同一个Erlang VM中.细节可以参考官方文档. 这部分介绍了RabbitMQ Management插件的使用,感觉这个用处不大,就不详细写了.可以参考官方文档. 安装 对于直接集成好的插件,无需安装. 对于没有集成的插件,需要下载(文件的后缀为.ez)后将其拷贝到插件目录(基本是在RabbitMQ安装目录下有一个plugins目录). 操作12345678# 列出所有插件sudo rabbitmq-plugins list# 启用某插件,然后,需要重启RabbitMQsudo rabbitmq-plugins enable $&#123;plugin_name&#125;# 禁用某插件sudo rabbitmq-plugins disable $&#123;plugin_name&#125; 性能 这部分介绍的主要是一些性能优化(取舍)技巧与安全相关的内容. 消息持久化 消息持久化可以避免由于RabbitMQ异常宕机(系统异常、软件bug等等原因)引起的消息丢失,是一个蛮好的扩展. 然而,由于持久化需要将消息写入磁盘(无需持久化的消息只需存在于内存中),因此会产生大量的磁盘IO,并降低消息周转速度.因此,一个比较好的实践是,对于不重要(可以容忍部分丢失)的消息,可以不做持久化处理. 消息确认 消息确认机制可以使得RabbitMQ对于消费者的消费情况有一个感知,从而在消费者发生故障的时候对消息进行重新投递,以保证消息一定会被消费成功(开启自动确认模式时,消费者故障/连接中断都会使得消息丢失).并且可以通过这个机制来控制消息的投递速率. 然而,相应的,这个机制也会使得消费者的消费速度变慢(在消费成功/失败后需要返回状态),且使得RabbitMQ的处理逻辑变复杂(在每一条消息投递出去后,都需要关注其结果). 因此,一个比较好的实践是,对于可以容忍部分丢失的消息,消费者可以开启自动应答以加快处理速度. 消费路由 这部分主要是回顾了下fanout,direct和topic三种交换机的特性,并简单介绍了交换机及绑定的存储方式. 主要介绍了功能最强大的topic交换机的一些细节.例如:使用Trie树(字典树)来存储绑定路由键模式,以支持快速查询.并给出了RabbitMQ官网的博客一和博客二两篇参考资料. 通常情况下,topic模式相比其余两种,会慢一些,并且内存占用会多一些. 投递消息 本书给出了一个RabbitMQ中消息投递的流程图. 这个过程有如下需要注意的地方: 1. 从客户端的角度来看,异步投递会比同步投递快一些; 2. 如果队列是空的,且消费者准备好接受消息,那么,消息不会被放到队列中,而是被直接投递给消费者,这会极大的提升消息处理速度(当然,开启消息投递,且消费者没有及时返回确认时,还需要进行其它处理逻辑); 3. 在持久化消息到达持久化队列时,会被写入磁盘(持久存储),同时内存中也会存储一份以提升消息投递速度.否则,消息会被写入瞬态存储.在RabbitMQ服务器内存不足的情况下,一部分消息会被刷到磁盘上(瞬态存储); 4. 当RabbitMQ需要重启并恢复持久化队列时,只会查看持久存储中的内容,瞬态存储会被清空; 5. 为了保证投递速率,应该尽可能保证队列为空. 内存使用率 关于内存占用,官方文档为: memory-use.当然…Flynnon没有看… 队列声明: 当声明队列时,如果队列的durable属性设置为true的话,会在rabbit_queue和rabbit_durable_queue两个表中增加记录,否则只会在rabbit_queue表中增加记录.以上每一条记录大约占用29个字的大小(这里的字是Erlang中的概念,与操作系统相关,32位系统中,字长为4字节,64位系统中,字长为8字节).并且,依据AMQP规范,队列会被绑定到匿名交换机上.综上,大致流程如下: 交换机声明: 当声明交换机时,RabbitMQ会在rabbit_exchange表创建一条大约29字的记录.若交换机进行了持久化声明,也会在rabbit_durable_exchange上创建一条记录.图示如下: 交换机类型 rabbit_exchange rabbit_durable_exchange 持久化交换机 x x 瞬时交换机 x 字/记录 29 29 绑定声明: fanout与direct类型的交换机的绑定内存占用如下: 绑定类型(队列-交换机) rabbit_route rabbit_durable_route rabbit_semi_durable_route rabbit_reverse_route 持久化-持久化 x x x x 持久化-瞬时 x x x 瞬时-瞬时 x x 瞬时-持久化 x x 字/记录 44 44 44 44 topic类型的交换机: 除了上述规则外,topic类型的交换机还需要rabbit_topic_trie_binding和rabbit_topic_trie_edge两张表来存放匹配信息.绑定会存放在rabbit_topic_trie_binding表中,表中的一条记录大概占用45个字.且topic模式中有多少部分就会有多少条记录插入到rabbit_topic_trie_binding表中. Erlang进程计数 这里展示了Erlang进程计数对于RabbitMQ的影响. Erlang进程 Erlang的进程是指虚拟机管理的进程,而不是操作系统的重量级进程.这些进程的创建和销毁都非常迅速,且进程之间发送消息非常快速,同一时间可以拥有大量的进程. 由于进程运行于Erlang虚拟机上,因此进程在所有的操作系统上都具有相同的行为方式. Erlang进程不共享任何内存，是完全独立的,各个进程之间唯一的交互方式就是消息传递. 最大进程数 可以在启动RabbitMQ时指定Erlang节点上能运行的最大进程数(也就是运行rabbitmq-server -detached时指定SERVER_ERL_ARGS的+P选项来增加上限,当然….Flynnon没有进行尝试….).如果不指定的话,RabbitMQ默认的设置就会生效,每个Erlang节点可以有1048576(也就是2^20)个进程(一般来说肯定是够用了). 当Erlang的进程数超过了设置的最大进程数时,Erlang就会崩溃.进程数消耗如下: 行为 消耗进程数 新建连接 4 新建信道 4 队列声明 1 后记 本书还有一些比较高级的内容,如:SSL配置,集群设置等等,但是Flynnon暂时用不太上,因此就不记录了…]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《RabbitMQ实战》笔记(二)]]></title>
    <url>%2F2018%2F07%2F02-RabbitMQ_2.html</url>
    <content type="text"><![CDATA[前言 这是笔记的第二部分….. RabbitMQ与RPC 传统上,为了实现系统间的相互通信,可以使用RPC技术(Remote Procedure Call),而有很多方法可以实现远程过程调用,但是大多数实现都会使得服务端与客户端紧密相连(例如Flynnon公司使用的Django-Json-RPC框架…). 然而,大多数RPC的实现是点对点的,也就是说客户端需要知道服务端的地址,然后才能进行连接并调用.这种设计在系统规模比较小的时候当然很好用,但是一旦系统规模变大,问题就来了. 这里的问题主要是指可扩展性,当有多台提供相同服务的RPC服务器存在时,如何选择呢?或者有多台提供的服务不同的RPC服务器存在时,如何定位服务呢?SOAP和某些RPC架构采取了复杂的补充协议和服务目录来做这个事情,但这也带来了额外的复杂性和bug几率,并且传统的RPC是应答式的,请求主动权在客户端,当服务端挂掉的时候,需要客户端进行重连,还得找到能提供相同服务的服务端,这增加了客户端的工作量. RabbitMQ提供了一种模式可以实现RPC,可以解决以上的问题.下面进行详细介绍. 原理介绍 但是上一篇笔记也有提到,AMQP的消息是单向的,那么,服务端如何将信息返回客户端呢(尤其是,服务端无法得到客户端的信息)? RabbitMQ给出的解决方案是:使用消息回发应答. 具体的流程如下: 客户端声明一个队列A,在投递消息时将A的名称放置到消息头的reply_to字段中,然后对该队列进行监听. 服务端检查reply_to字段,在处理完成后将结果投递到该字段所指的队列中(还记得每个队列默认绑定一个队列么…). 客户端从被监听的队列中得到某个消息时,进行校验(是不是自己要接收的消息),如果是的话,取出消息,解除监听并进行后续处理即可. 优化 其实这个过程还是慢简单易懂的,但是如何保证消息不串呢? 可以使用以下方法: 1. 每次在进行队列声明时都不指定队列名(RabbitMQ自动生成),这样使得各个客户端所使用的队列不同,且设置auto_delete参数为True; 2. 在进行队列声明时设置exclusive参数为True,确保只有当前消费者可以读取队列上的消息. 上面使用的方法已经可以用了,但是每次连接都新建一个queue其实是有点费资源的,因此我们可以进行一些优化.由于每一条消息只能被消费一次,因此我们不能在多个客户端之间共享队列,但是对于一个客户端来说,我们可以合并多次相关请求,也就是为每一个客户端建一个queue(因为RPC语义上就是阻塞的,因此每一个客户端使用一个queue即可,因为同一时间不会有多个无关的服务端消息到达). 这时,我们就必须标识每一次的请求了(消息可能乱序,可能重传,可能丢失…),具体采取的方法是:在发送消息时,放入一个唯一的correlation_id属性,服务端在投递响应消息时,也将该字段置入消息中即可.这样,客户端就可以通过校验这个字段来判断是不是自己所需要的响应了. 实现 下面给出一个简单的RPC客户端实现(这部分有参考官方教程. 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990# coding=utf-8import uuidimport pikaclass RPCCallTimeoutException(Exception): passclass RPCClient(object): def __init__(self, connection=None, timeout=2, open_confirm=True): # 初始化连接 self.connection = connection or pika.BlockingConnection(pika.ConnectionParameters(host='rabbitmq')) # 获取channel self.channel = self.connection.channel() # 开启消费者确认模式 if open_confirm: self.channel.confirm_delivery() # 定义私有的,自动删除的队列 result = self.channel.queue_declare(exclusive=True, auto_delete=True) self.callback_queue = result.method.queue # 定义超时时间 self.timeout = timeout # 响应值 self.response = None # 唯一标识 self.corr_id = None # 设置监听 self.channel.basic_consume(self.on_response, no_ack=True, queue=self.callback_queue) def on_response(self, ch, method, props, body): # 校验消息是否为自己所需要的消息 if self.corr_id == props.correlation_id: self.response = body def on_timeout(self): # 超时时抛出异常 raise RPCCallTimeoutException() def call(self, exchange, routing_key, body, time_limit=0): assert body is not None # 初始化RPC的响应 self.response = None # 初始化生成唯一标识 self.corr_id = str(uuid.uuid4()) # 投递消息(调用RPC) if not self.channel.basic_publish(exchange=exchange, routing_key=routing_key, properties=pika.BasicProperties( reply_to=self.callback_queue, correlation_id=self.corr_id, ), body=body): raise RPCCallTimeoutException() # 设置超时触发器 if self.timeout is not None: self.connection.add_timeout(self.timeout, self.on_timeout) # 轮询结果 while self.response is None: self.connection.process_data_events(time_limit=time_limit) # 返回响应 return self.response __call__ = call # 后续的扫尾工作,这里不关闭connection是因为它可能会被外部复用 def __del__(self): if self.channel is not None: self.channel.close()# -- 调用 --import jsonrpc_client = RPCClient()try: resp = rpc_client(exchange='payment', routing_key='ordering.create', body=json.dumps(&#123;'ordering_no': 'ordering_no'&#125;)) print(json.loads(resp))except RPCCallTimeoutException: # 超时处理 print('超时啦，啦啦啦啦') 下面给出一个简单的RPC服务端实现. 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556# coding=utf-8import pikaimport json# 获取连接connection = pika.BlockingConnection(pika.ConnectionParameters(host='rabbitmq'))# 获取信道channel = connection.channel()# 定义队列method_ = channel.queue_declare(queue='order_queue')# 另一种取queue的name的方法queue_name = method_.method.queue# 定义交换机channel.exchange_declare(exchange='payment', exchange_type='topic', auto_delete=False, durable=True)# 建立绑定channel.queue_bind(queue_name, 'payment', routing_key='ordering.create',)# 具体处理逻辑的方法def create_order(ordering_no): # 处理业务逻辑 return ordering_no # return do_something(ordering_no)# 接收到消息时的回调def on_request(ch, method, props, body): # 取出参数 data = json.loads(body) ordering_no = data.get('ordering_no', None) # 对参数进行校验 if not ordering_no: # 发现参数不合法时, result = 'params_wrong' code = 'fail' else: result = create_order(ordering_no) code = 'success' # 发送响应 # 这里可以发出响应的原因是,在本函数结束之前,pika库不会再次开始消费,也就是本channel目前是空闲的 ch.basic_publish(exchange='', routing_key=props.reply_to, # 注意,这里将消息标识置入响应中 properties=pika.BasicProperties(correlation_id = props.correlation_id), body=json.dumps(&#123;'result': result, 'code': code&#125;)) # 对RabbitMQ发出确认 ch.basic_ack(delivery_tag=method.delivery_tag)# 限流channel.basic_qos(prefetch_count=1)# 设置监听的队列channel.basic_consume(on_request, queue=queue_name, no_ack=False)# 开始阻塞式监听channel.start_consuming() 后续脑洞 其实上述的demo没有实现线程安全,但是大概也是够用了..然而感觉还是不够完美,创建的队列还是太多了,感觉可以实现一个队列名称池进一步优化其性能…然而…暂时用不上,再说吧~~~ 上述的RPC服务器就可以很容易的水平扩展了,只要RabbitMQ不崩溃(当然,客户端和服务端需要连接同一个RabbitMQ实例)…. 集群 我们需要明白,RabbitMQ随时可能挂掉(操作系统异常,断电,RabbitMQ的bug等等原因),如果这时候我们仅仅有一个实例的话,所有处于上游的服务就都会产生问题,从而导致应用雪崩式崩塌….解决这个问题的方法就是使用RabbitMQ的集群. 首先,吹吹牛逼:RabbitMQ的内建集群简单易用,只需要十分钟就能完成搭建,并且还无需停止服务(当然,你得懂得怎么搭).接下来详细进行介绍. 好处 首先,我们要考虑为啥要用集群? 使用RabbitMQ集群且配置得当的话可以有以下两个好处: 1.生产者和消费者能够在某些节点挂掉的时候继续运行;2.可以通过添加更多的节点来线性的扩展吞吐量,提高性能. 架构存储信息 先来看看,RabbitMQ如何记录其中的各种基础组件并将它们装配成一个消息通信服务. 单机版 事实上,单机版的RabbitMQ会记录以下四种类型的内部元数据: 1. 队列,包括:名称以及特殊属性(是否可持久化,是否排他,是否可删除等等); 2. 交换机,包括:名称,类型和特殊属性(是否可持久化等等); 3. 绑定,可以认为是一张展示了如何路由消息到队列的信息; 4. vhost,为vhost内的队列、交换机、绑定提供命名空间和安全属性. RabbitMQ默认会将这些信息存储于内存中(需要持久化的信息会存储在硬盘上,以供重启时重建). 集群版 当RabbitMQ变成集群之后,它需要额外的记录一些新的元数据类型: 集群节点位置、节点与其它类型(上述类型)元数据的关系. 同样的,可以设置将元数据存在内存中或者磁盘中. 但是具体的存储方法,有了变化: 队列: 在集群模式下,仅仅会在单个节点而不是全部节点上创建完整的队列信息(元数据,状态,内容).也就是说,只有队列的所有者节点知道有关队列的所有信息,其余节点仅仅存储该队列的元数据以及指向该队列的指针(去往该队列的途径). 这个机制是可以理解的,否则当队列本身也在整个集群中共享(冗余)的话,RabbitMQ会变的异常复杂(需要考虑的事情变多),例如转发消息到某个节点上的队列还是全部队列?消费者监听哪个节点?节点之间要不要分工? RabbitMQ默认不将队列和内容复制到所有节点上,这大概是基于以下两方面的考虑: 1. 存储空间.很容易理解,这样并没有获得额外的空间节省; 2. 性能.若在消息发布时将消息复制到每一个节点,则对于持久化消息,会触发多次磁盘写入,且新增节点时,网络与负载压力都会变大,性能相比单机版并没有明显提升(甚至会下降). 当某个节点挂掉的时候,会发生什么事情呢?答案是,该节点所有的队列与绑定都暂时消失了(可能会被持久化).监听那些队列的消费者丢失了订阅信息,且匹配到该队列的消息也会丢失(队列不存在了).同时,对于持久化的队列,也不能进行重新声明(会产生一个 404错误,感觉是由于其余节点指向该队列的指针还存在),只能恢复挂掉的节点并使用.这个机制保证了当失败节点重新加入集群时,该节点上的队列信息不丢失. 交换机: 在集群模式下,交换机的元数据是在各个节点之间共享的.这里需要说明的是,交换机仅仅是一个数据结构(包括了名称和一个队列绑定列表),并不会对消息进行任何操作(Flynnon看到这里的时候有点懵逼…). 实际上,当我们将消息发布到交换机时,是channel来将消息上的路由键同交换机的绑定键进行比较,然后路由消息(也就是说,真正承担交换机职责的是channel).由于交换机仅仅是一张查询表,因此在整个集群中进行复制会简单很多(只需要同步信息即可).因此,当创建新的交换机时,RabbitMQ会将这个查询表添加到集群上的所有节点上(这带来的好处就是当某个节点挂掉之后,只需重新启动,消息就可以被立即转发到对应的节点上). 在节点挂掉的这段时间内,因为交换机(路由信息)还存在,因此消息生产者的channel可能会继续向目标队列投递消息(这些消息会丢失).为了避免消息丢失所带来的后果,可以使用事务或者发送方确认以获取这个信息并进行补偿. 元数据存储 无论是单机版还是集群版,节点都是内存节点(RAM Node)或者磁盘节点(Disk Node)之一. 简介 对于队列、交换机、绑定、用户、权限和vhost的元数据,内存节点会将它们存放在内存中,而磁盘节点会将它们存放在磁盘中.由于内存的易失性(重启后,数据会丢失),因此单节点系统仅能是磁盘节点,而在集群(多节点系统)中,可以将部分节点(最少也得有一个磁盘节点)声明为内存节点以获得更加快速的元数据声明速度(当在集群中进行声明操作的时候,需要等待每个节点都成功提交变更后才返回结果,想一想使用RabbitMQ作为RPC的时候得有多慢….). 取舍 内存节点可以获得更好的性能,而磁盘节点可以有效的保存元数据.那么,如何进行权衡呢? 先来看看,如果集群中只有一个磁盘节点,而它又恰好挂掉了,会发生什么. 首先,它仍然能正产工作(因为元数据可以在其余节点找到),其次,由于数据无法固化,因此无法再进行新的声明操作了(例如:创建队列、创建交换机、创建绑定、添加用户、修改权限、添加或者删除集群节点等等). 因此为了避免上述发生上述情况,在集群中至少要存在两个磁盘节点,这样当其中一个挂掉之后,另一个还能进行数据固化以保存元数据变更. 那,如果内存节点挂掉了,会发生什么… 实际上,上述表述有问题,内存节点还是会存储一些信息(集群中磁盘节点的位置)在磁盘上,这样当它挂掉并重启之后就可以从磁盘上读取到所有的磁盘节点的信息,并依次尝试进行连接与元数据同步了.很好理解的是,一旦磁盘节点全部挂掉,内存节点之间或者说与集群之间就没有强关系了,也就是说重启后无法正确加入集群. 实战 接下来,实际配置一个集群. 部署集群12345678910111213141516171819202122# /bin/bash# 配置一个简单的集群# 貌似在rabbitmq安装完成后,会默认启动一个实例,可以先关掉(不关掉的话,以下两个端口号都得变)# 注意,以下两条命令分别在两个不同的服务器上执行(在一台服务器上执行也可以,需配置不同的端口号),在/etc/hosts下需要配置另外一个的host# 启动第一个节点, 这个节点的hostname flynnon 在/etc/hosts文件中配置为当前IPRABBITMQ_NODENAME=rabbit@flynnon RABBITMQ_NODE_PORT=5672 sudo rabbitmq-server -detached# 启动第二个节点, 这个节点的hostname fly_bwg 在/etc/hosts文件中配置为当前IPRABBITMQ_NODENAME=rabbit@fly_bwg RABBITMQ_NODE_PORT=5672 sudo rabbitmq-server -detached# 停止rabbit@flynnon节点(这里使用 -n 指定在哪个节点上执行命令,不指定为默认节点)sudo rabbitmqctl -n rabbit@fly_bwg stop_app# 清空rabbit@flynnon节点中的所有元数据,以避免元数据冲突sudo rabbitmqctl -n rabbit@fly_bwg reset# 在fly_bwg这个机器上执行以下指令,将 rabbit@fly_bwg 加入集群(后面的参数是指集群中磁盘节点的列表.若将本节点置入,则本节点就成为了一个磁盘节点,否则本节点为内存节点)sudo rabbitmqctl -n rabbit@fly_bwg join_cluster rabbit@flynnon# 查看集群状态sudo rabbitmqctl -n rabbit@flynnon cluster_status 补充: 在正常执行以上命令时,出现了如下问题.. ![执行是遇到的问题1-cookie][1] 这个很容易看懂,还记得前一篇提到的Erlang的Cookie机制么?出错的原因就是两个节点的cookie的值不一样,只需要保证所有节点的.erlang.cookie文件(如果我们使用解压缩方式安装部署的rabbitmq，那么这个文件会在${home}目录下，也就是$home/.erlang.cookie;如果我们使用rpm等安装包方式进行安装的，那么这个文件会在/var/lib/rabbitmq目录下)中的内容相同就行了,貌似应该先修改cookie文件再重启(使用rabbitmqctl stop &amp;&amp; rabbitmq-server start). 注意,如果rabbitmqctl无法连接当前主机上的节点,则需要重启rabbitmq-server(因为,rabbitmqctl的cookie是改完之后的,而rabbitmq-server可能还是原来的配置). 移除节点 移除节点十分简单,只需要使用如下命令即可. 1234# 将某个节点移除出它所在的集群(此时此节点会通知集群自己要离开集群,集群会进行处理而不是认为节点异常)sudo rabbitmqctl -n rabbit@bwg_flynnon stop_appsudo rabbitmqctl -n rabbit@bwg_flynnon resetsudo rabbitmqctl -n rabbit@bwg_flynnon start_app 如果不使用以上命令进行移除操作的话,集群会认为节点出了故障,并等待其恢复(例如:要离开的节点是一个磁盘节点,那么这段时间内无法进行新的定义操作). 镜像队列 前面有提到过,RabbiMQ的队列只能存在于集群中的一个节点上,但是这样其实不能实现高可用.因此在2.6.0版本的时候,RabbitMQ团队开发了内建的双活冗余选项:镜像队列. 与普通队列类似,镜像队列的主拷贝仅仅存在于某一个节点(master节点)上,然而在其它节点上存在多个从队列(slave)拷贝,一旦主队列出现故障(节点挂掉,网络问题等等原因),最老的(存活时间最久的)从队列即被推举为新的主队列节点.也就是说通过冗余数据(队列)的方式达到了一定程度上的高可用. 这部分可以参考朱小厮的博客或者官方文档,讲的蛮好的.这本书貌似有点过时(以后再改正吧). 声明 镜像队列的声明方式与普通队列相比,仅仅是多了一个x-ha-policy参数. 12345678import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))channel = connection.channel()# 声明镜像队列, arguments参数是一些自定义的参数(Custom key/value arguments for the queue)arguments = &#123;'x-ha-policy': 'all'&#125;channel.queue_declare(queue='test_queue', durable=True, exclusive=False, auto_delete=False, arguments=arguments) x-ha-policy的值代表的是,从队列拷贝存在的节点位置. 设置为all,则此队列会在集群的所有节点上产生镜像队列,同时新增节点时,无需人工干预,自动添加拷贝. 但,一般无需太多拷贝队列存在,因此有时需要能够手动指定在哪些节点上增加镜像.这样当然也可以(RabbitMQ2.7以后),但就需要硬编码了,且在某个声明的节点找不到(挂掉或者被用集群中移除)时,声明会失败.尽量不要这样声明,通用性不强. 123456789101112import pikaconnection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))channel = connection.channel()# 声明镜像队列,指定要建立镜像队列的节点列表arguments = &#123; 'x-ha-policy': 'nodes', 'x-ha-policy-params': ['rabbit@fly_bwg', 'rabbit@flynnon'],&#125;channel.queue_declare(queue='test_queue', durable=True, exclusive=False, auto_delete=False, arguments=arguments) 消息同步 默认情况下,新增的拷贝节点只会包含从其存在之后从镜像队列发来的消息,RabbitMQ(2.7之前)不会将镜像队列中现存的内容与新增的拷贝节点进行同步处理.新增从拷贝自始至终不会知道旧消息的存在,旧消息全部被消费后,新增从拷贝会与现存队列状态相同. 但是,如果在旧消息被消费之前就将旧的节点移除的话,新的拷贝节点会被推举为新的主节点,这样,旧的消息就会丢失.因此,在删除旧的节点前,需要确保消息已经同步完成. 12# 列出所有从节点的pid, 并列出所有同步完成的pid, 当这两个列表完全相同时, 就可以安全移除旧节点了rabbitmqctl list_queues name pid slave_pids synchronised_slave_pids 工作机制 某种程度上,可以认为镜像队列拥有一个隐藏的fanout交换机,指示channel将消息分发到所有的队列从拷贝上. 当我们在镜像队列上使用发送方确认时,只有所有的主从队列都正确(注意是全部队列)收到消息后,才会返回成功.但是如果消息在路由到从拷贝之前,镜像队列的主拷贝发生了故障,那么,某个从拷贝会被推举为新的主拷贝,此时消息永远不会到达,就会返回失败. 事实上,由于以上机制,某个从节点挂掉的时候,附加在镜像队列上的所有消费者不会感知到(从技术上讲,它们实际上是附加在队列主拷贝上的,不会与从拷贝产生关联). 但,当托管主拷贝的节点挂掉的话,所有的消费者都需要重新附加并监听新的队列主拷贝.这时消费者有两种情况: 1. 正好是通过故障节点连接到集群.这种情况就很简单了,因为节点挂了,因此connection(TCP连接)也就没了,在消费者重新附加到集群中的某个节点时,会自动选取新的队列主拷贝; 2. 通过一个完好的节点连接到集群.这种情况下,RabbitMQ会发送一个消费者取消(consumer cancellation)通知,以告知它们不能再附加到原来的队列主拷贝了(一般AMQP客户端接到这个通知后会抛出一个异常供我们进行捕获),然后,消费者重新附加即可.但是当消费者客户端不支持消费者取消就没什么比较好的方法了(此时最好不要使用镜像队列). 那些因为主节点挂掉而产生的消费未确认消息,RabbitMQ会将它们重新入队(无法分辨没有确认和确认丢失的情况).]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《RabbitMQ实战》笔记(一)]]></title>
    <url>%2F2018%2F06%2F26-RabbitMQ_1.html</url>
    <content type="text"><![CDATA[前言 公司的一些异步任务是通过Django+RabbitMQ+Celery实现的,编写的时候感觉真的蛮简单的,刚开始了解它只是简单的看了下RabbitMQ的入门教程并实现了这些demo,通过这些我明白了如何使用RabbitMQ,但是一些细节并没有弄的很清楚,于是这段时间就看了下《RabbitMQ实战 高效部署分布式消息队列》这本书. 为了避免忘记….记一下笔记….. 天降奇兵(RabbitMQ简史) 这一章主要介绍了消息队列、AMQP、RabbitMQ的历史,并且介绍了如何安装RabbitMQ. 安装这一步可以参考RabbitMQ安装,当然我更倾向于使用docker来启动实例,这样我们就可以忽略一些安装时的细节,相应的会简单很多. 12345678910111213141516171819#! /bin/bash# Ubuntu下正常安装Erlang和RabbitMQ# 下载安装包# 这里注意下版本,我是在https://packages.erlang-solutions.com/erlang/#tabs-debian找的,在我使用的时候21.0有点问题wget http://packages.erlang-solutions.com/site/esl/esl-erlang/FLAVOUR_1_general/esl-erlang_20.1-1~ubuntu~xenial_amd64.deb -O erlang.deb &amp;&amp; sudo dpkg -i erlang.deb# 补全依赖,并再次安装apt-get -f -y install &amp;&amp; sudo dpkg -i erlang.deb# 添加RabbitMQ的源echo "deb https://dl.bintray.com/rabbitmq/debian xenial main" | sudo tee /etc/apt/sources.list.d/bintray.rabbitmq.list# 添加公钥wget -O- https://dl.bintray.com/rabbitmq/Keys/rabbitmq-release-signing-key.asc | apt-key add -# 更新仓库并进行安装apt update &amp;&amp; sudo apt install rabbitmq-server# 后续扫尾工作apt -y autoremove &amp;&amp; apt -y autoclean 12345678#! /bin/bash# 通过Docker启动RabbitMQ# 设置RabbitMQ文件的目录地址RABBITMQ_DIR='/home/flynnon/docker_volumes/rabbitmq'# 启动容器,并映射目录及开放端口号# 这里使用了 rabbitmq-management 的镜像,感觉这个插件还是很好用的.docker run -d -e RABBITMQ_NODENAME=rabbit --name rabbit -p 4369:4369 -p 5671:5671 -p 5672:5672 -p 15671:15671 -p 15672:15672 -p 25672:25672 -v $RABBITMQ_DIR:/var/lib/rabbitmq rabbitmq:3.6-management 理解消息通信 这一章介绍了消费者、生产者、代理、交换机、队列、绑定、虚拟主机、消息持久化的概念及实现方法,并介绍了一条消息从产生到被消费都发生了什么(也就是生命周期). 一些概念 先来写一些比较虚的东西,这种虚是指RabbitMQ提供的抽象.实际上,我们无需了解具体实现(Erlang代码),只需要了解这些抽象的概念就可以着手进行开发了. 角色划分 使用RabbitMQ(消息队列)时,有三种角色需要区分: 代理: 在使用消息队列的场景中,消息队列服务器可以看做代理. 生产者: 而生产者是产生消息并将消息发送到代理服务器的角色(A program that sends messages is a producer.). 消费者: 连接到代理服务器,并订阅相应的队列,在有新的消息到达时,接收并处理的角色(A consumer is a program that mostly waits to receive messages). 消息 在RabbitMQ中传输的是消息,消息包含有效负载(payload)与标签(label)两部分.其中有效荷载是指实际要传递的数据(可以是任意支持的格式),而标签则描述了有效荷载,RabbitMQ会根据标签来对消息进行分发. 消息路由过程中实际分发的只是payload.也就是说,消费者接收到的只是payload部分,这样可以实现一定程度上的解耦,即生产者和消费者互相并不知道彼此的存在,尤其是消费者并不知道消息是如何来的(如果发送者的信息很重要的话,将它放到payload部分也是可以的). 通信 实际上,对于生产者与消费者都是通过Connection与Channel与RabbitMQ服务器进行通信的. Connection实际上是一个TCP连接. 而Channel则是建立在真实的TCP连接(Connection)中的虚拟连接.所有AMQP命令都是通过Channel发送出去的. 为什么使用Channel? 对于操作系统来说,由于建立和关闭Connection(TCP连接)是有一定代价的.在生产者为多个线程时,如果只有Connection,那么为了发送消息就需要频繁的创建销毁Connection,这会极大的浪费系统资源,并且操作系统每秒能创建的TCP连接数是有上限的,这就会导致性能瓶颈. 但是RabbitMQ又得基于TCP,因此在TCP的基础上抽象出了Channel的概念,Channel可以认为是轻量级的连接,一个Connection可以创建多个Channel,并且各个Channel间互相隔离.在Connection上创建和销毁Channel的代价很低,也不会对操作系统造成太大影响(不是没影响). 对于Connection与Channel的关系,本书中有一个形象的比喻:Connection好比电缆,而Channel好比光纤束,一条电缆可以有多条光纤束,且各个光纤束可以独立的传输数据. 建议客户端线程之间不要共用Channel,至少要保证共用Channel的线程发送消息必须是串行的,但是建议尽量共用Connection. 消息存储 生产者将消息投递给RabbitMQ后,RabbitMQ还没有将消息发送给消费者时,消息被存放在Queue中(A queue is the name for a post box which lives inside RabbitMQ. Although messages flow through RabbitMQ and your applications, they can only be stored inside a queue. A queue is only bound by the host’s memory &amp; disk limits, it’s essentially a large message buffer.). 消费 消费者从队列中获取存储的消息,目前有两种方法: a. 使用AMQP的 channel.consume 命令订阅某个队列,此时channel被设置为接收模式,这样当队列中有消息且RabbitMQ认为消费者有能力进行消费时,就会将改消息分给消费者; b. 使用AMQP的 channel.get 命令获取某个队列中的一条消息.通过这样的主动获取方式,消费者可以得到队列中可用的下一条消息.大致上讲,这样的行为类似于订阅某个队列,从中取一个消息,然后取消订阅.因此在需要获取大量消息时,循环get会比consume性能差很多. 然后就是一些具体的细节: a. 消息到了一个没有消费者监听的队列之后,会发生什么事? 答案是,消息被放到该队列后,会堆积,直到有消费者监听该队列时,才会进行分发. b. 在多个消费者监听一个队列时,消息如何分发? 答案是,消息会被轮询分发(round-robin)给所有消费者,每条消息只会被发送给一个消费者. c. 消息到达一个不存在的队列时,会发生什么? 答案是,消息会被丢弃. 消费者确认机制 RabbitMQ会一直向消费者中投递消息么? 想一想就知道,不会.否则可能压垮消费者,并且会导致无效消费.事实上,RabbitMQ会根据消费者的状态来决定要不要向它投递消息. 那么,问题又来了,RabbitMQ如何确认消费者的状态呢? 答案是,由消费者主动告知(也是最符合直觉的方法).这句话的含义是:消费者在接收到一条消息后必须对此消息进行确认. 这里所指的确认包括以下两种: 确认成功: basic.ack命令 在订阅队列时,开启自动确认(设置auto_ack参数为true)后,RabbitMQ在将消息发送给消费者后自动认为消费者已进行了确认. 在收到某个消费者的确认之前,RabbitMQ不会向其投递更多消息.如果消费者在确认之前取消了对队列的订阅(或断开了连接),那么RabbitMQ会认为这条消息没有被消费.会将这条消息重新投递到别的消费者那里去. 拒绝: basic.reject命令(此命令在2.0.0之后才支持) 在接到拒绝的命令后,RabbitMQ会认为此消费者无法处理这条命令,然后根据此命令附带的requeue参数决定接下来的行为.当requeue参数被设置为true时,消息会被重新发送给下一个订阅者,否则,消息会被丢弃.扩展:死信队列. 也可以简单粗暴的通过断开连接的方式达到上述目的,此时RabbitMQ会将消息重新入队并发送给下一个消费者.但是这样与使用basic.reject命令相比性能消耗太大. 谁来分发 现在又有了一个新的问题.消费者将消息投递给RabbitMQ后,RabbitMQ按照什么规则将消息分发到Queue中?由谁来进行这个操作呢? 先来回答后一个问题,这里有几种方案,例如:消费者在进行消息投递时直接指定Queue;由各个Queue来对消息进行拉取(此种情况需要定义多久拉取一次,或者说如何知道有新消息的问题)等等.. 但是这两种方式都不是很好,由消费者直接指定Queue的话,使得消费者所发送的消息与Queue产生了强耦合(生产者明确知道了自己所发送的消息的用途),而事实上这些信息生产者并不需要关心.由Queue来进行拉取的话,拉取时间不好设置(太短的话性能不好,太长的话可能会导致消息传递有延时),拉取结束之后消息还存不存不好判断(有可能多个Queue都需要拉取某条消息). 事实上,RabbitMQ在消息到达与Queue之间设置了一个交换机(Exchange).这个也许与RabbitMQ产生的背景有关系,但是不得不说,个人感觉这是一个很好的实践.通过Exchange解耦了生产者和Queue,即:生产者只需要在消息中指定某个Exchange与此消息的规则(路由键Routing Key)即可,具体的转发操作则不用关心.而Queue只用接收从Exchange传过来的消息并投递消息给相应的Queue即可. 建立分发规则 在有了上述的概念后,就很容易理解绑定(Binding)的含义了. 绑定实际上就是建立Queue与Exchange之间的联系,也就是告诉RabbitMQ中的某个Exchange将符合某种条件(规则)的消息发送到某个Queue.通过绑定,生产者或消费者可以建立Exchange和Queue之间的多对多关系. 那么,绑定的过程中设置的规则是指什么? 这里的规则由Exchange类型和绑定键(Binding Key)两部分组成.下面分别介绍: 绑定键是由句点”.”分隔的字符串,被分隔的每一部分被称为一个单词.其中可以存在两种通配符”“与”#”，用于做模糊匹配，其中”“用于匹配一个单词，”#”用于匹配多个单词(可以是零个).例如: “payment.notify”, “payment.#”等等. 生产者发送消息时,需要指定发送给哪个Exchange,并需要指定本消息的路由键.可以简单的认为路由键是用来与绑定键进行匹配的. 那么,Exchange的类型是什么意思?分发规则跟类型有啥关系? 粗略的说,这里的类型实际上是指路由算法.即: 将Exchange分为多种类型,每种类型都实现了独特的路由算法(这部分可以在RabbitMQ的教程中看到,有详尽的代码示例).目前有以下四种(路由键的含义见后面): direct: 若消息中的路由键能匹配到某个队列的名称,就将消息投递到该队列.否则,丢弃. fanout: 消息会被发送到所有绑定到此Exchange的Queue中(广播),路由键会被忽略. topic: 若消息的路由键能够匹配到此Exchange上绑定的某些绑定建,则将消息分发到对应的Queue中. 这里的匹配可以是完全匹配,也可以是模糊匹配(使用通配符).绑定键中的通配符”#”,”.”只在此种情况下生效. headers: 若消息的headers中的键值对能匹配(可以定义设置部分匹配或者全部匹配)到某个绑定键,则将消息分发到对应队列.这个用的蛮少的,资料也比较少,可以参考RabbitMQ Header Exchange用法. 操作 了解完抽象之后,我们需要知道该如何进行开发.也就是,我们如何基于这个抽象实现我们的自定义功能. 声明队列 创建(声明)队列必须使用一个处于”传输模式”的channel.也就是说,生产者或消费者都可以声明队列. 可以使用queue.declare命令创建队列(注意:当消费者在channel上订阅了一个队列时,就无法再无法创建队列了).此命令会返回队列的名称.被创建的每一个队列被创建时都会被自动绑定到默认交换机(名称为””),并以队列名作为路由键(详见后面的绑定). 使用这个命令时可以设置如下几个参数: exclusive,代表私有,当设置此参数时,队列只能被当前应用消费.可用来限制队列的消费者数目. auto-delete,代表自动销毁,当设置此参数时,在最后一个消费者取消订阅此队列时,队列会被自动移除(当然,队列中的消息也就不存在了). name,代表队列的名称(唯一标识),当设置此参数时,队列会被命名.没有设置时,RabbitMQ会为队列随机生成一个名字. 既然,生产者和消费者都可以声明队列,那么就无法保证队列的声明顺序,重复创建队列会引发问题么?事实上是会的.当多次声明的队列的属性不同时,就会产生错误. 声明交换机 声明交换机与声明队列的规则基本相同. 代码示例 我们使用Python语言来操作RabbitMQ.pika是RabbitMQ官方的连接库. 12345678910111213141516171819202122import pika# 获取Connection,pika封装了多种Connection,这里选择使用比较简单的BlockingConnection来写示例connection = pika.BlockingConnection(pika.ConnectionParameters('localhost'))# 从Connection获取Channelchannel = connection.channel()# 使用channel创建队列channel.queue_declare(queue='test_queue', durable=True, exclusive=False, auto_delete=False,)# 使用channel声明exchangechannel.exchange_declare(exchange='test_exchange', exchange_type='topic', auto_delete=False, durable=True)# 建立绑定关系channel.queue_bind('test_queue', 'test', routing_key='test.#',)# 发送消息# properties中可以放置一些设置,例如: delivery_mode=2时表示消息需要持久化,delivery_mode=1时,代表不用持久化..channel.basic_publish(exchange='test_exchange', routing_key='test.test.test', body='Hello World!')# 设置回调函数,用于在有消息到达时进行处理def callback(ch, method, properties, body): print(" [x] Received %r" % body)# 开始监听队列,此方法为阻塞方法channel.basic_consume(callback, queue='test_queue', no_ack=False, exclusive=False,) 扩展虚拟主机vhost 可能是因为起源于电信行业,因此租户比较多,而各个租户之间的数据肯定是不能串的. 当然,多起几个示例肯定是可以满足需要的,但是一点也不经济.因此RabbitMQ提供了一种类似命名空间的机制:vhost.vhost之于RabbitMQ相当于虚拟机之于物理机.初始时只存在一个vhost: “/“.各个vhost之间是绝对隔离的,这个特性也使得vhost可以很方便的迁移到别的RabbitMQ实例中而不用担心对其余vhost造成影响. vhost在建立连接是必须指定,缺省为”/“. 我们如何管理vhost呢?由于建立连接是要指定vhost,因此肯定不是在channel或者connection中管理.此时 rabbitmqctl 就登场了.rabbitmqctl是RabbitMQ自带的命令行管理工具.与vhost相关的有以下几个命令: 创建: rabbitmqctl add_vhost [vhost_name] 例如: rabbitmqctl add_vhost flynnon_host 删除: rabbitmqctl delete_vhost [vhost_name] 例如: rabbitmqctl delete_vhost flynnon_host 列出vhost列表: rabbitmqctl list_vhosts 持久化 默认情况下,RabbitMQ中的一切(消息、队列、交换机)都不是持久化的.也就是说,一旦重启,一切都会丢失. 对我们而言,这显然是不可接受的,那么,如何进行持久化? 队列和交换机的持久化比较简单,只需要在声明时设置其durable属性为true就可以了(见上方demo).这样,当RabbitMQ重启时,会自动创建队列与交换机. 消息的持久化: 需要在发送时指定消息的投递模式为2,以将消息标记为持久化. 当然,为了使得消息持久化更加安全,因此需要: 1. 将消息标记为持久化(投递模式设置为2); 2. 发送到持久化的交换机; 3. 到达持久化的队列. 12345678import pika# 队列,交换机持久化channel.queue_declare(queue='test_queue', durable=True, exclusive=False, auto_delete=False,)channel.exchange_declare(exchange='test_exchange', exchange_type='topic', auto_delete=False, durable=True)# 消息持久化channel.basic_publish(exchange='test_exchange', routing_key='test.test.test', body='Hello World!', properties=&#123;'delivery_mode': 2&#125;) 任何事情都是有代价的,如果没有代价,那RabbitMQ就直接默认开启持久化了… 这种代价也是可以想象的,因为一般持久化都需要把消息写到硬盘里,而磁盘读写比内存读写慢很多,也就是说:消息持久化会导致性能急速降低. 消息持久化机制: 当一个持久化消息到达一个持久化交换机时,RabbitMQ会将它写入一个持久化日志文件,并在写入成功后才发送响应(被路由到非持久化队列的消息,对应的记录会被自动删除),在消息被消费后,这条记录才会被标记删除. 消息确认 使用这种模型还有一个需要处理的问题,即: 生产者如何确定消息已经成功到达RabbitMQ呢?如果没有到达,在什么情况下进行重试? 有以下两种方法可以达到这个目的: 第一种方法是事务. 生产者可以在发送消息时开启事务,然后在消息全部发送完成后进行事务提交,如果RabbitMQ接收消息成功,则流程会正常走下去,否则RabbitMQ会停止执行这一系列的任务.同样,在产生错误时生产者也可以手动进行事务回滚,这样RabbitMQ会像没有收到这些消息一样工作. 第二种方法是发送方确认. 这种情况下,生产者需要将channel设置成Confirm模式(这个模式不可取消),然后该channel发送的所有消息都会被分配一个唯一ID号.然后当消息成功到达Queue时,RabbitMQ会发送一个确认(包含了唯一ID)给生产者,当RabbitMQ发生了内部错误导致消息丢失时,也会发送一个nack消息(未确认)给生产者. 由于channel只能被单线程使用(不是线程安全的),因此可以确定,一条channel上的消息时连续的.基于这个前提,RabbitMQ实现了简单的消息ID生成方式.即:每条channel上的第一条消息的ID为1,以后的消息ID逐渐递增.这样RabbitMQ就无需在每次消息发送时返回消息ID了(由生产者自己进行记录即可). 生产者在接收到这个消息后就可以根据情况进行特殊处理了(比如消息重发等等).由于回调对于发送方来说可以是异步的(设置回调函数接收),因此效率影响不大. 两种方法各有什么优缺点呢?在需要这个功能时,我们该如何选择呢?下面列出两种方法的一些差异. 通用性: 事务&gt;发送方确认. 事务是AMQP标准中的协议,而发送方确认机制则是RabbitMQ自己实现的.且发送方确认机制是在2.3.1才开始支持的,因此一些历史版本无法使用(感觉对于今天来说,可以忽略…). 性能: 由于事务支持回滚,因此需要在一段时间内保存状态,而发送方确认不需要,因此但是事务相对来说比较重量级且性能低下(会降低2-10倍的吞吐量).且事务会导致同步,而发送方确认为异步,因此可以认为发送方确认对于生产者影响很小. 1234567891011121314151617181920212223242526# RabbitMQ事务# 开启事务channel.tx_select()try: # 发送消息 channel.basic_publish(exchange='test_exchange', routing_key='test.test.test', body='Hello World!') # 逻辑处理 do_something() # 提交事务 channel.tx_commit()except Exception as e: print(e) # 手动回滚 channel.tx_rollback()&#125;# RabbitMQ发送方确认# 开启确认模式.由于Connection为BlockingConnection,因此此处无需设置回调函数(消息发布时同步返回True/False)channel.confirm_delivery()# 增加成功时的回调函数channel.add_on_return_callback(success_call_back)# 增加失败时的回调函数channel.add_on_cancel_callback(fail_call_back)# 发布消息,并得到消息处理成功或失败的标志success_flag = channel.basic_publish(body='test', exchange='test_exchange', routing_key='test.test.test',) 服务器管理 RabbitMQ是使用Erlang编写的,因此有一些很有趣的特征.这里会介绍与之相关的一些知识点与管理方法. 管理命令 Erlang的虚拟机类似Java的虚拟机,而一个节点则是虚拟机的一个实例.一个节点上可以运行多个Erlang应用程序,也就是可以在一个节点上启动多个RabbitMQ服务. 一般我们可以使用RabbitMQ自带的rabbitmqctl工具与RabbitMQ进行通信并进行管理.下面是服务器管理相关的一些命令: 启动rabbitmq服务: rabbitmq-server -detachd(以守护进程的方式在后台运行) 停止整个节点: rabbitmqctl stop -n rabbit@[hostname] 停止RabbitMQ实例: rabbitmqctl stop_app 配置文件 RabbitMQ的配置文件可以在启动时配置 CONFIG_FILE 环境变量指定.缺省情况下,配置文件为 /etc/rabbitmq/rabbitmq.config. 它的配置格式是原始的Erlang数据结构,示例如下: 12345% 大概含义是: []之中包含多个配置(用&#123;&#125;指定)[ &#123;mnesia, [&#123;dump_log_write_threshold, 1000&#125;]&#125;, &#123;rabbit, [&#123;sss:sss&#125;]&#125;] 上面的mnesia项是Erlang内建的非SQL型数据库.RabbitMQ使用它存储Queue,Exchange,Binding的元数据. Mnesia会将RabbitMQ的元数据写入到一个仅可增加的日志文件中,以保证其完整性.然后再定期将信息从日志文件转存到真实的Mnesia数据文件中. 目前本人已知的,常用的配置项如下: ；这里是为了调整表格首列的宽度 table th:first-of-type { width: 210px; } 可配置项名称 类型 含义 默认值 所属应用 dump_log_write_threshold 整型 转储的频度(超过多少行才可能进行转存). 100 Mnesia tcp_listeners {“ip”: port }数组 RabbitMQ应该监听的非SSL加密通信的IP和端口 [{“0.0.0.0”: 5672}, ] RabbitMQ ssl_listeners {“ip”: port }数组 RabbitMQ应该监听的SSL加密通信的IP和端口 空 RabbitMQ ssl_options {“key”: value }数组 SSL有关的选项(cacertfile-CA证书文件, certfile-服务器CA证书文件, keyfile-服务器密钥文件, fail_if_no_peer_cert-客户端是否需要安装有效证书True/False) 空 RabbitMQ vm_memory_high_watermark 十进制百分数 控制RabbitMQ允许消耗的安装内存百分比 0.4(代表40%) RabbitMQ msg_store_file_size_limit 整形(字节数) 控制RabbitMQ垃圾收集存储内容之前,消息存储数据库的最大大小 16777216(16M) RabbitMQ queue_index_max_journal_entries 整形 转储到消息存储数据库并提交之前,消息存储日志中的最大条目数 262144 RabbitMQ hipe_compile 布尔类型 是否开启Erlang HiPE编译选项(JIT技术),可以提高性能 false Erlang 权限控制 RabbitMQ的权限控制是基于用户的,各个vhost的权限互相独立,也就是:针对一个或多个vhost,用户可以拥有不同的权限. 很自然的,权限也必须使用rabbitmqctl工具来进行管理(因为建立连接是需要指定用户,一般而言用户没有给别人权限的能力). 用户管理 RabbitMQ存在用户,其初始用户用户名为guest,密码也为guest. 用户是全局唯一的,且创建时至少需要指定一个vhost(RabbitMQ的权限是以vhost为单位的). 123456789101112# 创建用户rabbitmqctl add_user username password# 删除用户# 注意: 删除用户时,所有引用了该用户的权限控制条目都会被一并删除,且没有警告!rabbitmqctl delete_user username# 列出所有用户rabbitmqctl list_users# 修改用户密码rabbitmqctl change_password username new_password 权限 从1.6.0开始,RabbitMQ实现了一套访问控制列表(ACL)风格的权限系统.针对每一个vhost,权限分为读、写、配置三种,可以分开授予用户. 三种权限的差别如下: 读 – 有关消费消息的任何操作,包括清除队列中的消息(需要先绑定成功). 写 – 发布消息(也需要先绑定成功). 配置 – 队列和交换机的创建和删除. 常用命令与权限的映射关系表如下: AMQP命令 配置权限 写权限 读权限 exchange.declare exchange - - exchange.delete exchange - - queue.declare queue - - queue.delete queue - - queue.bind - queue exchange basic.publish - exchange - basic.get - - queue basic.consume - - queue basic.purge - - queue 以第一条为例,含义为: 用户想执行exchange.declare命令,需要在exchange上具有配置权限. 权限控制条目 每一条访问控制条目(规则)都由四部分组成: 谁(用户)在哪里(vhost)的那些部分(权限范围,交换机/队列)具有什么权限(读、写、配置权限的组合). 访问控制条目无法跨越vhost,也就是说:如果想让用户在多个vhost上具有权限,需要设置多条控制条目(规则). 12345678910111213# 为用户分配权限# 需要更改某用户的权限时,直接重新分配即可(也只能重新分配..)# 最后面的三个权限模式是三个正则表达式. 例:".*" 代表所有权限, "" 代表无权限, "xx.*"代表以xx开头的队列或者交换机上有权限rabbitmqctl set_permissions -p &#123;vhost_name&#125; username &#123;conf_permission&#125; &#123;write_permission&#125; &#123;read_permission&#125;# 查看权限分配情况# 查看某vhost上的权限分配rabbitmqctl list_permissions -p &#123;vhost_name&#125;# 查看某用户在所有vhost上的权限rabbitmqctl list_user_permissions &#123;username&#125;# 清除某用户在某vhost上的所有权限rabbitmqctl clear_permissions -p &#123;vhost_name&#125; &#123;username&#125; 状态检查 我们该如何查看RabbitMQ的运行状态呢? 查看基本信息1234# 列出某vhost上的queue的信息# 中间的状态貌似是指queue在集群中的信息# 这里的 queueinfoitem 表示想展示的项目列表,有效值包括name, druable, auto_delete等等,用到时现查即可.缺省状态下,此命令展示 队列名及其上的消息数list_queues [-p &lt;vhost&gt;] [--offline|--online|--local] [&lt;queueinfoitem&gt; ...] 123# 列出某vhost上的exchange的信息# 这里的 exchangeinfoitem 含义同上,有效值包括 name, type, durable, auto_delete, internal, arguments, policyrabbitmqctl list_exchanges [-p &lt;vhost&gt;] [&lt;exchangeinfoitem&gt; ...] 123# 列出某vhost上的绑定信息# 这里的 bindinginfoitem 含义同上,有效值包括 source_name, source_kind, destination_name, destination_kind, routing_key, argumentsrabbitmqctl list_bindings [-p &lt;vhost&gt;] [&lt;bindinginfoitem&gt; ...] 日志信息 RabbitMQ的日志文件有如下两个: RABBITMQ_NODENAME.log RabbitMQ运行相关日志. 可以通过它得到RabitMQ的运行信息. RABBITMQ_NODENAME-sasl.log Erlang相关日志. 可以通过它查看Erlang的崩溃报告. 另外,RabbitMQ会将运行相关日志信息发布到 amq.rabbitmq.log这个交换机上,并以日志等级作为路由键(error, warning, info),因此我们自己定义好队列与绑定后,就可以通过消费者监听RabbitMQ的运行信息了. 常见问题rabbitmqctl 有时,RabbitMQ运行的好好的,但是我们在使用rabbitmqctl命令的时候就是会出现badrpc或者nodedown问题.这是为什么? 先来看看rabbitmqctl的工作原理.rabbitmqctl会启动一个Erlang节点,并使用Erlang的分布式系统尝试连接RabbitMQ节点.达成这个步骤需要两个条件:合适的Erlang Cookie和合适的节点名称. 首先来看看Erlang Coolie: 为了能使用rabbitmqctl连接RabbitMQ节点,需要共享相同的cookie.因此,碰到上述问题时,看看当前用户的Erlang Cookie与RabbitMQ的Erlang Cookie是否相同. Erlang节点之间通过交换作为秘钥的Erlang Cookie来进行认证(由于连接到某节点时就可以执行命令,因此需要确保连接者可信).而Erlang将令牌存储在用户主目录下的.erlang.cookie文件中. 再来看看节点名: 在启动Erlang节点时,可以指定一个节点名称(name或者sname之一). 如果两边的节点名不同,那么rabbitmqctl也无法正常连接到RabbitMQ服务器. Mnesia 有时,Mnesia启动老是失败,这是什么原因? 常见的原因如下两个: 1. RabbitMQ没有MNESIA_BASE(这是个环境变量)文件夹的写权限; 2. 主机名更改了或者服务器运行在集群模式下且启动时无法连接到其它节点. Mnesia会基于Erlang节点名与当前机器的主机名创建数据库schema,如果主机名更改了,它就无法加载旧的schema.同理,使用Erlang sname更改节点名,也会产生这个问题. 如果我们更改了Mnesia建立的文件夹的名称,Mnesia会重新创建新的schema文件夹并加载.]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>RabbitMQ</tag>
        <tag>消息队列</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[红包算法]]></title>
    <url>%2F2018%2F06%2F03-%E7%BA%A2%E5%8C%85%E7%AE%97%E6%B3%95.html</url>
    <content type="text"><![CDATA[前因 最近Flynnon的舍友来北京找工作,因此几个同学一起聚了下,聊的聊的就聊到了他的面试经历,其中有一道算法题,他印象比较深刻,正好大家都是程序员,于是进行了讨论,在这里做个记录. 题目 仿照微信红包设计一个红包分配算法,要求: 1. 抽奖公平; 2. 手气最好的人抽到的红包金额不大于手气最差的人的10倍. 初始思路 在看到这道题目时,首先意识到要用随机数生成算法以保证相对公平.然后对随机的范围进行限制即可. 简单概括为: 土豪分田地.首先确立一个土豪,它的金额为规则允许的最大值,其余人则相等.那么,分红包的过程就可以简单的看成从土豪手中抢钱的过程. 代码如下: 123456789101112131415161718192021222324252627282930313233343536# coding=utf-8from __future__ import print_functionimport random# 总金额total = 100# 红包数目count = 10# 最大倍数max_multiple = 10# 每个人抽到的红包的列表money_list = []# 平民的红包金额min_value = total * 1.0 / (max_multiple + count - 1)# 土豪的红包金额max_value = min_value * max_multiplefor i in range(count): # 当只有最后一个红包时,余额就是土豪的钱 if count == 1: money_list.append(total) break # 随机数的范围是 (min_value, max_value), 因为能抢的部分只是土豪比平民多的部分 the_value = random.random() * (max_value - min_value) + min_value # 总金额变少 total = total - the_value # 红包总数减一 count -= 1 # 重新求出地主金额 max_value = max_value - (the_value - min_value) money_list.append(the_value)print(money_list) 变化思路 上述版本写完后,总感觉有些复杂,因此重新理了一下思路,发现上面想的有些复杂. 这种思路可以简单的概括成 均富贵,看运气.大家初始拿到一笔相等的钱,然后凭运气从剩余的奖池里再拿一部分. 代码如下: 1234567891011121314151617181920212223242526272829303132333435363738# coding=utf-8from __future__ import print_functionimport random# 总金额total = 100# 红包数目count = 10# 最大倍数max_multiple = 10# 每个人抽到的红包的列表money_list = []# 最小红包金额min_value = total * 1.0 / (max_multiple + count - 1)# 每个用户都得到最小红包数之后的剩余金额,即公共部分remain_value = total - min_value * countfor i in range(count): # 当只有最后一个红包时,余额就是红包金额 if count == 1: money_list.append(total) break # 随机数的范围是 (0, remain_value), 即公共部分任取 tmp_value = random.random() * remain_value the_value = tmp_value + min_value # 总金额变少 total = total - the_value # 红包总数减一 count -= 1 # 重新求出剩余部分的金额数 remain_value -= tmp_value money_list.append(the_value)print(money_list) 总结 有的时候换种思路,事情就会好做很多. 另外就是Flynnon的算法比起刚毕业的时候真是差的越来越多了….要找个时间训练一下了…. 如果你有更加优秀的方法,可以在评论里留言,大家一起讨论(如果我能看见的话)…]]></content>
      <tags>
        <tag>杂记</tag>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[博客升级]]></title>
    <url>%2F2018%2F05%2F27-%E5%8D%9A%E5%AE%A2%E5%8D%87%E7%BA%A7.html</url>
    <content type="text"><![CDATA[前言 在努力工作混了一段时间后, 某天突然发现我服务器的IP被墙了, 于是更换了一下服务器, 并顺带升级了一下HTTPS. HTTPS证书获取 这一步是很简单的,直接从阿里云(万网)购买了心仪的域名 www.flynnon.com. 配置域名解析 因为是从阿里云购买的域名,因此顺理成章的配置了域名解析(免费版),这里很简单的配置了一下,大概就是将域名本身指向我购买的服务器的IP地址. 由于Flynnon的主机是从搬瓦工购买的,因此无法备案(当然也不需要备案).但是没有备案总感觉不保险,因此专门配置了CNAME类型的解析规则将blog.flynnon.com这个域名指向我的Github Page的地址了…. 注意: 这一步的时候,需要在source文件夹下创建一个CNAME文件,并将你配置的域名写入其中(比如我就写了blog.flynnon.com),否则Github Page会认为从该URL来的访问不合法. 折腾 在进行完上面几步后,就可以通过blog.flynnon.com来访问Flynnon的博客了,但Flynnon还想用自己购买的云主机来发布博客.因此又在这个基础上进行了一些折腾. Nginx 首先,需要一个服务器软件,这里Flynnon选择了Nginx.原因是它既是一个Web服务器(作为启动博客的服务器程序),也可以做反向代理(Flynnon想用它来为其余的服务分配一个好记的URL).当然,更重要的是,Flynnon想学习一下Nginx的使用…. Nginx使用apt包管理工具进行安装十分方便. 123# nginx的安装...写在这里都有点丢人...sudo apt updatesudo apt install nginx 配置也十分简单.下面是我最终的配置. 12345678910111213141516171819202122232425262728293031# /etc/nginx/sites-enabled/defaultupstream jenkins &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; # 设置监听的端口号 server_name www.flynnon.com; # 设置默认的hexo文件的目录位置 root /var/www/hexo; # 设置hexo的index文件名 index index.html index.htm; # 当找不到url对应的文件时返回404 location / &#123; try_files $uri $uri/ =404; &#125; # 这个是访问jenkins的设置,然后就可以通过 www.flynnon.com/jenkins 来访问jenkins了 location /jenkins &#123; proxy_pass http://jenkins; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Request-Url $request_uri; &#125;&#125; Jenkins 然后需要考虑的是,博客内容如何更新到服务器上.当然…每次更新博客的时候手动从Github上下载也不是不可以(但是太low了)…考虑了一下之后选择了使用Jenkins来进行自动构建. 安装及使用 下面记录一下Jenkins的配置过程. 123456789# Jenkins是基于Java的,因此使用前需要先安装Java.sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer# 我们按照Jenkins官网的介绍(https://jenkins.io/doc/pipeline/tour/getting-started/)使用即可,它的war包自带Jetty服务器wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war# 然后就可以直接运行了(jenkins.war中自带了jetty服务器), 使用--httpPort指定它监听的端口，安全考虑也只绑定了localhost.java -jar jenkins.war --httpPort=8080 --httpListenAddress=127.0.0.1 运行完以上两步后,通过浏览器访问 www.flynnon.com/jenkins 进行配置即可.这里网上的教程很多,就不一步步展示了. 接下来比较重要的是配置Hooks来同步代码,这里有两种思路,一种是直接从Github Page所在的项目中同步,直接就可以访问.另一种是从存放Hexo博客源码的项目同步代码,然后使用 hexo -g 生成HTML文件.这两种方式都可以.就不细写了..需要注意的是文件需要放置到nginx配置的目录中. 补充:实际使用时发现,jenkins默认的登录页面是 ip:port/login?from=..,也就是说访问 www.flynnon.com/jenkins 时会自动跳转到 www.flynnon.com/login?from=%2Fjenkins...这样肯定是不行的,查了半天之后还是没解决,后来通过请教同事(师傅)发现了[参数介绍](https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins).使用 –prefix 可以解决这个问题. Webhooks配置 为了实现自动发布,需要配置hooks,在Jenkins这边需要安装对应的插件,并且在博客任务中进行接收自动发布的勾选.这些资料网上很多,就不详细记录了. 代码管理方面.因为github的私有仓库很贵,因此Flynnon使用了bitbucket来进行博客源码的存放,为了实现自动发布,在github/bitbucket上进行了jenkins hooks的配置.一定要注意回调地址,千万不要写错(妈蛋…).它们都是HTTP协议的URI,但是bitbucket的hooks的url为: {jenkins_url}/bitbucket-hook/, 而github的url为 {jenkins_url}/github-webhook/. 一定不要想当然的复制!!! Execute Shell 在拿到源码后,需要进行额外的一些处理,在Jenkins中是在增加的构建步骤中处理,因为Flynnon对于shell更加熟悉,因此选择了增加Execute Shell. 如果在同步方式选择了同步生成代码的话,这一步就很简单了,配置如下: 123cd $&#123;WORKSPACE&#125;rm -rf /var/www/hexo/*cp -r ./* /var/www/hexo/ 如果选择了同步源码,就需要安装npm,然后进行生成.为了简单点,我使用了docker充当环境,下面有详细介绍. supervisor 其实进行完以上步骤之后就可以用了,但是每次都得手动/半自动(执行写好的shell脚本)对jenkins进行启动,并且挂了也没法自动重启.因此针对这个需求又使用了supervisor来进行管理. 1234567891011121314151617# 安装supervisorsudo apt install supervisor# supervisor的配置文件位于此目录下cd /etc/supervisor/# 这里图简单,直接修改了主配置文件.更好的做法是在conf.d目录下新建一个自定义的配置文件vim supervisord.conf# 下面是一些常用命令. 其中后面四个命令均可以省略 -c 参数# supervisord -c supervisor.conf 通过配置文件启动supervisor# supervisorctl -c supervisor.conf status 查看状态# supervisorctl -c supervisor.conf start [all]|[x] 启动所有/指定的程序进程# supervisorctl -c supervisor.conf stop [all]|[x] 关闭所有/指定的程序进程# supervisorctl -c supervisor.conf reload 重新载入配置文件# 这里我们只需要重新载入配置文件即可sudo supervisorctl reload 我的supervisor配置如下: 1234567[program:jenkins]command=java -jar /opt/jenkins.war --httpPort=8080 --prefix=/jenkinsuser=flynnonautostart=trueautorestart=truestartsecs=30startretries=8 docker 如果在同步方式选择了同步源码的话,还需要安装npm,但是作为一个后端开发,本人对于npm并不是很熟悉,而且怕被弄乱系统,因此选择了使用docker来启动一个npm的容器,这样就简单很多(反正它也只是用来安装hexo和生成博客的). Dockerfile如下: 123456789FROM node:10MAINTAINER tangfei_cn@foxmail.comWORKDIR /appCOPY ./package.json .# 国内的服务器,可以加上 npm config set registry https://registry.npm.taobao.org 设置源RUN npm install -g hexo-cli &amp;&amp; npm install -g &amp;&amp; npm install hexo --save 然后只需要在博客源码所在的页面执行下面一条语句即可.可以进行的优化有:使用alpine-node进行容器的体积优化.当然也可以直接换个思路…. 123# 这里的主要思路是将docker作为npm环境,然后将博客目录映射到容器中的对应目录进行构建.# 将生成的html文件所在的目录保存在本机上提供给nginx进行发布.docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generate 最终,我的Jenkins Shell中的配置如下: 123456789# 这里使用了jenkins自带的一些环境变量,避免硬编码cd $&#123;WORKSPACE&#125;docker build -t hexo:0.1 ./docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generaterm -rf /var/www/hexo/*cp -r ./public/* /var/www/hexo/# 为了解决权限问题...chmod o+r /var/www/hexo 在我的预想中,这个任务应该能正常运行,但是又遇到了权限问题…在将文件拷贝到 /var/www/hexo/ 下后,nginx无法读取该目录下的文件,导致502了…因此将supervisor中jenkins程序的user改成了root,并在Jenkins Shell的最后加了一句修改文件夹权限的命令… Update: 无需以root启动jenkins,只需修改结果文件的目录权限即可 总结 这一步之后,博客就搭建完成了,目前很符合我的需求,虽然不完美,但是已经没有了改动的想法. 如果你在仿照这篇博客搭建自己的博客时遇到了什么问题,或者觉得哪里不满足需求,可以联系我~]]></content>
      <tags>
        <tag>杂记, HTTPS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[改造博客记]]></title>
    <url>%2F2018%2F05%2F27-%E6%94%B9%E9%80%A0%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[前言 在写了一段时间的博客后,感觉 Github Page 默认的地址有些不好记,因此产生了使用自己域名的想法.下面是实际操作过程中的一些记录. 域名购买 这一步是很简单的,直接从阿里云(万网)购买了心仪的域名 www.flynnon.com. 配置域名解析 因为是从阿里云购买的域名,因此顺理成章的配置了域名解析(免费版),这里很简单的配置了一下,大概就是将域名本身指向我购买的服务器的IP地址. 由于Flynnon的主机是从搬瓦工购买的,因此无法备案(当然也不需要备案).但是没有备案总感觉不保险,因此专门配置了CNAME类型的解析规则将blog.flynnon.com这个域名指向我的Github Page的地址了…. 注意: 这一步的时候,需要在source文件夹下创建一个CNAME文件,并将你配置的域名写入其中(比如我就写了blog.flynnon.com),否则Github Page会认为从该URL来的访问不合法. 折腾 在进行完上面几步后,就可以通过blog.flynnon.com来访问Flynnon的博客了,但Flynnon还想用自己购买的云主机来发布博客.因此又在这个基础上进行了一些折腾. Nginx 首先,需要一个服务器软件,这里Flynnon选择了Nginx.原因是它既是一个Web服务器(作为启动博客的服务器程序),也可以做反向代理(Flynnon想用它来为其余的服务分配一个好记的URL).当然,更重要的是,Flynnon想学习一下Nginx的使用…. Nginx使用apt包管理工具进行安装十分方便. 123# nginx的安装...写在这里都有点丢人...sudo apt updatesudo apt install nginx 配置也十分简单.下面是我最终的配置. 12345678910111213141516171819202122232425262728293031# /etc/nginx/sites-enabled/defaultupstream jenkins &#123; server 127.0.0.1:8080;&#125;server &#123; listen 80; # 设置监听的端口号 server_name www.flynnon.com; # 设置默认的hexo文件的目录位置 root /var/www/hexo; # 设置hexo的index文件名 index index.html index.htm; # 当找不到url对应的文件时返回404 location / &#123; try_files $uri $uri/ =404; &#125; # 这个是访问jenkins的设置,然后就可以通过 www.flynnon.com/jenkins 来访问jenkins了 location /jenkins &#123; proxy_pass http://jenkins; proxy_set_header X-real-ip $remote_addr; proxy_set_header Host $host:$server_port; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_set_header Request-Url $request_uri; &#125;&#125; Jenkins 然后需要考虑的是,博客内容如何更新到服务器上.当然…每次更新博客的时候手动从Github上下载也不是不可以(但是太low了)…考虑了一下之后选择了使用Jenkins来进行自动构建. 安装及使用 下面记录一下Jenkins的配置过程. 123456789# Jenkins是基于Java的,因此使用前需要先安装Java.sudo add-apt-repository ppa:webupd8team/javasudo apt updatesudo apt install oracle-java8-installer# 我们按照Jenkins官网的介绍(https://jenkins.io/doc/pipeline/tour/getting-started/)使用即可,它的war包自带Jetty服务器wget http://mirrors.jenkins.io/war-stable/latest/jenkins.war# 然后就可以直接运行了(jenkins.war中自带了jetty服务器), 使用--httpPort指定它监听的端口，安全考虑也只绑定了localhost.java -jar jenkins.war --httpPort=8080 --httpListenAddress=127.0.0.1 运行完以上两步后,通过浏览器访问 www.flynnon.com/jenkins 进行配置即可.这里网上的教程很多,就不一步步展示了. 接下来比较重要的是配置Hooks来同步代码,这里有两种思路,一种是直接从Github Page所在的项目中同步,直接就可以访问.另一种是从存放Hexo博客源码的项目同步代码,然后使用 hexo -g 生成HTML文件.这两种方式都可以.就不细写了..需要注意的是文件需要放置到nginx配置的目录中. 补充:实际使用时发现,jenkins默认的登录页面是 ip:port/login?from=..,也就是说访问 www.flynnon.com/jenkins 时会自动跳转到 www.flynnon.com/login?from=%2Fjenkins...这样肯定是不行的,查了半天之后还是没解决,后来通过请教同事(师傅)发现了[参数介绍](https://wiki.jenkins.io/display/JENKINS/Starting+and+Accessing+Jenkins).使用 –prefix 可以解决这个问题. Webhooks配置 为了实现自动发布,需要配置hooks,在Jenkins这边需要安装对应的插件,并且在博客任务中进行接收自动发布的勾选.这些资料网上很多,就不详细记录了. 代码管理方面.因为github的私有仓库很贵,因此Flynnon使用了bitbucket来进行博客源码的存放,为了实现自动发布,在github/bitbucket上进行了jenkins hooks的配置.一定要注意回调地址,千万不要写错(妈蛋…).它们都是HTTP协议的URI,但是bitbucket的hooks的url为: {jenkins_url}/bitbucket-hook/, 而github的url为 {jenkins_url}/github-webhook/. 一定不要想当然的复制!!! Execute Shell 在拿到源码后,需要进行额外的一些处理,在Jenkins中是在增加的构建步骤中处理,因为Flynnon对于shell更加熟悉,因此选择了增加Execute Shell. 如果在同步方式选择了同步生成代码的话,这一步就很简单了,配置如下: 123cd $&#123;WORKSPACE&#125;rm -rf /var/www/hexo/*cp -r ./* /var/www/hexo/ 如果选择了同步源码,就需要安装npm,然后进行生成.为了简单点,我使用了docker充当环境,下面有详细介绍. supervisor 其实进行完以上步骤之后就可以用了,但是每次都得手动/半自动(执行写好的shell脚本)对jenkins进行启动,并且挂了也没法自动重启.因此针对这个需求又使用了supervisor来进行管理. 1234567891011121314151617# 安装supervisorsudo apt install supervisor# supervisor的配置文件位于此目录下cd /etc/supervisor/# 这里图简单,直接修改了主配置文件.更好的做法是在conf.d目录下新建一个自定义的配置文件vim supervisord.conf# 下面是一些常用命令. 其中后面四个命令均可以省略 -c 参数# supervisord -c supervisor.conf 通过配置文件启动supervisor# supervisorctl -c supervisor.conf status 查看状态# supervisorctl -c supervisor.conf start [all]|[x] 启动所有/指定的程序进程# supervisorctl -c supervisor.conf stop [all]|[x] 关闭所有/指定的程序进程# supervisorctl -c supervisor.conf reload 重新载入配置文件# 这里我们只需要重新载入配置文件即可sudo supervisorctl reload 我的supervisor配置如下: 1234567[program:jenkins]command=java -jar /opt/jenkins.war --httpPort=8080 --prefix=/jenkinsuser=flynnonautostart=trueautorestart=truestartsecs=30startretries=8 docker 如果在同步方式选择了同步源码的话,还需要安装npm,但是作为一个后端开发,本人对于npm并不是很熟悉,而且怕被弄乱系统,因此选择了使用docker来启动一个npm的容器,这样就简单很多(反正它也只是用来安装hexo和生成博客的). Dockerfile如下: 123456789FROM node:10MAINTAINER tangfei_cn@foxmail.comWORKDIR /appCOPY ./package.json .# 国内的服务器,可以加上 npm config set registry https://registry.npm.taobao.org 设置源RUN npm install -g hexo-cli &amp;&amp; npm install -g &amp;&amp; npm install hexo --save 然后只需要在博客源码所在的页面执行下面一条语句即可.可以进行的优化有:使用alpine-node进行容器的体积优化.当然也可以直接换个思路…. 123# 这里的主要思路是将docker作为npm环境,然后将博客目录映射到容器中的对应目录进行构建.# 将生成的html文件所在的目录保存在本机上提供给nginx进行发布.docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generate 最终,我的Jenkins Shell中的配置如下: 123456789# 这里使用了jenkins自带的一些环境变量,避免硬编码cd $&#123;WORKSPACE&#125;docker build -t hexo:0.1 ./docker run --rm -v $PWD/public:/app/public/ -v $PWD/themes:/app/themes/ -v $PWD/source:/app/source/ -v $PWD/db.json:/app/db.json -v $PWD/_config.yml:/app/_config.yml hexo:0.1 hexo generaterm -rf /var/www/hexo/*cp -r ./public/* /var/www/hexo/# 为了解决权限问题...chmod o+r /var/www/hexo 在我的预想中,这个任务应该能正常运行,但是又遇到了权限问题…在将文件拷贝到 /var/www/hexo/ 下后,nginx无法读取该目录下的文件,导致502了…因此将supervisor中jenkins程序的user改成了root,并在Jenkins Shell的最后加了一句修改文件夹权限的命令… Update: 无需以root启动jenkins,只需修改结果文件的目录权限即可 总结 这一步之后,博客就搭建完成了,目前很符合我的需求,虽然不完美,但是已经没有了改动的想法. 如果你在仿照这篇博客搭建自己的博客时遇到了什么问题,或者觉得哪里不满足需求,可以联系我~]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习-总结]]></title>
    <url>%2F2018%2F04%2F25-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(7).html</url>
    <content type="text"><![CDATA[前言 总算是断断续续的看完了,但是由于实践比较少,因此很多语法并没有深入的认识.但是也不能说完全没有收获,至少有了一些印象,当再看C语言相关的代码的时候至少知道搜索的关键词是什么了(笑..). 关于收获 总感觉做事是需要带着目的去的,事后也需要做总结,来审视做这件事的得失.没有目的就很难坚持下去,没有总结就容易产生浪费而不自知. 读这本书的目的 Flynnon是一个Python开发工程师,在能熟练的使用Python进行开发后就很自然的对它的实现产生了兴趣.于是上网百度了一圈,发现有一本现成的书《Python源码剖析》.简单了解了一下之后就买了它的影印版(很可惜绝版了…).并开始了学习… 但是进度远不如预期.当然,原因是多方面的(比如说Flynnon太懒..比如说手机太好玩(;´▽`)y-~~),但评估后发现对于C的不熟悉时影响效率的很大一个因素,因此决定先复习一下C语言的知识再继续. 关于这本书 看完之后感觉,这本书并不适合初学者(也许第一版会好一些吧),因为在什么都不懂的情况下(比如,连内存的概念都没有建立起来的时候),这本书开头的铺垫有点少.另外,它也不适合高级开发者,对于它们而言介绍的知识点过于简洁了,看完后还是有很多语法/用法没有学习到. 另外,也不怎么适合我这种半吊子,也许是翻译的问题,导致看起来有一种很难受的感觉.而且这本书过于简单了,对于知识点的介绍总是浅尝辄止,导致看完后细想来并没有收获什么.附录看起来倒是蛮全的,但是实在没有心情读完了…. Flynnon本人感觉这本书并不是很好,作者的思维太发散了,导致看起来很乱,初学者依靠这本书很难建立对C语言的完整印象,而且作者的发散思维又有很强的干扰作用,会使得读者(比如Flynnon)产生先暂停看看别的书的想法,而中断又不大可能,因此会导致读完后感觉不懂的东西还是很多(当然如果本来就知道这些知识点的话,会对那些知识点有一些不同的认识). 综上,感觉本书并不是一本很好的学习C语言的书籍… 收获 其实看完后的收获并不很多,因为日常开发中基本没有用到C的场景,这段时间的实践也仅仅是在看书的过程中写了一些小的Demo.因此对于这些知识点并没有记得很牢.但至少会对C语法有一定的印象,这样在看源码的时候至少知道怎么查了.因此也算是有些收获吧..]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(6)]]></title>
    <url>%2F2018%2F04%2F23-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(6).html</url>
    <content type="text"><![CDATA[前言 以下记录了第八章的一些知识点.这一章主要介绍了UNIX系统中用于输入和输出的系统调用,以及如何通过它们实现标准库函数(没细写). 输入/输出 在UNIX操作系统中,所有的外围设备(包括键盘和显示器)都被看作是文件系统中的文件.因此,所有的输入/输出都要通过读文件或写文件完成.也就是说,通过一个单一的接口就可以处理外围设备和程序之间的所有通信. 文件描述符 用户程序并不能直接操作文件(实际上文件仅仅是一种抽象),这部分权力被系统所接管.用户程序只能通过与系统交互得到一个文件描述符来对对应文件进行操作. 概念 文件描述符(File Descriptor)通常是一个小的非负整数,内核用以标识一个特定进程正在访问的文件.当打开一个现有文件或创建一个新文件时,内核向进程返回一个文件描述符.系统负责维护已打开文件的所有信息,用户程序只能通过文件描述符引用文件. 特殊的文件描述符 针对大多数的输入/输出是通过键盘和显示器来进行的这一现象,UNIX中的shell程序进行了优化.即: 把文件描述符0与进程的标准输入(standard input)关联,文件描述符1与标准输出(standard output)关联,文件描述符2与标准错误(standard error)关联. 这样的话,只要shell程序使用文件0作为输入,文件1和2作为输出,它就不会也无需知道程序的输入从哪里来,并输出到哪里去。 事实上,当我们通过shell进行简单的读写时,并不需要考虑什么文件描述符,直接使用read函数读取文本,再使用echo函数输出即可. 1234#!/bin/bash# demo.shread textecho $&#123;text&#125; 而使用者可以很方便的使用管道与0,1,2这三个文件描述符来进行重定向. 1234# 运行demo.sh文件./demo.sh # 从标准输入读取,并输出到标准输出./demo.sh &lt; la.txt &gt; xx.txt # 从la.txt进行读取,并输出到xx.txt# 通常,文件描述符2仍与显示器相关联.这样,出错信息会输出到显示器上 低级I/O 输入与输出是通过read和write系统调用实现的. 123456789/* 系统调用 */// 两个系统调用的函数都是类似的:// 参数: 第一个参数都是文件描述符,第二个参数是程序中存放读或写的数据的字符数组,第三个参数是要传输的字节数.// 返回值: 每个调用返回的都是实际传输的字节数,具体不同如下.int read(int fd, char *buf, int n); // 函数的返回值可能会小于请求的字节数.如果返回值为0,则表示已到达文件的结尾;如果返回值为-1,则表示发生了某种错误.int write(int fd, char *buf, int n); // 返回值是实际写入的字节数.如果返回值与请求写入的字节数不相等,则说明发生了错误 在一次调用中,读出或写入的数据的字节数可以为任意大小.但是,用更大的值调用该函数可以获得更高的效率,因为系统调用的次数减少了.但是一次读取太多的话,占用内存又会变多….所以需要权衡… 文件操作读取1234// open的函数签名// 参数: name为文件名, flags为打开方式, perms代表权限// 返回值: 所打开的文件的文件描述符,打开失败则返回-1.int open(char *name, int flags, int perms); open函数主要支持的几种打开方式: 名称 含义 对应 O_RDONLY 只读模式打开 r O_WRONLY 只写方式打开 w O_RDWR 读写方式打开 a 创建 12345// create的函数签名// 参数: name代表文件名, perms代表所创建的文件的权限.// 返回值: 所创建文件的文件描述符,打开失败则返回-1.// 如果此文件已存在,create将把该文件的长度截断为0,从而丢弃原先已有的内容(也就是覆盖).这个过程并不会报错,且权限不会更改. int create(char *name, int perms); 关闭 一个程序能同时打开的文件数目是有限制的(一般为20),因此当一个程序需要同时处理许多文件时,要么更改系统的限制数目要么重用文件描述符. 作为一个合格的程序,不应该擅自更改一些系统变量.因此,比较好的方法是重用文件标识符.其实也就是释放原来占用的文件标识符,再申请新的文件标识符. close用来断开文件描述符和已打开文件之间的连接,并释放此文件描述符,以供其它文件使用. 1234// close的函数签名// 参数: 要关闭的文件的文件标识符// 返回值: 成功返回0,出错返回-1.int close(int fd); close的功能与fclose类似,但是fclose会刷新缓冲区,而close不会. 当一个进程终止时,内核对该进程所有尚未关闭的文件描述符调用close关闭,所以即使用户程序不调用close,在终止时内核也会自动关闭它打开的所有文件. 删除 unlink将一个名称(这个涉及到软连接与硬链接..)从系统中删除. 1234// unlink的函数签名// 参数: 要删除的文件名// 返回值: 成功执行时,返回0;失败返回-1.int unlink(const char *pathname); 随机访问 上面介绍的read和write方法在访问文件时时顺序进行的,也就是在访问第1000个字符时需要先顺序访问前999个,但是对于我们的需求来说,这就有点浪费了,我们实际上需要一种可以直接从开头跳到第1000个字符的方法,也就是随机访问. 正好,系统调用lseek与fseek可以在文件中任意移动位置而不实际读写任何数据. 123456789101112131415161718192021222324252627// lseek的函数签名// 参数: fd -&gt; 要操作的文件的文件描述符// offset -&gt; 偏移量(相对于origin而言的),当origin参数不为0时,offset参数可以为负值// origin -&gt; 定位符(0表示以文件开头位置为基点,1表示以当前位置为基点,2表示以文件结束位置为基点).// 返回值: 调用成功时返回目前的读写位置,也就是距文件开头的字节数.若有错误则返回-1.long lseek(int fd, long offset, int origin);// 示例: 指向文件的末尾lseek(fd, 0L, 2);// fseek的函数签名// 参数: stream -&gt; 代表要操作的文件的文件指针// offset -&gt; 与上同// origin -&gt; 与上同// 返回值: 调用成功时返回0,若有错误则返回一个非零值.// 附加说明: fseek不像lseek会返回读写位置,因此必须使用ftell()来取得目前读写的位置int fseek(FILE * stream, long offset, int origin);// 示例: 指向文件的末尾fseek(FILE *stream, 0, 2);// ftell的函数签名// 参数: stream -&gt; 代表要操作的文件的文件指针// 返回值: 调用成功时返回目前的读写位置,也就是距文件开头的字节数.出错则返回-1.long ftell(FILE *stream); 获取文件信息 UNIX中,文件的信息是存储在inode表中的,而文件名仅仅是inode的一个别称. 也就是说,在UNIX中通过文件名打开文件需要经历以下步骤: 1.系统找到这个文件名对应的inode号码; 2.系统通过inode号码,获取到对应的inode信息; 3.根据inode信息,定位文件数据所在的block,读出数据. 在UNIX系统中,目录就是文件.目录文件的结构非常简单,就是一系列目录项(dirent)的列表.每个目录项,由两部分组成:所包含文件的文件名,以及该文件名对应的inode号码. 我们可以通过系统调用stat来获取某文件的信息. 1234567891011121314151617181920212223// stat的函数签名// 参数: path -&gt; 代表要操作的文件的路径// buf -&gt; 用来承载文件信息的stat结构体对象的指针// 返回值: 返回文件的i结点中的所有信息;若出错,则返回-1.int stat(const char *path, struct stat *buf);// 头文件&lt;sys/stat.h&gt;中包含了描述stat的返回值的结构// 这个就不细写了,用到的时候查就可以了~(Flynnon还是太懒了...)struct stat &#123; mode_t st_mode; //文件对应的模式,文件,目录等信息. ino_t st_ino; //inode节点号 dev_t st_dev; //设备号码 dev_t st_rdev; //特殊设备号码 nlink_t st_nlink; //文件的连接数 uid_t st_uid; //文件所有者 gid_t st_gid; //文件所有者对应的组 off_t st_size; //普通文件,对应的文件字节数 time_t st_atime; //文件最后被访问的时间 time_t st_mtime; //文件内容最后被修改的时间 time_t st_ctime; //文件状态改变时间 blksize_t st_blksize; //文件内容对应的块大小 blkcnt_t st_blocks; //伟建内容对应的块数量&#125;; 下面给出一个使用stat系统调用的例子. 123456789#include &lt;sys/stat.h&gt;#include &lt;unistd.h&gt;#include &lt;stdio.h&gt;int main() &#123; struct stat buf; stat("/etc/hosts", &amp;buf); printf("/etc/hosts file size = %d\n", buf.st_size); // 通过stat系统调用得到了某个文件的大小并打印&#125; 扩展 UNIX系统中的权限是由九位二进制数字控制的,具体如下: 1.从左至右,1-3位数字代表文件所有者的权限,4-6位数字代表同组用户的权限,7-9数字代表其他用户的权限. 2.每三位中,第一位代表读权限,第二位代表写权限,第三位代表执行权限. 也就是:代表权限的二进制的取值范围为:000 000 000 - 111 111 111,换算为八进制就是 0000 - 0777.方便起见,一般使用三个八进制的值来表示权限,例如777代表所有人拥有所有权限. 在Linux中更改文件权限的方式如下. 123456#!/bin/bash# 将某个文件的权限换成777(所有人都可读可写可执行)sudo chmod 777 $&#123;file_path&#125;# 使某文件对于其所属用户组可执行.sudo chmod g+x $&#123;file_path&#125;]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[《操作系统革命》杂记]]></title>
    <url>%2F2018%2F04%2F11-%E3%80%8A%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%E9%9D%A9%E5%91%BD%E3%80%8B%E6%9D%82%E8%AE%B0.html</url>
    <content type="text"><![CDATA[前因 最近莫名其妙的产生了自己搭建服务器的想法(已经有云服务器的前提下),结果淘宝、京东、百度、Google了一圈之后发现好像没有便宜的….但是也不是毫无收获吧,搜索的过程中,不知道在哪里看到了《操作系统革命》这个名字,感觉很高大上的样子….就搜了一下,发现B站上有这个纪录片.于是把它看完了,并进行了一些记录. 记录片基本是跟随Linux发展的时间线走的,从GNU开始说起,直到Red Hat和VA Linux的上市为止.因为是科普性质,所以很多事情都是一笔带过的. 大事记 比尔盖茨首先提出了软件是需要收费的. Richard Stallman从1983年开始逐步开启了GNU计划,并聚集了一帮人开发出了除了内核之外的一套操作系统上的工具.在这个过程中他创建了Free Software Foundation(自由软件基金会). 而Linus比他们早开发出内核(Linux内核),因此1992年,两方结合组成了一个完整的操作系统生态. 因为后来Linux这个名字使用更加广泛,因此Richard与Linus两位大佬谁都不服谁…纪录片中那个颁奖视频中一个在强调是GNU(GNU/Linux)系统而不是Linux系统,另一个在逗娃… 1998年的GNU自称为Free Software(Free是指开放,即源代码可以获取、修改),然而人们总把它与免费联系在一起,认为它不能赚钱,违背了商业道德.基于此以及理念上的不同,Eric,Linus等一批人提出了Open Source的概念,并成立了开放源代码促进会. IE使用捆绑、免费打败网景之后,网景开始担心微软滥用市场地位,修改通用标准(HTML/HTTP)等,使其它软件公司(网景等)被迫退出服务器市场.,因此决定开放源代码(把源代码本身开做产品,借助公司之外的人开发软件).这个决定使得OpenSource与Linux进入到更多人的视线(毕竟大公司). 自由软件社团的人组织对微软发起退款运动…使得计算机制造商允许人们购买未预装操作系统的电脑. Red Hat与VA Linux的上市,标志着Linux系统与开源的巨大胜利(当然,记录片中的VA Linux,现在基本没听到过这个名字了…). Linux内核发展简史 1991年,Linux 0.01发布,1万行代码,1个用户. 1992年,Linux 0.96发布,4万行代码,1000个用户. 1993年,Apache项目正式启动,促进了Internet发展的同时,并使得Linux系统使用人数快速增长(使用这一套很省钱且很快就可以搭建一个Web服务器,回报比NT高).并且Apache的市场份额逐渐增加(可靠、灵活、可扩展). 1994年,Linux 1.0发布,17万行代码. 1995年,Linux 1.2发布,25万行代码,50万用户. 1997年,Linux 2.1发布,80万行代码,350万用户. 1998年,Linux 2.110发布,150万行代码,750万用户. 1998年,开放源代码促进会(Open Source Intiative)成立. 1999年,Linux 2.2发布,1200万用户. 1999年,RED HAT成为首个上市的Linux公司. 自由(Free)与开源(Open Source)自由软件中的四种自由: 自由之零：不论目的为何，有使用该软件的自由; 自由之一：有研究该软件如何运作的自由，并且得以修改该软件来匹配用户自身的需求。获取该软件之源码为达成此目的之前提; 自由之二：有重新散布该软件的自由，所以每个人都可以借由散布自由软件来敦亲睦邻; 自由之三：有改善再利用该软件的自由,并且可以发表修订后的版本供公众使用,如此一来，整个社区都可以受惠.如前项,获取该软件之源码为达成此目的之前提. Open Source许可证原则: 1.自由的重新发布(无所谓收不收费); 2.必须附带源码； 3.衍生著作,拿到别人的源码后可在遵循统一协议的情况下再发布; 4.必须保证原作者程序的完整性,须使用版本号分别; 5.没有对个人或组织的歧视; 6.没有对任何领域的歧视; 7.许可证是可继承的; 8.不针对特定系统; 9.不能损坏其它程序的许可性质. 纪录片中对自由软件与Free Software区别的解释: Open Source 关注的是可以由此形成一个社团,成员通过交流与改进软件来相互协作. Free Software 关注的是与他人合作的自由、组织社团的自由. GUN基金会的解释: https://www.gnu.org/philosophy/free-software-for-freedom.zh-cn.html 收获 其实看完之后,收获真的不多…只能说了解了Linux发展的历史,以及对闭源,开源和自由软件有了一点了解. 我认为开源本身对于开发者的好处是显而易见的,可以通过观看其它人写到代码来提升自己(得有耐心…),如果自己开发的的程序/功能被很多人使用,对于个人品牌打造很有帮助.就像记录片中的某人(没记住名字…),在面试的时候直接来了一句,某某软件是我开发的~怎一个潇洒了得. 另外,自由软件这个概念也很好,但是并不好实现,只能说盼望世界变成这样吧… 然而,闭源将软件看做劳动成果保护起来,用以获取财富;开源将软件看做知识,提倡自由分享.这两种都没错…只能说是立场之争…站在我的角度,肯定是开源好一点了(性价比高且使用时有莫名的成就感)… 再好的软件也需要推广,比如纪录片中提到的每隔一段时间的安装会,以及掀起对微软的退款游行以提高知名度.. 题外话 感觉这篇博客语法很差劲…但是又没想还咋改,希望未来的某个时间能再次看到这篇博客,并修改一番吧…]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(5)]]></title>
    <url>%2F2018%2F04%2F10-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(5).html</url>
    <content type="text"><![CDATA[前言 以下记录了第七章的一些知识点. 输入输出 标准库实现了简单的文本输入/输出模式.在这个模式中,文本流由一系列行组成,每一行的结尾是一个换行符.如果系统没有遵循这种模式,则标准库将通过一些措施使得该系统适应这种模式.例如,标准库可以在输入端将回车符和换行符都转换为换行符,而在输出端进行反向转换. 一般输入输出相关的标准函数均定义在&lt;stdio.h&gt;头文件中. 标准输入输出函数12345// getchar 与 putchar // getchar从标准输入进行字符读取.函数在每次被调用时返回下一个输入字符.若遇到文件结尾,则返回EOF.int getchar(void);// putchar将字符输送至标准输出上.如果没有发生错误,则函数putchar返同输出的字符;如果发生了错误,则返回EOF.int putchar(int); 符号常量EOF(END OF FILE)在头文件&lt;stdio.h&gt;中定义,其值一般为-1,但程序中应该使用EOF本身来测试文件是否结束,这样才能保证程序同EOF的特定值无关. 事实上,getchar与putchar都是宏定义而不是函数. 格式化输出 格式化输出是更高层次上的一种输出方法,通过它可以设定输出格式. 函数12345678910// printf的函数原型// printf在输出格式format的控制下,将其参数进行转换与格式化,并输出到标准输出.它的返回值为打印的字符数.// 后面三个小数点代表变长参数表(不定长参数),具体请见下方扩展int printf(char *format, ...);// sprintf的函数原型// printf在输出格式format的控制下,将其参数进行转换与格式化,并将结果存放到string中.它的返回值为打印的字符数.int sprintf(char *string, char *format, ...);// 注意:上述函数使用第一个参数判断后面参数的个数及类型.如果参数的个数不够或者类型错误,则将得到错误的结果. 格式字符串 格式字符串即printf函数与sprint函数的函数定义中的format参数. 格式字符串包含两种类型的对象:普通字符和转换说明.在输出时,普通字符(不包括%)将原样不动地复制到输出流中,而转换说明则是用于控制上述函数中其余参数(即最后不定长参数表)的转换和打印. 每个转换说明都由一个百分号字符(即%)开始,并以一个转换字符结束.合法的转换字符列表如下: 转换字符 参数类型 输出形式 d, i int 类型 十进制数 o int 类型 无符号八进制数(没有前导 0) x, X int 类型 无符号十六进制数(没有前导0x或0X),即:10~15分别用abcdef或ABCDEF表示 u int 类型 无符号十进制数 c int 类型 单个字符 s char *类型 顺序打印字符串中的字符，直到遇到’\0’或已打印了由精度指定的字符数为止 f double 类型 十进制小数[-]m.dddddd，其中d的个数由精度指定(默认值为6) e, E double 类型 科学计数法[-]m.dddddd e ±xx 或[-]m.dddddd E ±xx，其中d的个数由精度指定(默认值为 6) g, G double 类型 如果指数小于-4或大于等于精度,则用 %e/%E 格式输出,否则用 %f 格式输出.尾部的0和小数点不打印 p void *类型 指针(取决于具体实现) % 无(不转换参数) 打印一个百分号% 填充 通过在%与转换字符之间添加一些特定格式的值可以更加细致的控制输出格式(例如指定输出是左对齐还是右对齐).合法的填充如下: 填充格式 含义(作用) 负号 - 指定被转换的参数按照左对齐的形式输出 数字 指定最小字段宽度,转换后的参数将打印不小于最小字段宽度的字段.不足则用空格填充 小数点 字段宽度与精度的分隔符 数字 指定精度.(指定字符串中要打印的最大字符数,浮点数小数点后的位数,整型最少输出的数字数目) 字母 h 或 l 只能作用于整形.h表示将整数作为short类型打印. l表示将整数作为long类型打印 效果示例 下面是一些示例(以printf(format, “hello world”)为例): 格式化字符串(format) 输出结果 解释 :%12s: : hello world: 最少输出12个字符(右对齐) :%.9s: :hello wor: .分隔, 最大输出九个字符(超出的截断) :%-12s: : hello world: 最少输出12个字符(左对齐) :%-11.10s: :hello worl : .分隔, 最少输出11个字符,后面的字符串输出10位,左对齐 扩展 在printf函数与sprintf函数的声明中均使用了三个小数点(省略号)来作为参数,这种参数叫做变长参数表.它表示参数表中参数的数量和类型是可变的,且它只能出现在参数表的尾部. 变长参数表的使用: 标准头文件&lt;stdarg.h)中包含一组宏定义,它们对如何遍历参数表进行了定义.具体请见下列示例. 123456789101112131415161718192021222324252627282930313233343536373839404142/* 使用变长参数表实现一个具有printf部分功能的函数 */#include&lt;stdio.h&gt;#include&lt;stdarg.h&gt;/* 变长参数表相关的宏有 va_list, va_start, va_arg, va_end. 它们都被定义在 stdarg.h 头文件中 *//* 适应变长参数表时参数列表中至少应包括一个有名参数(例如以下示例中的fmt), va_start将最后一个有名参数作为起点 */void minprintf(char *fmt, ...)&#123; // 声明不定长参数表 va_list ap; // 使用 va_list宏 来声明一个指向变长参数表的参数指针. char *p, *sval; // 定义一些中间变量 int ival; double dval; va_start(ap, fmt); // 使用 va_start宏 来使上面声明的参数指针ap指向变长参数表中的第一个参数.在使用 ap 之前,该宏必须被调用一次 for (p = fmt; *p; p++) &#123; // 遍历 fmt 参数(即格式字符串) if (*p != '%') &#123; // 跳过格式字符串中的 % 字符 putchar(*p); continue; &#125; switch (*++p) &#123; // 根据格式字符来选择具体的打印策略 case 'd': ival = va_arg(ap, int); // 使用 va_arg宏 来从不定长参数表中读取特定类型的参数,并将参数指针移动相应的步长 printf("%d", ival); // 为了简单....使用了printf函数来完成输出时的格式转化 break; case 'f': dval = va_arg(ap, double); printf("%f", dval); break; case 's': for (sval = va_arg(ap, char *); *sval; sval++) putchar(*sval); break; default: putchar(*p); break; &#125; &#125; va_end(ap); // 使用结束后,使用 va_end宏 来完成清理工作&#125;int main(void)&#123; minprintf("%d %s %f", 1, "hahaha", 2.5); // 调用, 其结果与同参数调用printf函数相同 return 0;&#125; 格式化输入 格式化输入是更高层次上的一种输入读取方法,通过它可以对读取到的字符串进行转化,直接得到特定类型的变量. 函数12345678910111213// scanf的函数原型// scanf函数从标准输入中读取字符序列,按照format中的格式说明对字符序列进行解释,并把结果保存到其余的参数中int scanf(char *format, ...);// sscanf的函数原型// sscanf从字符串string中读取字符序列,按照format中的格式说明对字符序列进行解释,并把结果保存到其余的参数中int sscanf(char *string, char *format, ...);// 注意:// 1.scanf与sscanf函数的所有不定长参数都必须是指针,用于指定经格式转换后的相应输入保存的位置;// 2.上述函数在扫描完其格式串或者碰到某些输入无法与格式控制说明匹配的情况时,终止执行.// 3.上述函数的返回值为成功匹配并赋值的输入项的个数,而当达到文件尾时,该函数返回EOF. 即:该函数的返回值可以用来确定已匹配的输入项的个数.// 4.返回值为0表示下一个输入字符与格式串中的第一个格式说明不匹配.下一次调用scanf函数时将从上一次转换的最后一个字符的下一个字符开始继续搜索. 格式字符串 格式字符串即scanf函数与sscanf函数的函数定义中的format参数.它通常包含转换说明,用于控制输入的转换. 格式字符串包含三种类型的对象:空白字符(空格/制表符),普通字符和转换说明.在读取时,空白字符将被忽略,普通字符(不包括%),用于匹配输入流中下一个非空白符字符,而转换说明则是用于控制上述函数中其余参数(即变长参数表中的参数)的读取与转换. 每个转换说明都由一个百分号字符(即%)开始,并以一个转换字符结束.合法的转换字符列表如下: 转换字符 参数类型 读取参数格式 d int *类型 十进制整数 i int *类型 可以是八进制(以 0 开头)或十六进制(以 0x 或 0X 开头) o int *类型 八进制整数(可以以 0 开头,也可以不以 0 开头) x int *类型 十六进制整数(可以 0x 或 0X 开头,也可以不以 0x 或 0X 开头) u unsigned int *类型 无符号十进制整数 c char *类型 字符 s char *类型(指向一个足以存放该字符串(还包括尾部的字符’\0’)的字符数组.字符串的末尾将被添加一个结束符’\0’) 字符串(不加引号) e, f, g float *类型 浮点数,它可以包括正负号(可选)、小数点(可选)及指数部分(可选) % 无(不进行任何赋值操作) 不进行任何赋值操作 填充 通过在%与转换字符之间添加一些特定格式的值可以更加细致的控制读取规则.合法的填充如下: 填充格式 含义(作用) 赋值禁止字符 * 被此字符填充时,跳过该输入字段,不进行赋值 数字 指定最大字段宽度 h 只能作用于整形.h表明参数表的相应参数是一个指向short类型的指针 l 作用于整数时,表明参数表的相应参数是一个指向long类型的指针.作用于浮点数时,表明参数表的相应参数是一个指向double类型的指针 使用示例12345678910111213141516171819#include &lt;stdio.h&gt;int int_v;char char_v[20];float f_v;scanf("%d %s %*d %f", &amp;int_v, char_v, &amp;f_v);// 运行上述程序片段时,可在标准输入输入 10 lalala 3 2.8, 之后, int_v的值为10, char_v数组的前七个字符为 l a l a l a \0, f_v的值为 2.8// scanf函数忽略格式串中的空格和制表符.此外,在读取输入值时,它将跳过空白符(空格符、横向制表符、换行符、回车符、纵向制表符以及换页符).如果要读取格式不固定的输入,最好每次读入一行,然后再用sscanf将合适的格式分离出来读入.// scanf函数可以与其它输入函数混合使用,无论使用哪个输入函数,调用下一个输入函数时将从scanf没有读取的第一个字符处开始读取数据.即:每次使用scanf它的读取都会被消费,而读取失败的会被略过.// 场景: 在从标准输入读取日期时,支持多种输入格式.while (getline(line, sizeof(line)) &gt; 0) &#123; // 需要保存输入,再一一判断格式 if (sscanf(line, "%d %s %d", &amp;day, monthname, &amp;year) == 3) printf("valid: %s\n", line); // dd mm yy 格式 else if (sscanf(line, "%d/%d/%d", &amp;month, &amp;day, &amp;year) == 3) printf("valid: %s\n", line); // mm/dd/yy格式 else printf("invalid: %s\n", line);&#125; 文件操作 文件也可以看成是一种特殊的输入输出设备.事实上,在Linux系统中一切都被抽象成文件. 文件的打开 在操作文件之前,我们需要先打开一个文件.这个操作是通过&lt;stdio.h&gt;头文件中的fopen函数实现的.它的介绍如下: 1234567891011#include &lt;stdio.h&gt;// fopen函数的函数签名// 第一个参数name是一个字符串,它包含了文件名(包括绝对路径).// 第二个参数mode也是一个字符串，它代表了文件的使用模式,用于指定文件的使用方式.这个参数的详细介绍在后面一点.// 它的返回值是一个可以用于文件读写操作的指针,被成为文件指针.关于文件指针,后面在详细介绍.FILE *fopen(char *name, char *mode);// fopen函数的使用// 以写模式打开一个文件FILE *fp = fopen("/home/flynnon/a.txt", "w"); fopen函数返回的文件指针实际上指向的是一个包含文件信息的结构.这些所指的信息包括:缓冲区的位置、缓冲区中当前字符的位置、文件的读或写状态、是否出错或是否已经到达文件结尾等等状态.如果发生错误,fopen将返回 NULL. 幸运的是,我们并不需要直接与这些具体的细节打交道.这些信息已经被&lt;stdio.h&gt;头文件中的FILE封装好了.这里要注意的是FILE像int一样是一个类型名,而不是一个结构标记(它是通过typedef定义的). 使用fopen打开一个文件有多种模式,见下表: 模式字符串 名称 行为 w 写模式 打开不存在的文件时,会新建.打开已存在的文件时,会将先该文件的内容清空.然后写入. r 读模式 只能对文件内容进行读取,不能写入. a 追加模式 打开不存在的文件时,会新建.打开已存在的文件时,会将指针移动到文件末尾.然后写入. r 与上述模式合用,二进制模式 用来打开二进制类型的文件. 文件内容的读写 有两个类似于getchar与putchar的从文件中操作字符的函数getc与putc,下面是介绍. 123456// getc与putc都需要一个文件指针,以得到操作的文件的信息.// getc函数返回fp指向的输入流中的下一个字符.如果到达文件尾或出现错误,该函数将返回EOF.int getc(FILE *fp);// putc函数将字符c写入到fp指向的文件中,并返回写入的字符.如果发生错误,则返回EOF.int putc(int c, FILE *fp); 同样的,也有两个类似于printf与scanf的从文件中操作字符的函数fprintf与fscanf,下面是介绍. 1234// 它们与scanf和printf函数的区别仅仅在于它们的第一个参数是一个指向所要读写的文件的指针int fscanf(FILE *fp, char *format, ...);int fprintf(FILE *fp, char *format, ...); 特殊的文件 启动一个C语言程序时,操作系统环境负责打开3个文件,并将这3个文件的指针提供给该程序.这3个文件分别是标准输入、标准输出和标准错误,它们的文件指针分别为stdin、stdout和stderr. stdin,stdout,stderr都是常量,不能为它们重新赋值. 事实上,前面的标准输入输出函数getchar与putchar可以等同于下列定义宏定义. 123// 实际上,getchar与putchar只是从标准输入stdin中进行字符的读取与输出.#define getchar() getc(stdin)#define putchar(c) putc((c),stdout) 关闭文件 文件作为一种资源,长时间占用总是不好的.因此在使用完成之后需要关闭它.这时就会用到fclose函数. 当文件指针不再需要时及时释放是一个很好的习惯.当程序正常终止时,程序会自动为每个打开的文件调用fclose函数. 123// fclose函数关闭一个文件指针所指的文件流,把缓冲区内最后剩余的数据输出到流中,并释放函数指针和有关的缓冲区.// 如果流成功关闭,fclose返回0,否则返回EOF.int fclose(FILE *fp); 重定向 有时候在编写代码时,不想通过硬编码来指定输入输出的文件,此时可以使用freopen函数来进行流的重定向. 123456789101112// freopen函数可以把预定义的标准流文件定向到以mode模式打开的filename文件的文件指针FILE * freopen(const char *filename, const char *mode, FILE *stream);// 下列语句将标准输出重定向到了normal.log文件中freopen("normal.log", "w", stdout);// 此时下列输出语句实际上是将 "lalalal" 输出到normal.log文件中printf("lalalal");// 下列语句将标准输出重定向到了normal.log文件中freopen("normal.log", "w", stdout);// 此时下列输出语句实际上是将 "lalalal" 输出到normal.log文件中printf("lalalal"); 输出错误 前面提到标准输入输出有三种,也给出了使用stdin、stdout(使用printf,scanf,pprintf,pscanf)的例子.下面会给出一个使用stderr的示例,并介绍ferror、feof函数. 12345678910111213141516171819202122232425#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;int main(int argc, char *argv[]) &#123; if(argc == 1)&#123; fprintf(stderr, "param is wrong."); // 将字符串输出到标准错误 exit(1); // 使用exit退出程序 &#125; FILE *fp = fopen("/Users/flynnon/blog/d.json", "r"); if(ferror(fp))&#123; // 检查文件流中是否有错误 fprintf(stderr, "ope file error"); exit(1); &#125; exit(0);&#125;// exit函数被调用时,调用程序将终止执行,任何调用该程序的进程都可以获取exit的参数值.// 一般以0作为正常的返回值,以其余数字作为错误的标志(可以看看Linux中的规定).// exit还会为每个已打开的输出文件调用fclose函数,以将缓冲区中的所有输出写到相应的文件中.void exit(int);// 如果流fp中出现错误,则函数ferror返回一个非0值.int ferror(FILE *fp);// 如果指定的文件到达文件结尾,它返回一个非0值.int feof(FILE *fp); 行输出与行输入 在读取文件的时候,常常有读取一行或者输出一行的需求,而使用以上的fgetc/fscanf/fputc/fprintf都不是很方便(傻瓜)…还好,C语言标准库提供了fgets与fputs方法…下面是介绍. 1234567// 输出函数fputs将一个字符串(不需要包含换行符,此函数自己根据平台添加)写入到一个文件中.发生错误时,该函数将返回EOF,否则返回一个非负值.int fputs(char *line, FILE *fp);// fgets函数从fp指向的文件中读取下一个输入行(包括换行符),并将它存放在字符数组line中,它最多可读取maxline-1个字符.// fgets读取的行将以'\0'结尾保存到数组中.// 通常情况下,fgets返回line,但如果遇到了文件结尾或发生了错误,则返回 NULL.char *fgets(char *line, int maxline, FILE *fp); 同printf与fprintf,scanf与pscanf一样,对于标准输入输出也有一对类似的函数fget与fput. puts函数在写入字符串时会在结尾添加一个换行符;而gets函数在读取字符串时会自动删除结尾的换行符(‘\n’). 常用函数 在C标准库中提供了很多常用的函数. 字符串操作相关 与字符串操作相关的函数主要定义在&lt;string.h&gt;头文件中,下面是介绍. 函数声明 作用 返回值 char strcat(char dest, const char *src) 将src指向的字符串复制到dest指向的字符串的末尾 指向最终的目标字符串dest的指针 char strncat(char dest, const char *src, size_t n) 把src所指向的字符串追加到dest所指向的字符串的结尾,直到n字符长度为止 指向最终的目标字符串dest的指针 int strcmp(const char str1, const char str2) 把str1所指向的字符串和str2所指向的字符串进行比较(按照每一位的ascii比较) 标志大小的int值,大于(正),小于(负),等于(0) int strncmp(const char str1, const char str2, size_t n) 把str1和str2进行比较,最多比较前n个字节 同上 char strcpy(char dest, const char *src) 把src所指向的字符串复制到dest 指向最终的目标字符串dest的指针 char strncpy(char dest, const char *src, size_t n) 把src所指向的字符串复制到dest,最多复制n个字符,src长度小于n时,使用NULL填充 指向最终的目标字符串dest的指针 size_t strlen(const char *str) 计算字符串str的长度,直到空结束字符,但不包括空结束字符 长度 char strchr(const char str, int c) 在参数str所指向的字符串中搜索第一次出现字符c(一个无符号字符)的位置 指向第一次出现位置的指针,未找到则返回NULL char strrchr(const char str, int c) 在参数str所指向的字符串中搜索最后一次出现字符c(一个无符号字符)的位置 指向最后出现位置的指针,未找到则返回NULL 字符串类别测试与转化函数 头文件&lt;ctype.h&gt;中定义了一些用于字符测试和转换的函数.下面是介绍. 函数签名 含义 返回值 int isalpha(int c) 判断c是否是字符 若c是字符,返回一个非零值,否则返回0 int isupper(int c) 判断c是否是大写字符 若c是大写字符,返回一个非零值,否则返回0 int islower(int c) 判断c是否是小写字符 若c是小写字符,返回一个非零值,否则返回0 int isdigit(int c) 判断c是否是数字字符 若c是数字字符,返回一个非零值,否则返回0 int isalnum(int c) 判断c是否是字母/数字 若c是字母/数字,返回一个非零值,否则返回0 int isspace(int c) 判断c是否是空白字符(空格、横向制表符、换行符、回车符，换页符或纵向制表符) int toupper(int c) 将c转化成大写字母 如果c有相对应的大写字母,则该函数返回c的大写字母.否则返回c本身 int tolower(int c) 将c转化成小写字母 如果c有相对应的小写字母,则该函数返回c的小写字母.否则返回c本身 命令执行函数 函数system(char* s)执行包含在字符申s中的命令,然后继续执行当前程序. system函数返回一个整型的状态值,其值来自于执行的命令,并同具体系统有关. 存储管理函数 函数malloc和calloc用于动态地分配存储块.介绍如下. 1234567891011// malloc的函数签名// 当分配成功时,它返回一个指针,设指针指向n字节长度的未初始化的存储空间,否则返回NULL.void *malloc(size_t NumBytes);// calloc的函数签名// 当分配成功时,它返回一个指针,该指针指向的空闲空间足以容纳由n个指定长度的对象组成的数组,否则返回NULL.该存储空间被初始化为0.// numElements: 对象个数, sizeOfElement: 每个对象的大小void *calloc(size_t numElements,size_t sizeOfElement);// 释放p指向的存储空间.其中,p是此前通过调用malloc或calloc函数得到的指针void free(void *FirstByte); 数学函数 头文件&lt;math.h&gt;中声明了20多个数学函数,感觉用到的时候查就可以了… 随机数 函数rand()生成介于0和RAND_MAX之间的伪随机整数序列(RAND_MAX是在头文件&lt;stdlib.h&gt;中定义的符号常量). 函数srand(unsigned)设置rand函数生成的序列的种子. 12// 生成0-1之间的随机数的宏定义#define frand() ((double) rand() / (RAND_MAX+1.0))]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(4)]]></title>
    <url>%2F2018%2F03%2F29-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(4).html</url>
    <content type="text"><![CDATA[前言 以下记录了第六章的一些知识点. 结构语义 结构是一个或多个变量的集合,这些变量可能为不同的类型.也就是说:为了处理的方便而将这些变量组织在一个名字之下,这个名字被称作结构. 语法 关键字 struct 引入结构声明.结构声明由包含在花括号内的一系列声明组成. struct后面的名字是可选的,称为结构标记.结构标记用于为结构命名,在定义之后,结构标记就代表花括号内的声明,可以用它作为该声明的简写形式. 结构中定义的变量称为成员. 结构成员、结构标记和普通变量(即非成员)可以采用相同的名字,它们之间不会冲突. 123456// 结构的声明struct point &#123; // struct是关键字.point被称作结构标记 int x; // x,y,point 被称为成员 int y; int point; // 通过分析上下文,可以很明显的分辨出两个point代表的含义&#125;; struct声明定义了一种数据类型.在标志结构成员表结束的右花括号之后可以跟一个变量表,这与其它基本类型的变量声明方式是相同的. 如果结构声明的后面不带变量表,则不需要为它分配存储空间,它仅仅描述了一个结构的模板或轮廓. 如果结构声明中带有标记,那么在以后定义结构实例时也可以使用该标记定义. 12345// 结构实例的声明struct &#123; int x; &#125; x, y, z; // 直接跟变量表声明结构实例struct point pt; // 通过标记定义声明结构实例 结构的初始化可以在定义的后面使用初值表进行.使用这种方式初始化时,初值表中同每个成员对应的初值必须是常量表达式. 自动结构也可以通过赋值初始化,还可以通过调用返回相应类型结构的函数进行初始化. 123456789101112131415161718192021// 结构实例的初始化#include &lt;stdio.h&gt;struct point&#123; int x; int y; int point;&#125;;struct point get_point(void)&#123; struct point pt = &#123;4, 5, 6&#125;; return pt;&#125;;int main(void)&#123; struct point p1 = &#123;1, 2, 3&#125;; // 使用初值表初始化 struct point p2 = p1; // 赋值初始化 struct point p3 = get_point(); // 通过函数返回值初始化 struct point p4; // 自动初始化.此时: p4.x == p4.y == p4.point == 0&#125; 在表达式中，可以通过 结构名.成员 这样的形式来引用某个特定结构中的成员. 123456789101112131415#include &lt;stdio.h&gt;struct point&#123; int x; int y; int point;&#125;;int main(void)&#123; struct point p = &#123;1, 2, 3&#125;; printf("%d %d %d ", p.x, p.y, p.point); // 访问成员 p.x = 100; printf("%d %d %d", p.x, p.y, p.point); // 也可以为成员赋值&#125;// 很明显,输出是: 1 2 3 100 2 3 结构可以嵌套,即:结构中可以包含结构(不能嵌套自身的结构体). 1234567891011121314# include&lt;stdio.h&gt;struct inner&#123; int x;&#125;;struct outer&#123; struct inner y; // 结构体的嵌套 int x;&#125;;int main(void)&#123; struct outer o = &#123;&#123;1&#125;, 2&#125;; // 嵌套型结构体的初始化 printf("%d %d", o.y.x, o.x); // 很明显,输出为 1 2&#125; 运算 结构仅支持如下操作: 1.作为一个整体复制和赋值(包括向函数传递参数以及从函数返回值); 2.通过&amp;运算符取地址; 3.通过”.”操作符访问成员. 结构之间不允许比较. 指向结构的指针定义123456789101112struct point&#123; // 声明一个结构 int x; int y;&#125;struct point *p; // 声明一个指向point结构类型的指针struct point tmp = &#123;1, 2&#125;; // 定义一个point结构类型的变量p = &amp;tmp; // 通过取地址符&amp;使p指向tmp变量int y = (*p).x + 1; // 通过指针操作结构成员的写法(注意: 结构成员运算符“.”的优先级比“*”的优先级高,因此括号必须存在) // 此时y的值为2y = p-&gt;x + 1; // 通过指针操作结构成员的简写方法. // 此时y的值为3 扩展 由于”.”(用于结构体),”-&gt;”(用于结构体),”[]”(用于下标),”()”(用于函数调用)的操作符优先级是最高的,因此在不熟悉时可能对语句的结果判断失误,因此,最好使用括号来显式定义操作顺序. 12345678910111213141516171819// 优先级的示例#include &lt;stdio.h&gt;int main(void)&#123; struct point&#123; int *s; &#125;; int z = 0; struct point tmp = &#123;&amp;z&#125;; struct point *p = &amp;tmp; int r = *p++-&gt;s; // 这个语句的含义是: 先读取p指向的结构体中的str指针所指向的值对象(即z)的值,然后再将p加1 printf("%d\n", r); // 此时的r的值为0&#125; 结构体中可以嵌套指针(包括指向自身类型的指针). 12345678// 结构体中嵌套自身类型的指针示例struct office&#123; int chair; int computer; struct office *o; // 结构体中嵌套指向本类型的指针&#125;;struct office o1 = &#123;10, 10, NULL&#125;; // 使用空指针进行初始化struct office o2 = &#123;10, 10, &amp;o1&#125;; // 使用正常的指向某个结构实例的指针进行初始化 结构数组声明1234567891011121314// 变量数组的声明与初始化(以下两种声明方式是等价的)// 先声明结构体,再声明结构体数组struct point &#123; int x; int y;&#125;;struct point p_array[2];// 声明结构体的同时声明数组struct point &#123; int x; int y;&#125; p_array[2]; 初始化1234567891011121314// 结构体数组的初始化// 精确的做法,将每一行(即每个结构)的初值都括在花括号内进行初始化struct point p_array[2] = &#123; &#123;1, 2&#125;, &#123;3, 4&#125;&#125;;// 简单做法,在定义的后面通过一个用圆括号括起来的初值表进行初始化// 即: 如果初值是简单变量或字符串,并且其中的任何值都不为空,则内层的花括号可以省略struct point p_array[2] = &#123; 1, 2, 3, 4&#125;;// 同普通数组一样,如果初值存在并且方括号[ ]中没有数值,编译程序将自动计算数组 p_array 中的项数. 扩展 C语言提供了一个编译时(compile-time)一元运算符sizeof,可用来计算任一对象的长度. 表达式 sizeof 对象 以及 sizeof(类型名) 将返回一个整型值(严格地说,返回值是无符号整型值,其类型为 size_t),它等于指定对象或类型占用的存储空间字节数. 12345678910111213141516171819202122232425262728293031323334// sizeof的用法#include&lt;stdio.h&gt;int test(void)&#123; printf("%s", "exec"); // 这里并不会被执行 return 1;&#125;;struct point&#123; int x; int y;&#125;;struct special&#123; int x; char y;&#125;;int main()&#123; struct point p = &#123;1, 2&#125;; struct special sp = &#123;1, 'x'&#125;; struct point *p_p = &amp;p; int tmp_array[] = &#123;1, 2, 3&#125;; printf("%ld", sizeof tmp_array); // 当sizeof的对象是数组时,返回数组总大小. printf("%ld", sizeof p_p); // 当对象是指针时,返回指针本身的大小,而不是指示内存空间的大小. printf("%ld", sizeof p); // 一般而言,结构体的大小为所有元素的大小之和. printf("%ld", sizeof(sp)); // 然而,由于需要对齐,因此实际长度可能会有变化. printf("%ld", sizeof(1+1)); // 对象是表达式时,求的大小是表达式返回值的类型大小,但并不计算表达式的值. printf("%ld", sizeof(test())); // 如果对象是函数,则返回函数返回值类型大小,不实际执行,因此函数中的输出并不会出现. printf("%ld", sizeof(int)); // 作用于类型时,返回该类型所占空间大小. printf("%ld", sizeof("123")); // 由于字符串结尾总有一个'\0',因此计算空间时会比实际长度大一. return 0; // 结果为: 12 8 8 8 4 4 4 4&#125; 不同的对象有不同的对齐要求,所以,结构中可能会出现未命名的“空穴“(hole). 通过使用sizeof可以很容易的算出数组中元素的个数. 条件编译语句 #if 中不能使用sizeof,因为预处理器不对类型名进行分析.但预处理器并不计算 #define 语句中的表达式,因此,在#define中使用sizeof是合法的. 12345678910111213// 利用sizeof求数组元素个数的方法int tmp[] = &#123;1, 2, 3&#125;;// 1. 数组的长度除以单个元素的长度int length = sizeof(tmp) / sizeof(int);// 2. 数组的长度除以指定元素的长度int length = sizeof(tmp) / sizeof(sizeof(tmp[0]));// 一个利用sizeof求数组长度的宏定义#define ARR_LEN(x) (sizeof(x) / sizeof(x[0])) C语言提供了一个称为 typedef 的功能,它用来建立新的数据类型名. 从任何意义上讲,typedef 声明并没有创建一个新类型,它只是为 某个已存在的类型增加了一个新的名称而已.typedef声明也没有增加任何新的语义,即通过这种方式声明的变量与通过普通声明方式声明的变量具有完全相同的属性. 优点:1.可以使程序参数化,以提高程序的可移植性(如果typedef声明的数据类型同机器有关,那么当程序移植到其它机器上时,只需改变typedef类型定义就可以了);2.通过使用更恰当的名称为程序提供更好的说明性. 123456typedef int Length; // 给int一个别名LengthLength x = 0; // 相当于 int x = 0;typedef struct tnode &#123; char *word; struct tnode *right;&#125; Treenode; // 复杂声明 联合概念 联合(union)是可以(在不同时刻)保存不同类型和长度的对象的变量,由编译器负责跟踪对象的长度和对齐要求. 联合提供了一种方式,以在单块存储区中管理不同类型的数据,而不需要在程序中嵌入任何同机器有关的信息(通过使用联合,一个变量可以合法地保存多种数据类型中任何一种类型的对象). 定义方式1234567// 使用联合的场景示例: 假设一个常量可能是int,f1oat或字符指针.// 若该常量的不同类型占据相同大小的存储空间,且保存在同一个地方的话,使用将最方便.通过将该常量定义为联合可以实现.union u_demo &#123; int ival; float fval; char *sval;&#125; u; // 变量u必须足够大,以保存这3种类型中最大的一种,具体长度同具体的实现有关. 使用 同结构类似,可以使用 联合名.成员 或 联合指针-&gt;成员 的方法来访问联合中的成员. 读取的类型必须是最近一次存入的类型.由程序员负责跟踪当前保存在联合中的类型,如果保存的类型与读取的类型不一致,其结果取决于具体的实现. 联合只能用其第一个成员类型的值进行初始化. 实际上,联合就是一个结构,它的所有成员相对于基地址的偏移量都为0.对联合允许的操作与对结构允许的操作相同:作为一个整体单元进行赋值、复制、取地址及访问其中一个成员. 1234567891011121314151617181920212223242526272829303132333435363738#include &lt;stdio.h&gt;// 定义宏来标识当前union变量的类型#define INT 1#define CAHR 2// 定义union类型union u_d&#123; char y; int x;&#125;;// 通过校验当前union变量的类型来进行针对性处理(这里是输出)// 以下两个带注释行的用法是不规范的,很可能得不到预期的结果void print_u_demo(union u_d u, int u_type)&#123; if (u_type == INT)&#123; printf("%d\n", u.x); printf("%c\n", u.y); // 这里会输出 u.x 对应的 ASCII 字符 &#125; else if (u_type == CAHR)&#123; printf("%d\n", u.x); // 这里不能得到有意义的输出 printf("%c\n", u.y); &#125; else&#123; printf("bad type %d in utype\n", u_type); &#125;&#125;int main()&#123; int u_type = 0; // 用变量来记录结构成员当前的类型 union u_d u = &#123;'A'&#125;; // 使用第一个成员类型来初始化 u_type = CAHR; print_u_demo(u, u_type); u.x = 100; u_type = INT; print_u_demo(u, u_type); return 0;&#125; 内存模型 union变量占用的内存等于最长的成员占用的内存.本质上只是对一段大内存的不同解读方式.如下图所示: 位字段背景 在存储空间很宝贵的情况下,有可能需要将多个对象保存在一个机器字中(机器字指计算机一次能处理数据的bit位数). 一种常用的方法:使用类似于编译器符号表的单个二进制位标志集合. 1234567891011121314151617181920212223// 使用一个char或int对象中的位标志集合来标识一个对象的属性的示例// 这里使用int型变量来标识某标识符的特定信息的集合.int flags;// 定义一个与相关位的位置对应的"屏蔽码"的集合,其中的每一个元素代表一种属性// 这些数字必须是2的幂.这样,访问这些位就变成了用移位运算、屏蔽运算及补码运算进行简单的位操作// 使用宏定义#define KEYWORD 01#define EXTRENAL 02#define STATIC 04// 使用枚举定义enum &#123; KEYWORD = 01, EXTERNAL = 02, STATIC = 04 &#125;;// 为该标识符的属性设值flags |= EXTERNAL | STATIC;// 判断该标识符是否有特定属性if ((flags &amp; (EXTERNAL | STATIC)) == 0)&#123; doSomething();&#125; C语言语法层面的支持 这种做法的本质是利用一位来存储一种信息,但是每种信息只能有简单的 是/否 概念.这样就在很大限度上减少了内存使用,并且判断效率也很高.至于使用什么方法来实现这种思路就无关紧要了. 也许是C语言中类似的做法很多.因此,它在语法层面为这种操作提供了支持.即:位字段(位域). 位字段允许我们定义一个由位组成的段,并可为它赋以一个名字.通过这种方式可以更高效的利用内存. 123456789101112131415161718192021222324252627282930313233343536// 位字段的声明// 位字段只能定义为 int, signed int, unsigned int中的一种struct &#123;unsigned int is_keyword : 1; // 冒号“:”后的数字为该位字段所占的bit位数unsigned int : 1; // 可以使用无名字段来占位,仅起填充作用,该字段所在的位不能被使用unsigned int : 0; // 0字段,不实际占用位,仅起标记作用(下一个位字段在下一个字边界开始).unsigned int is_static : 1;&#125; flags;// 位字段的访问// 位字段没有独立的地址,不能进行取址操作// 位字段没有独立的存储空间,不能进行sizeof()操作flags.is_keyword// 内存分配// 规则: 1.位字段按声明顺序在机器字内存储; // 2.位字段不能跨越机器字存储,上一个机器字空间不足时,该位字段将全部存到下一个机器字// 假设当前机器是32位struct &#123; unsigned int a :20; unsigned int b : 6; unsigned int c : 2;&#125;demo; // 20+6+2 &lt; 32, 故可在1个机器字内存储struct &#123; unsigned int d :20; unsigned int e :6; // 32 -（20+6）= 6, 该机器字剩余6bit unsigned int f :20; // 6bit不够存储f,则f将在下一个机器字边界开始存储&#125;flagscopy; //整体来看, 20+6+20&gt;32 故需在2个机器字内存储struct &#123; unsigned int g : 1; unsigned int : 0; unsigned int h : 1; // 由于前面是一个0字段标记,因此h将在下一个机器字边界开始存储&#125;]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(3)]]></title>
    <url>%2F2018%2F03%2F21-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(3).html</url>
    <content type="text"><![CDATA[前言 以下记录了第五章的一些知识点. 指针概念语义 一般来说,内存可以看作是一系列连续编号或编址的存储单元,我们将不可再分的最小单位定义为位(bit,一个位大小的内存中只能存储0/1两种状态之一).我们可以将一些信息转化为二进制(0/1的序列)进行存储,这就是编码. 在第一个较通用的编码表ASCII编码诞生后,我们将其中能存储一个英文字符的空间称为一字节(Byte),其中,1Byte=8bit. 而一般把存储器中的一个字节(Byte)称为一个内存单元.如果我们将这些存储单元看作有序的(例如,按照物理顺序排序),那么就可以用某个值表示每一个内存单元的地址,又由于字节大小是固定的,因此我们可以通过记录某字节在这个字节序列中的位置来计算位置,也就是说,这个位置信息可以等价为内存单元的地址. 我们将某个内存单元A的地址(也就是位置信息)也存储到内存单元B(也可能是一组内存单元)之后,就可以通过取出B单元的信息来计算出A的地址,从而间接的取出A的信息.其中,B中的值被称为A的地址,B被称为指针. 也就是:指针是能够存放一个地址的一组存储单元. 语法 1.ANSI C使用类型void (指向 void的指针)代替在原来使用char 作为通用指针的类型. 也就是说:任何类型的指针都可以转换为 oid 类型，并且在将它转换回原来的类型时不会丢失信息; 2.在C语言中,通过一元运算符&amp;来取某变量的地址.又由以上推导可得:地址运算符&amp;只能应用于内存中的对象,即变量与数组元素.它不能作用于表达式,常量或register类型的变量; 3.一元运算符是间接寻址或间接引用运算符.当它作用于指针时,将访问指针所指向的对象; 4.为了安全,指针只能指向某种特定类型的对象.也就是说,每个指针都必须指向某种特定的数据类型; 5.由于指针也是变量,所以在程序中可以直接使用,而不必通过间接引用的方法使用; 6.对指针有意义的初始化值只能是空(NULL/0)或者是表示地址的表达式(表达式所代表的地址必须是在此前已定义的具有适当类型的数据的地址). 12345678910111213int x = 1;int *y = &amp;x, *z; // 定义一个指向变量x的内存地址的指针yvoid *p = &amp;x; // void* 类型的变量可以作为通用指针z = y; // 指针可以直接使用int *t = NULL; // 指针定义时,可以指向NULL/0.此时,它被称为 空指针.int *u = 0;// 指针数组初始化// name数组中的每个元素都是一个指针,它指向某一个字符串常量(该常量存在于内存中的某个位置).char *name[] = &#123; "January", "February", "March", "April", "May", "June", "July", "August", "September", "October", "November", "December"&#125;; 应用场景指针与函数参数 将指针作为参数的优点: 1. 指针参数使得被调用函数能够访问和修改主调函数中对象的值; 2. 在函数需要返回多种不同含义的值时,可以利用指针参数进行接收. 123456789101112131415161718192021222324252627// 当is_valid函数返回1时,输出为:swap success,当is_valid函数返回0时,输出为swap fail.#include &lt;stdio.h&gt;int is_valid(int *x)&#123; // 这里虚构is_valid函数进行参数检查,它的返回值表示参数是否合法 return 1;&#125;int swap(int *x, int *y)&#123; //这里的swap函数实现了如下功能:1.修改交换传递的参数的值;2.通过返回值标识了交换是否成功 if (!(is_valid(x) &amp;&amp; is_valid(y)))&#123; return 0; &#125; int temp = *x;; *x = *y; *y = temp; return 1;&#125;int main(void)&#123; int x = 1, y = 2; if (swap(&amp;x, &amp;y))&#123; printf("%s", "swap success"); &#125; else&#123; printf("%s", "swap fail"); &#125; return 0;&#125; 指针与数组 通过查询维基百科可以得到:数组(Array)是由相同类型的元素(element)的集合所组成的资料结构,分配一块连续的内存来存储.很容易联想到:若数组A中存在多个元素,那么其中某个元素b的地址可以在首元素地址的基础上,通过位移(指针运算)来得到.而根据定义,数组类型的变量或表达式的值即是该数组第0个元素的地址.因此有: A[i]与*(A+i)是等价的,即通过数组和下标实现的表达式可等价地通过指针和偏移量实现.且若确信相应的元素存在,也可以通过下标访问数组第一个元素之前的元素(即i可以为负数). 指针是一个变量,而数组名并不是变量(它是常指针).因此可以为指向数组的指针重新赋值,而不可以更改数组名所指向的地址(即不能更改A的值). 一般来说,用指针编写的程序比用数组下标编写的程序执行速度快,但另一方面,用指针实现的程序理解起来稍微困难一些. 当把数组名传递给一个函数时,实际上传递的是该数组第一个元索的地址.由于在被调用函数中,该参数是一个局部变量,因此,数组名参数必须是一个指针,也就是一个存储地址值的变量. C语言规范保证,0永远不是有效的数据地址.因此,可以返回地址0来表示发生了异常事件. 123456int* test(int x)&#123; if (x &gt; 0)&#123; return &amp;x; // 正常情况 &#125; return 0; // 用0来表示异常情况&#125; 字符指针与函数 字符串常量是一个数组(字符数组),因此字符串常量可通过一个指向其第一个元素的指针访问. 将字符串常量作为参数时,实际是传递了字符指针,函数中是通过使用这个指针来访问字符串常量.C语言没有提供将整个字符串作为一个整体进行处理的运算符. 12345char amessage[] = "now is the time"; // 定义一个数组// amessage 是一个仅仅足以存放初始化字符串以及空字符'\0'的一维数组.其中作为数组名的amessage是一个常指针,它始终指向该内存区域.然而,数组中的单个字符可以进行修改.char *pmessage = "now is the time"; // 定义一个指针// 在字符串的内部表示中,字符数组以空字符'\0'结尾.// pmessage是一个指针,其初值指向一个字符串常量.它的值可以被修改(可以指向不同的位置).但这个字符串常量不能被改变(结果未定义). 123// 进栈和出栈的标准用法*p++=val; // 将val压入栈val=*--p; // 将栈顶元素弹出到val中 指针数组12345678910//指针数组的声明char *lineptr[10]; // lineptr是一个具有10个元素的一维数组, 其中数组的每个元素都是一个指向字符类型对象的指针.// 注意, lineptr是一个常指针// 指针数组的初始化char *name[] = &#123; "Illegal month", "January", "February", "March", "April", "May", "June", "July","August", "September", "October", "November", "December"&#125;// 说明: name数组的初始化通过一个字符串列表实现，列表中的每个字符串赋值给数组相应位置的元素. 第i个字符串的所有字符存储在存储器中的某个位置, 指向它的指针存储在name[i]中. 由于上述声明中没有指明name的长度, 因此, 编译器编译时将对初值个数进行统计, 并将结果填入数组的长度. 二维数组 在C语言中,二维数组实际上是一种特殊的一维数组,即:它的每个元素也是一个一维数组. 一般来说,除数组的第一维(下标)可以不指定大小外,其余各维都必须明确指定大小.初始化时,没有指定的元素会被默认初始化. 一般来说,二维数组在内存中也是按照一维数组的形式排列的.在C语言中,二维数组是按行排列的. 二维数组(多维数组)中每一个一维数组的长度是固定的,而指针数组的每一行长度(该指针指向的元素的大小/数组的长度)可以不同. 指针数组最频繁的用处是存放具有不同长度的字符串. 12345678910111213141516171819202122232425// 二维数组的声明与定义// 按行分段赋值int daytab[2][12] = &#123; &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;// 上述声明的第一维大小的定义可以省略,即int daytab[][12] = &#123; &#123;31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;, &#123;31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;&#125;;// 按行连续赋值int daytab[2][12] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;// 同理int daytab[][12] = &#123; 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31, 31, 29, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31&#125;;// 访问二维(多维)数组中某元素// 实际是通过常规的矩阵下标计算公式 n×row+col(其中,n表示每一个一位数组的长度,row表示行下标,col表示列下标)计算得到元素 array[row][col]的位置int tmp = daytab[0][1]; // 此时,tmp的值为28 函数指针 在C语言中,函数本身不是变量.但我们可以定义指向函数的指针,这种指针被称作函数指针. 声明格式: 类型说明符 (*函数名)(参数), 示例如下: 123/* 函数指针的声明 */ int (* sort)(int, int);// 这里的sort更恰当的说应该叫做函数指针的变量名.这个特殊的指针指向一个接收两个int型变量,并返回整型值的函数 调用格式: (*func)(params…) / func(params…) 123456789101112131415161718192021222324252627/* 函数指针的赋值与调用示例 */#include &lt;stdio.h&gt;void test(); // 声明一个函数void test_test(void (* t)(void))&#123; // 参数声明为函数指针 printf("hahah "); t(); // 通过传入的函数指针对函数进行调用&#125;int main(void)&#123; void (*tmp)(); // 声明一个函数指针 tmp = test; // 初始化函数指针 tmp(); // 调用方法一 (*tmp)(); // 调用方法二 test_test(tmp); // 将函数指针作为参数传递&#125;void test()&#123; static int x = 1; // 声明静态变量 printf("%s%d ", "test", x); // 通过打印静态变量来直观表示打印次数 x += 1;&#125;// 输出: test1 test2 hahah test3&#125; 指针的运算 指针与整数之间不能相互转换.0是惟一的例外:常量0可以赋值给指针,指针也可以和常量0进行比较.程序中经常用符号常量NULL(定义在标准头文件&lt;stddef.h&gt;中)代替常量0. 指针的运算: 1.如果指针p和q指向同一个数组的成员,那么它们之间就可以进行类似于==、!=、&lt;、&gt;=的关系比较运算。这里实际比较的是它们的位置关系(数组下标的大小); 2.任何指针与0进行相等或不等的比较运算都有意义,用来校验当前指针是否是空指针; 3.如果p和q指向相同数组中的元素,且 p&lt;q ,那么 q-p+1 就是位于 p和q 指向的元索之间的元素的数目; 4.指针可以和整数进行相加或相减运算.例如: p为指针,则 p+n 表示指针p当前指向的对象之后第n个对象的地址.具体计算时,n将根据p指向的对象的长度按比例缩放,而p指向的对象的长度则取决于p的声明. 5.相同类型指针之间的赋值运算是合法的,void* 类型的指针与其它指针的赋值运算是合法的; 6.指针的算术运算中指向不同数组元素之间的运算没有定义,但是可以使用数组最后一个元素的下一个元素的地址(这个地址可以赋给指向数组元素的指针,但仅允许它进行赋值或比较运算,不能对保存这个地址的指针进行解引用或下标运算). 123456789101112131415int tmp[] = &#123;1, 2, 3, 4, 5, 6, 7&#125;;int *x = tmp + 1; // x指向2int *y = tmp + 4; // y指向5int *p = &amp;tmp[7]; // 数组tmp最后一个元素的下一个元素的地址int z = p - y; // 可以使用p进行运算,此时z的值为p与y下标的距离3z = x &lt; y; // z的值为1z = x == 0; // z的值为0z = x != 0; // z的值为1x = y + 1; // x现在指向y所指元素的后一个元素,即6y = z; //赋值操作void* p = y; // 赋值操作 特殊命令行参数 在支持C语言的环境中, 可以在程序开始执行时将命令行参数传递给程序. C语言中的参数约定如下: main函数的第一个参数argc的值表示运行程序时命令行中参数的数目; 第二个参数argv是一个指向字符串数组的指针，数组中的每个字符串对应一个参数.另外，ANSI标准要求argv[argc]的值必须为一个空指针. 图示如下: 扩展:UNIX系统中的C语言程序有一个公共的约定:以负号开头的参数表示一个可选标志或参数.例如: ls -l 这样的shell命令.实现: 通过校验argv所指向的数组中的某个字符串是否以’-‘开头,再在这个基础上通过switch来得到其后跟随的字符,并进行特殊处理.]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(2)]]></title>
    <url>%2F2018%2F02%2F04-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(2).html</url>
    <content type="text"><![CDATA[前言 以下记录了第三章及第四章的一些知识点. 语句 在表达式之后加上一个分号(;),它们就变成了语句; 12// 语句int x; 用一对花括号“{”与“}”把一组声明和语句括在一起就构成了一个复合语句(也叫作程序块), 复合语句在语法上等价于单条语句; 12345// 复合语句&#123; int x = 1; x += 1;&#125; 建议在有语句嵌套的情况下使用花括号来显式定义匹配关系; switch语句中, default分支是可选的,如果没有 default 分支也没有其它分支与表达式的值匹配,则该switch语句不执行任何动作。在switch 语句中,case的作用只是一个标号,而break/return语句才会使程序的执行立即从switch语句中退出; 1234567891011121314151617// switch语句// 注: 中括号，表示此语句可以没有switch (表达式) &#123; case 常量表达式1: 语句1; // 可以是多条语句，可以加括号，也可以不加，到下一个case之前，都是本case的语句范围 [break;] case 常量表达式2: 语句2; [break;] .... case 常量表达式n: 语句n; [break;] [default：] 语句n+1; [break;]&#125; break语句可用于从for、while与do-while等循环中提前退出,continue语句用于使for、while或do-while语句开始下一次循环的执行; goto语句可以与标号配合进行程序的任意跳转功能。标号的命名同变量命名的形式相同,标号的后面要紧跟一个冒号。标号可以位于对应的goto语句所在函数的任何语句的前面。标号的作用域是整个函数; 12345678910111213141516// goto语句示例int main(void)&#123; int i, j; for (i = 0; i &lt; 10; i++)&#123; printf( "Outer loop executing. i = %d\n", i ); for (j = 0; j &lt; 3; j++)&#123; printf( " Inner loop executing. j = %d\n", j ); if ( i == 5 ) goto stop; // 进行跳转 &#125; &#125; /* This message does not print: */ printf( "Loop exited. i = %d\n", i ); stop: printf( "Jumped to stop. i = %d\n", i ); // 定义标号 return 1;&#125; 函数 在函数中可以通过return语句返回一个值,如果没有显式声明返回值类型,则返回值类型为int.此外,在任何情况下,如果函数没有成功地返回一个值,则它的“值”肯定是无用的; 123456// 函数返回值样例int func_demo(void)&#123; int x = 1; return x; printf("%s", "这条语句不会被执行.");&#125; 123456789// 未定义返回值的情况下,函数的值xx()&#123;&#125;int main(void)&#123; int x = xx(); printf("%d", x); // 结果是0 return 0;&#125; 函数的声明与定义必须一致.如果某函数与调用它的主函数放在同一源文件中,并且类型不一致,编译器就会检测到该错误。但是,如果被调用函数是单独编译的(这种可能性更大),这种不匹配的错误就无法检测出来，出现错误的几率会很大; 如果没有函数原型,则函数将在第一次出现的表达式中被隐式声明.如果先前没有声明过的一个名字出现在某个表达式中,并且其后紧跟一个左圆括号,那么上下文就会认为该名字是一个函数名字,该函数的返回值将被假定为int类型,且上下文并不对其参数作任何假设,即很可能会取到错误的返回值; 1234567891011121314151617// 类型检查错误且函数解析错误的样例// demo.c#include &lt;stdio.h&gt;char* xx(void)&#123; return "lalala";&#125;// demo2.c#include &lt;stdio.h&gt;int main(void)&#123; int x = xx(1); printf("%d %s", x, "啦啦啦"); return 0&#125; 1234# 以如下命令进行编译,会产生warning(而不是error)gcc demo.c demo2.c -o la# 以如下命令对二进制文件进行执行,控制台的输出为 4195868 啦啦啦./la 变量 C语言程序可以看成由一系列的外部对象构成, 这些外部对象可能是变量或函数.由于函数内不允许定义函数,因此函数天生是外部对象.那么外部变量就可以认为是定义在所有函数之外的变量,同函数一样,全局共享一个实例.与此相对应,内部变量(自动变量)即为定义在函数内部的变量; 12345678# include &lt;stdio.h&gt;int x = 1; // 外部(全局)变量int main(void)&#123; int y = 1; // 内部(自动)变量 printf("%d", x + y); return 0;&#125; 构成C语言程序的函数与外部变量可以分开进行编译。一个程序可以存放在几个文件中,原先已编译过的函数可以从库中进行加载; 外部变量或函数的作用域从声明它的地方开始,到其所在的(待编译的)文件的末尾结束.如果要在外部变量的定义之前使用该变量,或者外部变量的定义与变量的使用不在同一个源文件中,则必须在相应的变量声明中强制性地使用关键字 extern; 1234567891011/*外部变量定义与使用分离 及 内部变量默认初始化 的栗子*/// demo.c#include &lt;stdio.h&gt;int main(void)&#123; extern int x; printf("%d", x);&#125;// demo2.cint x = 100; 1234# 以如下命令进行编译,会产生warning(而不是error)gcc demo.c demo2.c -o la# 以如下命令对二进制文件进行执行,若有x有extern定义则控制台的输出为100,若没有则控制台输出为0./la 变量声明用于说明变量的属性(主要是变量的类型),而变量定义除此以外还将引起存储器的分配.在一个源程序的所有源文件中,一个外部变量只能在某个文件中定义一次,而其它文件可以通过extern声明来访问它(定义外部变量的源文件中也可以包含对该外部变量的extern声明).外部变量的定义中必须指定数组的长度,但 extern 声明则不一定要指定数组的长度.外部变量的初始化只能出现在其定义中; 当源文件个数很多时,变量/函数的定义位置并不是那么容易找到,很容易造成混乱.为了解决这个问题,可以将定义与实现分离,即使用头文件进行定义的集中管理,而将实现分散在各个文件中.通过这种机制,可以减少变化时错误的产生几率; 123456789101112131415/*上面的栗子,通过使用头文件来将共享的部分集中在一起之后变为如下形式,可以去除变量x的声明很自然的...如果某个包含文件的内容发生了变化,那么所有依赖于该包含文件的源文件都必须重新编译*/// 在文件test.h中int x = 100;//在文件 demo1.py 中#include &lt;stdio.h&gt;# include "test.h"int main(void)&#123; printf("%d", x);&#125; 被static限定符声明的外部变量与函数的作用域被限定为被编译源文件的剩余部分,通过此修饰符可以实现隐藏外部对象的目的.而被static限定的内部变量则只能在该函数中使用但一直占据存储空间,且只在第一次进入程序块时被初始化一次; 123456789101112131415161718// static变量的栗子, 五次输出值均为14#include &lt;stdio.h&gt;#include "test.h"int test(int x)&#123; static int y = 10; int tmp = x + y; y += 1; return tmp;&#125;int main(void)&#123; int times = 5; while(times-- &gt; 0)&#123; printf("%d", test(times)); &#125; return 0;&#125; register声明告诉编译器,它所声明的变量在程序中使用频率较高,因此建议将此变量放入寄存器中以使程序更小、执行速度更快(编译器可以忽略此建议).register声明只适用于自动变量以及函数的形式参数.同时,无论寄存器变量实际上是不是存放在寄存器中,它的地址都是不能访问的; 变量初始化 1.在不进行显式初始化的情况下,外部变量和静态变量都将被初始化为 0,而自动变量和寄存器变量的初值则没有定义(即初值为无用的信息); 2.定义标量变量时,可以在变量名后紧跟一个等号和一个表达式来初始化变量; 3.对于外部变量与静态变量来说,初始化表达式必须是常量表达式,且只初始化一次(从概念上讲是在程序开始执行前进行初始化); 4.对于自动变量与寄存器变量,初始化表达式可以不是常量表达式:可以包含任意在此表达式之前已经定义的值,包括函数调用.且在每次进入函数或程序块时都会初始化; 5.对于数组. (a)初始化表达式列表用花括号括起来,各初始化表达式之间通过逗号分隔. (b)若初始化表达式元素个数比数组元素数少,则对外部变量、静态变量和自动变量来说,没有初始化表达式的元素将被初始化为0,如果初始化表达式的个数比数组元素数多,则会产生编译错误. (c)不能一次将一个初始化表达式指定给多个数组元素,也不能跳过前面的数组元素而直接初始化后面的数组元素; (d)对于字符数组.可以用一个字符串来代替用花括号括起来并用逗号分隔的初始化表达式序列. 预处理器总览 从概念上讲,预处理器是编译过程中单独执行的第一个步骤,大概有以下几种: 名称 符号 含义 文件包含预处理器 #include 将本行内容替换为path所指的文件的内容 宏替换预处理器 #define 将本文件中的 name(名字记号) 替换为 text(替换文本) 预处理器运算符 ## (配合#define使用) 一种连接实际参数的手段 条件包含 #if,#elif,#else,#endif,#ifdef,#ifndef 一种控制编译结果的手段 文件包含预处理器12345// 在系统目录查找#include &lt;stdio.h&gt;// 先在用户目录查找#include "test.h" (a)在源文件中,任何形如:#include “文件名”或#include &lt;文件名&gt; 的行都将被替换为由文件名指定的文件的内容.(b)如果文件名用引号引起来,则在源文件所在位置查找该文件.如果在该位置没有找到文件,或者如果文件名是用尖括号&lt;&gt;括起来的,则将根据相应的规则(可能是环境变量)查找该文件. 宏替换预处理器1234567891011// 常规版本#define XX 100// 带参数的版本(格式匹配)#define max(A, B) ((A) &gt; (B) ? (A) : (B))//使用#的版本#define dprint(expr) printf(#expr " = %g\n", expr)// 使用##的版本#define paste(front, back) front ## back (1)格式为#define 名字 替换文本 后续所有出现名字记号的地方都将被替换为替换文本;(2)#define 指令定义的名字的作用域从其定义点开始,到被编译的源文件的末尾处结束;(3)宏定义也可以带参数,这样可以对不同的宏调用使用不同的替换文本,最好使用括号指定层次关系;(4)可以通过#undef 指令在本文件中释放被宏定义的名字;(5)如果在替换文本中,参数名以#作为前缀则结果将被扩展为由实际参数替换该参数的带引号的字符串.即第三个示例的作用为: 将 dprint(x/y) 函数变为 printf(“x/y” “ = &amp;g\n”, x/y); 语句 亦即 printf(“x/y = &amp;g\n”, x/y);(6)##为宏扩展提供了一种连接实际参数的手段.如果替换文本中的参数与##相邻,则该参数将被实际参数替换,##与前后的空白符将被删除,并对替换后的结果重新扫描.即##用来将两个宏参数连接为一个宏参数.以上第四个例子的作用: 将 paste(name, 1) 转化为 name1 (宏调用 paste(name, 1)的结果将建立记号 name1)(7)一个长的#define语句可用反斜杠分成几行. 条件包含系列123456789101112131415161718192021#define X 1// 根据条件选择编译内容#if !defined(X) code#elif (X == 0) code1#elif X == 1 code2#else code3#endif// 简写#ifdef X code4#endif#ifndef X code5#endif (1)通过这种机制可以修改要被编译的代码.(2)#if 语句对其中的常量整型表达式(其中不能包含 sizeof、类型转换运算符或 enum 常量)进行求值,若该表达式的值不等于 0,则包含其后的各行,直到遇到#endif、#elif或#else语句为止.(3)在条件包含预处理器中可以使用表达式 defined(名字),该表达式的值遵循规则如下:当名字已经定义时,其值为 1;否则,其值为 0.(4)#ifdef与#ifndef是一种简写,用来测试某个名字是否已经定义并执行相应语句. #ifdef的使用和#if defined()的用法一致 #ifndef又和#if !defined()的用法一致(5)最后要使用#endif标识判断结束.]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[C语言复习笔记(1)]]></title>
    <url>%2F2018%2F01%2F24-C%E8%AF%AD%E8%A8%80%E5%A4%8D%E4%B9%A0%E7%AC%94%E8%AE%B0(1).html</url>
    <content type="text"><![CDATA[前言 前段时间在看一本书叫做《Python源码剖析》,但是发现在很多分析具体实现的地方看不懂.尤其是struct和指针部分,因此决定重温一下C语言的语法. C语言是我接触的第一门编程语言,刚开始学习时,什么都不懂,学校的课本也是写的乱七八糟,因此在网上搜了一下,找到了《C Primer Plus》这本书,然而当时学习是为了应付考试,因此只是学习到文件读写部分就没有继续了,现在想想甚为可惜… 由于有了一定的基础,因此本次复习选择的书是比较简洁的《The C Programing Language(中文版)》,在学习的过程中,会将一些个人认为比较重要的知识点记录下来供以后参考. 以下记录了第1-2章的一些知识点。 拾遗 main是一个特殊的函数名——每个程序都以main函数为起点开始执行,这意味着每个程序都必须在某个位置包含一个main函数; 在允许使用某种类型变量值的任何场合,都可以使用该类型的更复杂的表达式; 赋值操作是一个表达式,并且具有一个值,即赋值后左边变量保存的值; 即: (x = 1) == 1 在关系表达式或逻辑表达式中,如果关系为真,则表达式的结果值为数值 1; 如果为假,则结果值为数值 0; 函数原型中的参数名是可选的,只需标明类型即可; 即: 形如 int test(int, int); 的函数声明是合法的 在 C 语言中,所有函数参数都是“通过值”传递的.在被调用的函数中,参数可以看作是快速初始化的局部变量; 函数中的每个局部变量只在函数被调用时存在,在函数执行完毕退出时消失; 外部变量声明方式: (1) 定义在所有函数之外; (2) 通过extern关键字定义. 注: a.外部变量只能定义一次; b.在源文件中,如果外部变量的定义出现在使用它的函数之前, 那么在那个函数中就没有必要使用extern声明(接上面的a,即a的本质),因此在通常的做法中,所有外部变量的定义都放在源文件的开始处,这样就可以省略extern声明; “定义”表示创建变量或分配存储单元,而“声明”指的是说明变量的性质,但并不分配存储单元。 摘抄 声明语句说明变量的名字及类型,同时也可以指定变量的初值。 运算符指定将要进行的操作。 表达式把变量与常量组合起来生成新的值。 对象的类型决定该对象可取值的集合以及可以对该对象执行的操作。 变量命名规范: 变量名是由字母和数字组成的序列,但其第一个字符必须为字母.其中下划线“_”被看做是字母.一般变量用小写字母,常量用大写字母. 基本数据类型及限定符基本数据类型: 关键字 解释 char 字符型,占用一个字节,可以存放本地字符集中的一个字符 int 整型,通常反映了所用机器中整数的最自然长度 float 单精度浮点型 double 双精度浮点型 限定符: 关键字 解释 short 用于限定整型 eg: short int x —&gt; short x long 用于限定整型 eg: long int x —&gt; long x signed/unsigned 用于限定整型,代表是否可以有负值 关于类型所占用位数的规定: short 与 int 类型至少为 16 位; long 类型至少为 32 位; short类型不得长于 int 类型,而 int 类型不得长于 long 类型; long double 类型表示高精度的浮点数. 常量 字符常量 一个字符常量是一个整数,书写时将一个字符括在单引号中即可.如’x’字符在机器字符集中的数值就是该字符常量的值; 字符串常 从技术角度看,字符串常量就是字符数组.其中字符串的内部表示使用一个空字符’\0’作为串的结尾.因此存储字符串的物理存储单元数比括在双引号中的字符数多一个； 枚举常量 枚举是一个常量整型值的列表.在没有显式定义的情况下,enum 类型中第一个枚举名的值为 0,第二个为 1…, 如果指定了其中部分枚举名的值,那么未指定值的枚举名的值将依着最后一个指定值向后递增. 规定: 不同枚举中的名字必须互不相同。同一枚举中不同的名字可以具有相同的值. 意义: 枚举为建立常量值与名字之间的关联提供了一种便利的方式. 常量定义 常量可以通过const修饰符 或者 宏定义来实现. 变量声明 声明表达式 在声明中,如果变量名的后面紧跟一个等号以及一个表达式,该表达式就充当对变量进行初始化的初始化表达式 例如: int x; int x = 1; 变量的默认初始化 如果变量不是自动变量,则只能进行一次初始化操作,从概念上讲,应该是在程序开始执行之前进行,并且初始化表达式必须为常量表达式。 每次进入函数或程序块时,显式初始化的自动变量都将被初始化一次,其初始化表达式可以是任何表达式。默认情况下,外部变量与静态变量将被初始化为0。未经显式初始化的自动变量的值为未定义值(即无效值) const限定符 任何变量的声明都可以使用 const限定符限定。此限定符指定变量的值不能被修改,对数组而言,const限定符指定数组所有元素的值都不能被修改. const 限定符也可配合(数组)参数使用,它表明函数不能修改(数组元素)参数的值 例如: int strlen(const char[]) 与 int test(const int a) 运算符与表达式 简单分类 示例 注意 二元运算符 +, -, *, /, %, &amp;, /执行的是整除(即地板除法,只留整数) 关系运算符 &gt;, &gt;=, &lt;, &lt;= 运算结果是 0/1 相等性运算符 ==, != 运算结果是 0/1 逻辑运算符 &amp;&amp;, &#124;&#124; 短路机制 一元运算符 !, ++, – ++,–位置影响 强制类型转换运算符 () 位操作运算符 &amp;, &#124;, ^, &lt;&lt;, &gt;&gt;, ~ 可以简单认为作用于二进制 三元运算符 : ? 示例: z = (a&gt;b) ? a: b 等价于 if (a &gt; b){ z = a;} else {z = b;} 赋值运算符 op= 某些赋值表达式的缩写 逗号运算符 , 优先级最低 补充 赋值表达式:如果 expr1 和 expr2 是表达式,那么赋值表达式 expr1 = (expr1) op (expr2)等价于:expr1 op= expr2其中op可以为+,-,*,/,%,&lt;&lt;,&gt;&gt;,|,^,&amp; 之一.则op=可以称为赋值运算符.同赋值表达式一样, 赋值运算符的类型是它的左操作数的类型,其值是赋值操作完成后的值.逗号运算符:被逗号分隔的一对表达式将按照从左到右的顺序进行求值,语句的类型与值为表达式最右边的操作数的类型和值.某些情况下的逗号并不是逗号运算符,比如分隔函数参数的逗号,分隔声明中变量的逗号等,这些逗号并不保证各表达式按从左至右的顺序求值. 类型转换 1. 自动转换是指把’比较窄的’操作数转换为’比较宽的’操作数,并且不丢失信息的转换. 场景: (1)赋值表达式： 赋值运算符右边的值需要转换为左边变量的类型,左边变量的类型即赋值表达式结果的类型; (2)二元运算: 如果二元运算符的两个操作数具有不同的类型,那么在进行运算之前先要把“较低”的类型提升为“较高”的类型,且运算的结果为较高的类型(long double &gt; double &gt; float &gt; long &gt; int &gt; (char/short)) 注: char和short在参与运算时,会先转成int (3)函数调用: 在没有函数原型的情况下,char 与 short 类型都将被转换为 int 类型,float 类型将被转换为double 类型 2. 强制(手动)类型转换: 格式: (类型名)表达式 [这里用到了强制转化运算符] 示例: long x = 0.123; int y = (int)x; # y == 0 注意 1. C 语言没有指定同一运算符中多个操作数的计算顺序(&amp;&amp;、||、?: 和,运算符除外). 即: x = f() + g(); 语句中,f()可以在 g()之前计算,也可以在 g()之后计算 2. C 语言没有指定函数各参数的求值顺序 即: printf(“%d %d\n”, ++n, power(2, n)); 语句的结果取决于编译器的具体实现 3. ANSI C标准明确规定了所有对参数的副作用都必须在函数调用之前生效 4. 书中写到: 在任何一种编程语言中,如果代码的执行结果与求值顺序相关,则都是不好的程序设计风格. 本人对此持怀疑态度]]></content>
      <tags>
        <tag>学习之路</tag>
        <tag>C语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[重启博客记]]></title>
    <url>%2F2017%2F12%2F26-%E9%87%8D%E5%90%AF%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[我所在的公司为了保证迭代速度，因此在初期选用了功能强大的Django框架进行开发。因此目前公司后端所用到的技术大多是与Django能很好的合作的。Celery就是这样一个工具，可以使用它来进行一些异步处理。 为了能跟上公司技术进步的脚步，这段时间一直在看Celery与RabbitMQ的官方文档进行学习。然而，Flynnon的英语并不是很好….因此学习的很慢。 其实RabbitMQ还好，示例清楚明了，在跟着Tutorials走了一遍后，感觉对于它有什么作用，以及如何使用Python进行开发有了一定的了解。然而这一套在Celery这里就行不通了，看了很久都没弄懂它是怎么用的… 于是就通过百度搜索了一下Celery，在结果中看到了很多博主写的博客。虽然有很多纯粹是复制粘贴的，质量很差，但是也有不少质量很高的博客，使我茅塞顿开。 在这个过程中就萌生了写一些东西的想法，其实在16年的时候就搭建了博客(虽然处于半废弃状态…)，于是就想着把他捡起来，重新开始Flynnon的博客之旅。 重建博客大约花费了四天，这段时间大约做了以下工作: 1. 建立博客。通过查看Hexo的官方文档，重新构建了对Hexo的认知，并建立了新的博客，并对之前的博文进行了迁移操作; 2. 选择主题。这一步花费了很长时间，我之前使用的主题是vno，它很不错，但是既然是重新来过，就把主题也一起换了…，最后选择了NexT主题，感觉它看起来很简洁，并且用户很活跃; 3. 定制化。主要是通过查看NexT的文档对博客进行配置，也添加了很多很使用的功能(Google Analytics etc.)。在这里主要参考了Ele的博客，构图什么的都是从那里偷的…. 4. 完善细节。这一步始终在进行…. 希望我可以坚持下去，搭建一个不错的博客吧….]]></content>
      <tags>
        <tag>杂记</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java控制访问权限的方法]]></title>
    <url>%2F2017%2F02%2F27-%E4%BB%A5%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%9F%90%E4%B8%80%E4%BD%8D%E7%BD%AE%E4%B8%BA%E7%95%8C%EF%BC%8C%E4%BA%A4%E6%8D%A2%E5%85%B6%E4%B9%8B%E5%89%8D%E4%B8%8E%E4%B9%8B%E5%90%8E%E7%9A%84%E9%83%A8%E5%88%86(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：给定一个字符串str和一个整数i，i代表字符串中某一个元素的下标，将str[0..i-1]移到这个元素的右侧，将str[i+1..len(str)-1]移到这个元素的左侧。(要求：时间复杂度为Ｏ(N),空间复杂度为Ｏ(1)).测试用例样例： 输入：”abcde”, 2 预期结果: decab 下面是Java实现： 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647/** * Created by Flynnon on 17-2-27. * 问题：给定一个字符串str和一个整数i，i代表字符串中某一个元素的下标，将str[0..i-1]移到这个元素的右侧，将str[i+1..len(str)-1]移到这个元素的左侧。 * 要求：时间复杂度为Ｏ(N),空间复杂度为Ｏ(1) */public class Test &#123; /** * 将一个数组以某一元素分界，将这个元素之前的部分与之后的部分互换位置 * 主要思路: 将之前的部分与之后的部分分别逆序，再将整体逆序即可 * @param str 要进行操作的字符串 * @param i 作为分界线的元素的下标 * @return 转化之后生成的字符串 */ public static String replaceBeginAndEnd(String str, int i) &#123; if (str == null || i &lt; 0 || str.length() &lt;= i) &#123; return str; &#125; char[] chars = str.toCharArray(); reverseCharArray(chars, 0, i - 1); reverseCharArray(chars, i + 1, chars.length - 1); reverseCharArray(chars, 0, chars.length - 1); return new String(chars); &#125; /** * 用来翻转一个数组的某一部分 * @param charArray 要进行操作的数组 * @param begin 要翻转的部分第一个元素的下标 * @param end 要翻转的部分最后一个元素的下标 */ public static void reverseCharArray(char[] charArray, int begin, int end) &#123; char tmp; while (begin &lt; end) &#123; tmp = charArray[begin]; charArray[begin] = charArray[end]; charArray[end] = tmp; begin++; end--; &#125; &#125; public static void main(String[] args) &#123; String str = "abcde"; System.out.println(replaceBeginAndEnd(str, 2)); &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[带行号遍历二叉树(Java实现)]]></title>
    <url>%2F2017%2F02%2F27-%E5%B8%A6%E8%A1%8C%E5%8F%B7%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：给定一颗二叉树，要求输出它的层序遍历，并在每行开始时输出行号。测试用例样例： 输入：节点值为1-7的满二叉树。 预期结果： 1 : 1 2 : 2 3 3 : 4 5 6 7 下面是Java实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;/* Created by Flynnon on 17-2-26. 对二叉树带行号的层序遍历的归纳 *//** * 定义节点类 * 为了简单就不定义getter/setter方法了 */class Node &#123; public int value; public Node left; public Node right; public Node() &#123; this(0); &#125; public Node(int v) &#123; this.value = v; this.left = null; this.right = null; &#125;&#125;/** * 对二叉树进行操作的工具类 */class PrintBinaryTree &#123; //私有化构造函数 private PrintBinaryTree() &#123; throw new RuntimeException("该工具类不应该被实例化"); &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下） * 主要思路：利用队列先进先出的性质保存顺序 * * @param root 要遍历的二叉树的根节点 */ public static void levelTraversal(Node root) &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); if (temp != null) &#123; System.out.print(temp.value + " "); q.add(temp.left); q.add(temp.right); &#125; &#125; &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下）,并附带行号 * 主要思路：利用队列先进先出的性质保存顺序来层序遍历二叉树。 * 使用curLineLast与nextLineLast两个节点标志来标识遍历过程中当前行结尾节点与下一行结尾节点， * 再使用一个lineNo整形量来记录当前行号（初始设为1），并在curLineLast节点更替时，更新lineNo的值并按格式打印即可。 * 注：nextLineLast始终指向最新遍历到的节点 * @param root 要遍历的二叉树的根节点 */ public static void levelTraversalWithLineNo(Node root) &#123; // 加入断言，保证root不为null assert root != null; // curLineLast : 当前行结尾节点 // nextLineLast : 下一行结尾节点 // 刚开始时，curLineLast与nextLineLast均指向根节点 Node curLineLast = root, nextLineLast = root; // 设根节点所在的行为第1行 int lineNo = 1; System.out.print(lineNo + " : "); Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); // 只有当前节点的子节点不为空时，nextLineLast才需要更改指向的目标 if (temp.left != null) &#123; q.add(temp.left); nextLineLast = temp.left; &#125; if (temp.right != null) &#123; q.add(temp.right); nextLineLast = temp.right; &#125; System.out.print(temp.value + " "); // 当出栈节点为当前行尾节点时，说明该换行了 if (curLineLast == temp) &#123; // 将当前行尾节点指向下一行尾节点 curLineLast = nextLineLast; System.out.print(System.lineSeparator() + ++lineNo + " : "); &#125; &#125; &#125;&#125;/** * 测试类 */public class BinaryTree &#123; // 以1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1为例 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = PrintBinaryTree.createTreeNode(sc); sc.close(); System.out.print("层序遍历:"); PrintBinaryTree.levelTraversal(root); System.out.println("带行号的层序遍历:"); PrintBinaryTree.levelTraversalWithLineNo(root); &#125;&#125; 下面是测试用例及结果，与预期结果一致（多出的一个行号先忽略了吧….）。 ![测试结果][1] 由于本人水平有限，本文难免存在谬误，欢迎批评指正！ [1]: https://i.loli.net/2018/11/18/5bf04097a1abd.png]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[遍历二叉树并用二维数组保存(Java实现)]]></title>
    <url>%2F2017%2F02%2F27-%E9%81%8D%E5%8E%86%E4%BA%8C%E5%8F%89%E6%A0%91%E5%B9%B6%E4%BD%BF%E7%94%A8%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%BF%9D%E5%AD%98(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。 给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列。保证结点数小于等于500。 测试用例样例： 输入：节点值为1-7的满二叉树。 预期结果： [1 ] [2,3] [4,5,6,7] 下面是Java实现： 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112import java.util.*;/** * Created by Flynnon on 17-2-27. * 问题：有一棵二叉树，请设计一个算法，按照层次打印这棵二叉树。 * 给定二叉树的根结点root，请返回打印结果，结果按照每一层一个数组进行储存，所有数组的顺序按照层数从上往下，且每一层的数组内元素按照从左往右排列. */public class BinaryTreeUtil &#123; /** * 定义节点类 * 为了简单就不定义getter/setter方法了 */ public static class Node &#123; public Node()&#123; this(0); &#125; public Node(int v)&#123; value = v; &#125; int value; Node left = null; Node right = null; &#125; /** * 进行转化的工具类 * 主要思路：主要思路与带行号层序遍历二叉树类似，只是用可变长数组（List）来存储每一行的元素 * @param root 要遍历的二叉树的根节点 * @return 此二叉树转化成的二维数组 */ public static int[][] getTreeValueArray(Node root) &#123; // 保证这颗二叉树非空 if (root == null) &#123; return new int[][]&#123;&#125;; &#125; // curLineLast : 当前行结尾节点 // nextLineLast : 下一行结尾节点 // 刚开始时，curLineLast与nextLineLast均指向根节点 Node curLineLast = root, nextLineLast = root; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); // 外层 List&lt;List&lt;Integer&gt;&gt; lists = new ArrayList&lt;&gt;(); // 内层 List&lt;Integer&gt; list = new ArrayList&lt;&gt;(); while (!q.isEmpty()) &#123; Node temp = q.poll(); // 只有当前节点的子节点不为空时，nextLineLast才需要更改指向的目标 if (temp.left != null) &#123; q.add(temp.left); nextLineLast = temp.left; &#125; if (temp.right != null) &#123; q.add(temp.right); nextLineLast = temp.right; &#125; // 将当前节点（值）加入内层 list.add(temp.value); // 当出栈节点为当前行尾节点时，说明该换行了 if (curLineLast == temp) &#123; // 换行时将内层加入到外层中 lists.add(list); // 新初始化一个内层 list = new ArrayList&lt;&gt;(); // 将当前行尾节点指向下一行尾节点 curLineLast = nextLineLast; &#125; &#125; // 将得到的List转化为int[] int[][] ints = new int[lists.size()][]; for (int i = 0; i &lt; ints.length; i++) &#123; Integer[] integerArray = lists.get(i).toArray(new Integer[0]); ints[i] = new int[integerArray.length]; for (int j=0;j&lt;integerArray.length;j++)&#123; ints[i][j] = integerArray[j]; &#125; &#125; return ints; &#125; /** * 前序递归构造二叉树 root-&gt;left-&gt;right * * @param scanner 输入流，用于读取节点值 * @return 构造完成的二叉树的根节点 */ public static Node createTreeNode(Scanner scanner) &#123; assert scanner != null; Node root = null; //声明当前根节点 int data = scanner.nextInt(); if (data &gt; 0) &#123; //若当前节点存在（这里为了简单以负数为占位符） root = new Node(data); //使用其它顺序构造二叉树，只需更改这三句即可 root.left = createTreeNode(scanner); root.right = createTreeNode(scanner); &#125; return root; &#125; /** * 测试类 * 以1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1为例 */ public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = Test.createTreeNode(sc); sc.close(); int[][] result = BinaryTreeUtil.getTreeValueArray(root); for (int[] arr : result) &#123; System.out.println(Arrays.toString(arr)); &#125; &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从m个各不相同的元素中取出n个并进行全排列(Java实现)]]></title>
    <url>%2F2017%2F02%2F26-%E4%BB%8Em%E4%B8%AA%E5%90%84%E4%B8%8D%E7%9B%B8%E5%90%8C%E7%9A%84%E5%85%83%E7%B4%A0%E4%B8%AD%E5%8F%96%E5%87%BAn%E4%B8%AA%E5%B9%B6%E8%BF%9B%E8%A1%8C%E5%85%A8%E6%8E%92%E5%88%97(Java%E5%AE%9E%E7%8E%B0).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要解决的问题是：从m个各不相同的元素中取出n个，进行全排列，得到所有可能的结果。 即：输入为字符数组（数组内每个字符均不相同）和个数n，返回由这些字符组成的所有长度为n的字符串。测试用例样例： 输入为{‘a’,’b’,’c’}和个数1，返回值为{“a”,”b”,”c”} 输入为{‘a’,’b’,’c’,’d’}和个数2，返回值为{“ab”,”ac”,”ad”,”ba”,”bc”,”bd”,”ca”,”cb”,”cd”,”da”,”db”,”dc”} 下面是Java实现： 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import java.util.ArrayList;import java.util.List;/** * Created by Flynnon on 17-2-26. */public class ListChars &#123; /** * @param chars 总的字符序列（数组） * @param n 要取出的字符的个数 */ public static void doit(char[] chars, int n) &#123; if (n &lt;= 0 || chars == null) &#123; return; &#125; List&lt;Character&gt; charList = new ArrayList&lt;&gt;(); //通过这一步初始化序列的长度 for (int i = 0; i &lt; n; i++) &#123; charList.add('#'); &#125; listAll(charList, chars, n); &#125; /** * 从m个元素中任取n个并对结果进行全排列 * @param list 用于承载可能的排列情况的List * @param chars 总的字符数组，长度为m * @param n 从中取得字符个数 */ public static void listAll(List&lt;Character&gt; list, char[] chars, int n) &#123; if (n == 0) &#123; //这里偷懒，直接打印了.... System.out.println(list); // 输出一种可能的排列 return; &#125; for (char aChar : chars) &#123; // 暴力尝试 if (!list.contains(aChar)) &#123; // 若List中不包含这一位元素 list.set(list.size() - n, aChar); // 将当前元素加入 &#125; else &#123; // 否则跳到下一位 continue; &#125; listAll(list, chars, n - 1); // 下一位 list.set(list.size() - n, '#'); // 还原 &#125; &#125; public static void main(String[] args) &#123; // 以字符数组承载总的字符集合 char[] chars = &#123;'a', 'b', 'c', 'd'&#125;; ListChars.doit(chars, 2); &#125;&#125; 下面是测试用例及结果，与预期结果一致。 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二叉树的递归构建及先序、中序、后序、层序遍历(Java实现)]]></title>
    <url>%2F2017%2F02%2F25-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E9%80%92%E5%BD%92%E6%9E%84%E5%BB%BA%E5%8F%8A%E5%85%88%E5%BA%8F%E3%80%81%E4%B8%AD%E5%BA%8F%E3%80%81%E5%90%8E%E5%BA%8F%E3%80%81%E5%B1%82%E5%BA%8F%E9%81%8D%E5%8E%86(%E9%80%92%E5%BD%92%E5%92%8C%E5%BE%AA%E7%8E%AF).html</url>
    <content type="text"><![CDATA[最近在看面试题的时候发现，一些基础的算法都记不住了，只是能大概说出个原理….为了加深记忆，这里对一些简单的算法题进行一个归纳。 下面的代码主要展示的是：二叉树的递归构建，先序、中序、后序遍历（递归和循环），层序遍历的Java语言实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213import java.util.LinkedList;import java.util.Queue;import java.util.Scanner;import java.util.Stack;/* Created by Flynnon on 17-2-25. 对二叉树的递归定义、前序、后序、中序、层序遍历方法的归纳 *//** * 定义节点类 * 为了简单就不定义getter/setter方法了 */class Node &#123; public int value; public Node left; public Node right; public Node() &#123; this(0); &#125; public Node(int v) &#123; this.value = v; this.left = null; this.right = null; &#125;&#125;/** * 对二叉树进行操作的工具类 */class PrintBinaryTree &#123; //私有化构造函数 private PrintBinaryTree()&#123; throw new RuntimeException("该工具类不应该被实例化"); &#125; /** * 层序遍历二叉树（每一行从左到右，整体上从上到下） * 主要思路：利用队列先进先出的性质保存顺序 * @param root 要遍历的二叉树的根节点 */ public static void levelTraversal(Node root) &#123; Queue&lt;Node&gt; q = new LinkedList&lt;&gt;(); q.add(root); while (!q.isEmpty()) &#123; Node temp = q.poll(); if (temp != null) &#123; System.out.print(temp.value + " "); q.add(temp.left); q.add(temp.right); &#125; &#125; &#125; /** * 前序遍历二叉树（递归） root-&gt;left-&gt;right * @param root 要遍历的二叉树的根节点 */ public static void preOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; System.out.print(root.value + " "); preOrderRec(root.left); preOrderRec(root.right); &#125; /** * 前序遍历二叉树（非递归） root-&gt;left-&gt;right * 主要思路：利用栈保存未打印的节点，然后逐个出栈处理，在此过程中更新栈 * @param root 要遍历的二叉树的根节点 */ public static void preOrderUnRec(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); Node temp; while (!stack.empty()) &#123; //root==null时，只会空转一个循环，因此无需判断 temp = stack.pop(); if (temp != null) &#123; System.out.print(temp.value + " "); stack.push(temp.right); //注意：这里的入栈顺序是先right后left stack.push(temp.left); // 以保证从栈中取出时为先left后right &#125; &#125; &#125; /** * 后序遍历二叉树（递归） * @param root 要遍历的二叉树的根节点 */ public static void postOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; postOrderRec(root.left); postOrderRec(root.right); System.out.print(root.value + " "); &#125; /** * 后序遍历二叉树（非递归） left-&gt;right-&gt;root * 主要思路：利用栈保存未打印的节点，然后逐个出栈，进行判断，并根据需要更新栈 * 因为是处理完左右子树后，再处理根(回溯)，所以需要一个记录上一个被打印的节点的引用 * @param root 要遍历的二叉树的根节点 */ public static void postOrderUnRec(Node root) &#123; if (root == null) &#123; return; &#125; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); stack.push(root); //cur:当前节点 pre:上一个被打印的节点 Node cur, pre = null; while (!stack.empty()) &#123; //查看（不是取出）栈顶的结点 cur = stack.peek(); //如果当前结点没有孩子结点（叶子节点） //或者孩子节点都已被打印过（这里不可能出现有两个子节点却只打印了其中一个的情况） //说明该打印当前节点了 if ((cur.left == null &amp;&amp; cur.right == null) || (pre != null &amp;&amp; (pre == cur.left || pre == cur.right))) &#123; System.out.print(cur.value + " "); //打印当前结点 stack.pop(); //被打印的节点（当前节点）出栈 pre = cur; //更新pre的值 &#125; else &#123; if (cur.right != null) //若未轮到当前节点，将当前节点的右节子点、左子节点入栈 stack.push(cur.right); //注意：这里的入栈顺序是先right后left if (cur.left != null) // 以保证从栈中取出时为先left后right stack.push(cur.left); &#125; &#125; &#125; /** * 中序遍历二叉树（递归） * @param root 要遍历的二叉树的根节点 */ public static void inOrderRec(Node root) &#123; if (root == null) &#123; return; &#125; inOrderRec(root.left); System.out.print(root.value + " "); inOrderRec(root.right); &#125; /** * 中序遍历二叉树（非递归） left-&gt;root-&gt;right * 主要思路：模拟递归的过程，将左子树节点不断的压入栈，直到左叶子，然后处理栈顶节点的右子树 * @param root 要遍历的二叉树的根节点 */ public static void inOrderUnRec(Node root) &#123; Stack&lt;Node&gt; stack = new Stack&lt;&gt;(); Node cur = root; //纯粹是为了好看...JVM会优化 while (cur != null || !stack.isEmpty()) &#123; //当root==null时，不会进入循环，因此无需判断 while (cur != null) &#123; //从当前节点开始，从上到下将最左边的那一列节点入栈 stack.push(cur); cur = cur.left; &#125; cur = stack.pop(); //取出栈顶的节点（该节点左节点为null，因此现在该打印它） System.out.print(cur.value + " "); cur = cur.right; //定位到已打印的节点的右子节点 &#125; &#125; /** * 前序递归构造二叉树 root-&gt;left-&gt;right * @param scanner 输入流，用于读取节点值 * @return 构造完成的二叉树的根节点 */ public static Node createTreeNode(Scanner scanner) &#123; assert scanner!=null; Node root = null; //声明当前根节点 int data = scanner.nextInt(); if (data &gt; 0) &#123; //若当前节点存在（这里为了简单以负数为占位符） root = new Node(data); //使用其它顺序构造二叉树，只需更改这三句即可 root.left = createTreeNode(scanner); root.right = createTreeNode(scanner); &#125; return root; &#125;&#125;/** * 测试类 */public class BinaryTree&#123; // 这里以节点值分别为1-7的满二叉树为例 // 1 2 4 -1 -1 5 -1 -1 3 6 -1 -1 7 -1 -1 public static void main(String[] args) &#123; Scanner sc = new Scanner(System.in); Node root = PrintBinaryTree.createTreeNode(sc); sc.close(); System.out.print("层序遍历:"); PrintBinaryTree.levelTraversal(root); System.out.print("\n中序递归遍历:"); PrintBinaryTree.inOrderRec(root); System.out.print("\n中序非递归遍历:"); PrintBinaryTree.inOrderUnRec(root); System.out.print("\n前序递归遍历:"); PrintBinaryTree.preOrderRec(root); System.out.print("\n前序非递归遍历:"); PrintBinaryTree.preOrderUnRec(root); System.out.print("\n后序递归遍历:"); PrintBinaryTree.postOrderRec(root); System.out.print("\n后序非递归遍历:"); PrintBinaryTree.postOrderUnRec(root); &#125;&#125; 这是测试结果截图（本测试用例没问题）： 由于本人水平有限，本文难免存在谬误，欢迎批评指正！]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Java控制访问权限的方法]]></title>
    <url>%2F2016%2F11%2F05-Java%E4%B8%AD%E6%8E%A7%E5%88%B6%E8%AE%BF%E9%97%AE%E6%9D%83%E9%99%90%E7%9A%84%E6%96%B9%E6%B3%95.html</url>
    <content type="text"><![CDATA[这篇博客主要用来介绍Java中的访问权限. 引入访问控制权限 我们都知道，一个通用类库(如：JDK)开发出来的目的是让普通开发者重用以节省开发时间与精力，但是类库的设计不可能在刚开始就尽善尽美，普通开发者在对类库的使用过程中，总能发现很多由于设计不当所出现的问题，这时，类库开发者就需要对类库进行重构。 而类库的更新不能影响到消费者程序的执行，这就引出了面向对象设计的一个基本问题：类库开发者如何区分可以变动的部分和不可以变动的部分？ Java这门语言在设计的时候吸收了很多前人的经验，所以这个问题也被抛了出来，而它解决这个问题的方法是通过访问修饰符，即限制普通开发者访问的部分。 对于访问权限成型的一些思考 在设计时很容易想到使用二分，即将访问权限分为可以访问与不能访问两种，也就是引入public与private。如果域被public修饰，说明这个部分可以被任何人访问到；如果域被private修饰，则除了当前类其他人都不能访问。但这样又会出现一些问题，即使用绝对的二分产生的副作用太大，被private修饰的域连类库开发者本身都无法访问了。 Java在引入包进行命名空间的管理之后，就有了一种较为优秀的解决方法，即引入friendly与protected，对于具有friendly访问权限的域，只有同一个包内的类可以访问；对于具有protected访问权限的域，只有此域所在类的子类或与此类在同一个包内的类可以访问，这样就划分了较为清楚的界限。 一般来说，用户自己写的类会被划分到自己特有的包中，这种情况下，这种访问权限控制的方式对于类库开发者与用户来说是正确的。但是，并不是所有的用户都会遵守规则，如果用户恶意使用类库开发者使用的包，还是会产生权限泄露，即用户访问到了类库开发者隐藏的东西。对于这种情况有什么解决方法么？ 个人认为：这个问题根本不是问题….因为权限控制实际上是一种约定，这种约定的内涵是：在使用双方都遵守的情况下，双方都可以得到较满意的答案（即：类库开发者拥有重构的 对于类库开发者来说唯一的约束是那些自己公开的API。也就是说对于已经公开的API，也许会有用户使用，这种情况下一定不能更改API以避免影响用户已经开发过的Java应用程序（保证向下兼容），那么对于类库开发者认为用户一定无法访问的部分就可以随便改了，在用户自己违反了约定的情况下，他的权益就无法也无需得到保证。 Java访问权限关键字介绍 上面说到Java中分了四种访问权限，一表胜千言，下面是详细的介绍。 关键字 含义 类内部 本包 子类 外部包 public 公有的 √ √ √ √ protected 受保护的 √ √ √ × default 缺省(包访问权限) √ √ × × private 私有的 √ × × × 一些需要注意的小问题 Java的权限控制只停留在编译期间。 它不会在编译生成的class文件中留下任何的痕迹，只在编译的时候进行访问控制的检查。因此，通过反射可以访问任何包下任何类中的成员，包括私有成员。 类的访问修饰符。 对于一个非内部类来说，因为它直属于包而不属于任何一个类，所以只有包访问权限与公有权限对它来说才有意义。也就是说，只能用public或者默认权限来修饰非内部类。 对于一个内部类来说，它直属于一个类，因此四种权限都可以对其起作用。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[初识AJAX]]></title>
    <url>%2F2016%2F09%2F06-%E5%88%9D%E8%AF%86AJAX.html</url>
    <content type="text"><![CDATA[这几天一直在看书，大致了解了AJAX技术，在这里做一个小小的总结。 简单了解AJAX 我觉得维基百科是比较准确的一个信息源，因此，我们先来看维基百科中对于AJAX的定义。 在维基百科上我们可以看到：AJAX即“Asynchronous JavaScript and XML”（异步的JavaScript与XML技术），指的是一套综合了多项技术的浏览器端网页开发技术。 那么，现在我们对AJAX有一个大致的印象：AJAX=JavaScript+XML。而js和xml我们至少都应该听说过。 AJAX为什么会出现 回顾我们的开发旅程，在使用Servlet+JSP+JavaBean开发基于B/S架构的应用的过程中，交互是如何实现的？用户在网页端填写并提交表单（Form），然后点击提交按钮向网页服务器发送请求（Request）。服务器接收请求并处理传来的表单，返回响应(Response)，浏览器取得响应信息后，通过解析将页面展示在浏览器上。 然而，这种模式存在很多问题。现在看这样一个例子：浏览器端展示了用户登陆界面，当用户输入用户名、密码及验证码后，数据被发送到了服务器，假定我们在Servlet中处理请求后发现用户名及密码不匹配，接下来的处理流程是什么样的？ 我们会将包含页面及错误信息的响应返回给浏览器端，浏览器在解析响应后对这些信息进行展示。使用这样的开发流程，无论后台业务逻辑实现的多么完美都会存在一些固有的问题： 首先，十分浪费带宽。在前后两个页面中除了展示错误信息的部分外其它元素全都是相同的，完全没有必要再次传输，在设计者的预想中，只需要对第一次的界面信息进行复用就可以了。 其次，用户体验差。在传统的开发模式下，假设我们是用户，一旦在登陆页面的表单中不小心输入了错误的密码(因为密码框是密文，所以无法得知具体的输入)，在提交表单后就会出现下列情况：等待一段时间后页面才被刷新、界面提示用户名错误、原来的输入都被清空。这样我们又得重新输入一遍用户名及密码，体验极不友好。在我们的的网速比较慢的情况下，体验还会更差。这对于产品经理及网站的用户来说都是不可忍受的。 那么有没有什么方法可以解决这种问题呢？也就是说，能不能在用户刚输入密码时就得到服务器端的反馈呢？ AJAX解决上述问题的思路 技术的更新总是一环套一环的，在js的XMLHttpRequest对象出现之前这个问题是没有优雅的解决办法的，只能使用一些丑陋的方法并且效果还不是特别好。但是在XMLHttpRequest对象出现之后，前辈们立刻就想到了一种比较好的解决方法，即：使用XMLHttpRequest对象作为Agent来将请求发送给服务器，并用它来接收服务器返回的数据，这样就可以不跳转页面完成数据的交互，而且只需要传输少量必要的数据，因此对网速的要求也变低了。 但是，还有两个问题没有解决： 1.如何根据服务器端返回的数据动态更改页面，以达到与用户交互的作用？ 2.如何规定服务器发送回来的数据格式？ 下面来看前辈们选择的解决方法： 对于1：前辈们选择了使用JavaScript。个人认为这样做的原因有两个，第一，JavaScript足够流行，几乎所有的主流浏览器都对JavaScript提供了支持；第二，JavaScript可以通过DOM编程的方式来动态的改变网页的内容。 对于2：前辈们选择了XML，我想可能是因为它语法足够严格、语义明确而且更加通用吧。但是我认为传输的数据格式对使用AJAX并没有影响。例如，我们可以选择传输Json来使传输的数据更加少，甚至可以只是传输一段有意义的字符串，只要服务器端开发者与浏览器端开发者对字符串格式进行了约定即可。 AJAX的准确定义 在了解了上面的内容后，我们就可以对AJAX进行一个准确的定义了：AJAX 是一种用于创建快速动态网页的技术。通过在后台与服务器进行少量数据交换，AJAX 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。 下面我们来看一下，如何利用AJAX技术进行开发。 使用AJAX开发的步骤-概述 关于AJAX更详细的介绍，可以查看W3School中对于AJAX的介绍 下面是我简单总结的AJAX实现步骤： 1. 我们需要一个XMLHttpRequest对象。（我们都知道IE低版本浏览器的标准很很多都与主流标准不兼容。很不幸，对于XMLHttpRequest对象也是一样的….） 因此，一个XMLHttpRequest对象的获取过程可以是这样的： 123456var httpXml = null;if(window.XMLHttpRequest)&#123; httpXml = new XMLHttpRequest(); //针对现代浏览器，IE7及以上版本&#125;else if(window.ActiveXObject)&#123; httpXml = new ActiveXObject("Microsoft.XMLHTTP"); //针对IE5,IE6版本&#125; 2.我们需要为这个XMLHttpRequest对象注册它要进行的操作（通过回调），并根据返回的请求状态与HTTP状态码来查看消息的状态，并确定在何种情况下我们要进行何种操作。 这个过程是这样的： 12345678//为XMLHttpRequest对象的onreadystatechange属性注册httpXml.onreadystatechange=function()&#123; // 在回调函数中根据请求状态与返回的HTTP状态码来选择相应的操作处理数据 if(httpXml.readyState==4&amp;&amp;httpXml.status==200)&#123; //这里只是简单的显示接收到的文本信息 alert(httpXml.responseText); &#125;&#125;; 3.我们需要进行请求发送的参数设置。 这个过程是这样的： 123456//函数原型：open(method,url,async,username,password)//method ---&gt;请求方式:GET,POST或HEAD//url ---&gt;请求的地址 GET提交方式可以在后面加上参数//async ---&gt;请求是否异步执行，true---异步，false---同步 默认为true//username,password ---&gt;可选，为url所需的授权提供认证资格。如果不为空，会覆盖掉url中指定的资格httpXml.open("GET","http://localhost:8080/aaa/MyServlet", true); 4.要真正的发送请求啦！ 1234// 参数为请求参数,POST提交内容格式为---&gt;"username=taffy&amp;password=666",GET为-----&gt;空// 注意：若为POST请求方式，还需设置一个http请求头(应该位于open之后,send之前)// 即 setRequestHeader("CONTENT-TYPE","application/x-www-form-urlencoded"); 标志form表单的enctype属性 httpXml.send(null); 这样，一个简单的AJAX过程就完成了。 一些没有介绍的小知识点： 12345678//XMLHttpRequest对象的重要属性responseText 得到返回的文本信息responseXML 得到返回的XML信息//XMLHttpRequest对象的重要方法getResponseHeader() 得到指定头部信息getAllResponseHeaders() 将 HTTP响应头部作为未解析的字符串返回//XMLHttpRequest对象的控制方法abort() 取消当前响应，关闭连接，将readyState置0 简单的Demoregister.html（客户端页面） javascript123456789101112131415161718192021222324252627282930313233343536373839&lt;!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd"&gt;&lt;html&gt;&lt;head&gt;&lt;meta http-equiv="Content-Type" content="text/html; charset=UTF-8"&gt;&lt;title&gt;Insert title here&lt;/title&gt;&lt;script type="text/javascript"&gt; &lt;!--&gt;onload:页面加载完成后调用 &lt;--&gt; window.onload = function()&#123; var user = document.getElementById("my_user"); //获取XMLHttpRequest对象 var httpXml = null; if(window.XMLHttpRequest)&#123; httpXml = new XMLHttpRequest(); //针对现代浏览器，IE7及以上版本 &#125;else if(window.ActiveXObject)&#123; httpXml = new ActiveXObject("Microsoft.XMLHTTP"); //针对IE5,IE6版本 &#125; user.onblur=function()&#123; httpXml.onreadystatechange=function()&#123; if(httpXml.readyState==4&amp;&amp;httpXml.status==200)&#123; if(httpXml.responseText!="true")&#123; alert("用户名不存在"); &#125; &#125; &#125;; httpXml.open("GET","http://localhost:8080/aaa/MyServlet?user="+user.value,true); httpXml.send(null); &#125;&lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="http://localhost:8080/aaa/AnotherServlet"&gt; &lt;input type="text" name="username" id="my_user"&gt; &lt;input type="text" name="password" id="my_pass"&gt; &lt;input type="submit" value="提交"&gt; &lt;/form&gt;&lt;/body&gt;&lt;/html&gt; MyServlet.java（服务器端逻辑） 123456789101112131415161718192021222324252627282930313233343536373839404142import java.io.IOException;import java.io.PrintWriter;import javax.servlet.ServletException;import javax.servlet.annotation.WebServlet;import javax.servlet.http.HttpServlet;import javax.servlet.http.HttpServletRequest;import javax.servlet.http.HttpServletResponse;/** * Servlet implementation class MyServlet */@WebServlet("/MyServlet")public class MyServlet extends HttpServlet &#123; private static final long serialVersionUID = 1L; /** * @see HttpServlet#HttpServlet() */ public MyServlet() &#123; super(); &#125; @override protected void doGet(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; PrintWriter out = response.getWriter(); String username = request.getParameter("user"); if (username!=null&amp;&amp;!username.equals("")) &#123; if (username.equals("admin")) &#123; out.write("true"); &#125;else &#123; out.write("false"); &#125; &#125;else &#123; out.write("false"); &#125; out.close(); &#125; @override protected void doPost(HttpServletRequest request, HttpServletResponse response) throws ServletException, IOException &#123; doGet(request, response); &#125;&#125; 上面的小demo可以正常实现逻辑，就不放结果了…. Ajax的优缺点 优点： 能在不更新整个页面的前提下维护数据。这使得Web应用程序更为迅捷地回应用户动作，并避免了在网络上发送重复的信息，减少了流量。 缺点： 1.它可能破坏浏览器的后退功能。在动态更新页面的情况下，用户无法回到前一个页面状态，因为浏览器仅能记下历史记录中的静态页面(现代浏览器一般都可以解决这个问题)； 2.使用动态页面更新使得用户难于将某个特定的状态保存到收藏夹中。 大致就是这样啦。本人水平有限，欢迎指正。]]></content>
      <categories>
        <category>学习之路</category>
      </categories>
      <tags>
        <tag>学习之路</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello Hexo!]]></title>
    <url>%2F2016%2F09%2F02-HelloHexo.html</url>
    <content type="text"><![CDATA[其实在很久之前我就想搭建一个个人博客，可是因为自己太懒，而且不敢去开始，所以一直没有付诸行动。最近几天，在看到了田浩同学分享的特别帅的个人博客页面后，想有一个自己个人博客的冲动突然就上来了。于是在经历了两天的漫无目的地寻找之后于2016-09-02成功建立了自己的个人博客。以后应该会将自己在学习的路上的一些想法与经验写在这里。不过话说回来….也不知道有没有人看….这里附上一些参考链接：建立这篇博客时参考的文章地址田浩同学帅炸了的博客]]></content>
      <categories>
        <category>随笔</category>
      </categories>
      <tags>
        <tag>随笔</tag>
      </tags>
  </entry>
</search>
